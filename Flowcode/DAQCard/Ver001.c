//************************************************************************************
//**  
//**  Source name:   D:\GitHub\Programming\Flowcode\DAQCard\Ver001.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F14K50
//**  
//**  Generated by:  Flowcode v6.1.3.2
//**  Date:          Wednesday, February 15, 2017 16:30:24
//**  Users:         -1
//**  Registered to: 88263627
//**  Licence key:   K38DMR
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 12000000
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0x38
#endif
#ifdef HI_TECH_C
__CONFIG(0x38);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0x1F
#endif
#ifdef HI_TECH_C
__CONFIG(0x1F);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0x1E
#endif
#ifdef HI_TECH_C
__CONFIG(0x1E);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0x8
#endif
#ifdef HI_TECH_C
__CONFIG(0x8);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x88
#endif
#ifdef HI_TECH_C
__CONFIG(0x88);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0x3
#endif
#ifdef HI_TECH_C
__CONFIG(0x3);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xC0
#endif
#ifdef HI_TECH_C
__CONFIG(0xC0);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0x3
#endif
#ifdef HI_TECH_C
__CONFIG(0x3);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xE0
#endif
#ifdef HI_TECH_C
__CONFIG(0xE0);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"

MX_UINT8 FCLV_LOOP1;


/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_OUTSTRING 2
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_OUTSTR;
MX_GLOBAL MX_UINT8 FCV_OPERATION;
MX_GLOBAL MX_UINT16 FCV_READINPUT;
MX_GLOBAL MX_CHAR FCV_OUTSTRING[FCVsz_OUTSTRING];


/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :dash_scale_vert1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII6
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII7
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII5
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII4
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII3
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII2
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII0
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1


/*========================================================================*\
   Use :PWM_Digital
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_0ba71_PWM_Digital__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_pwm
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define MX_PWM_REF1 
#define MX_PWM_PRESCALE1 (1)
#define MX_PWM_PIN_1 (5)
#define MX_PWM_PORT_1 portc
#define MX_PWM_PERIOD 255
#define MX_PWM_TRIS_1 trisc
#define MX_PWM_CHANNEL_1 (1)


/*=----------------------------------------------------------------------=*\
   Use :cal_pwm
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_PWM
#define MX_PWM_TMR_1 2

void FC_CAL_PWM_ChangePeriod_1(MX_UINT16 FCL_PERIOD, MX_UINT16 FCL_PRESCALER);
void FC_CAL_PWM_Disable_1();
void FC_CAL_PWM_SetDuty8Bit_1(MX_UINT8 FCL_DUTY);
void FC_CAL_PWM_Enable_1();
void FC_CAL_PWM_SetDuty10Bit_1(MX_UINT16 FCL_DUTY);

/*========================================================================*\
   Use :PWM1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_0df41_PWM1__ENABLED = (0x0);

void FCD_0df41_PWM1__ChangePeriod(MX_UINT16 FCL_PERIOD, MX_SINT16 FCL_PRESCALER);
void FCD_0df41_PWM1__Disable();
void FCD_0df41_PWM1__SetDutyCycle(MX_UINT8 FCL_DUTY);
void FCD_0df41_PWM1__Enable();
void FCD_0df41_PWM1__SetDutyCycle10Bit(MX_UINT16 FCL_DUTY);

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define ADC_2_MX_ADC_ACTIME 40
#define MX_ADC_REF 
#define ADC_2_MX_ADC_VREFVOL 500
#define MX_ADC_CHANNEL_8 
#define MX_ADC_TYPE_19 
#define ADC_2_MX_ADC_VREFOP 0
#define ADC_2_MX_ADC_CONVSP 3
#define MX_ADC_BITS_10 
#define ADC_2_MX_ADC_CHANNEL 8

#define FCV_0aae2_cal_adc__FALSE (0)
#define FCV_0aae2_cal_adc__TRUE (1)

void FC_CAL_ADC_Disable();
void FC_CAL_ADC_Enable(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_CAL_ADC_Sample(MX_UINT8 FCL_SAMPLE_MODE);

/*========================================================================*\
   Use :adc_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT16 FCD_08f42_adc_base__RawSampleInt();
MX_UINT8 FCD_08f42_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_08f42_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08f42_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_08f42_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_08f42_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_08f42_adc_base__GetVoltage();
void FCD_08f42_adc_base__RawEnable();
MX_UINT8 FCD_08f42_adc_base__RawSampleByte();
MX_UINT16 FCD_08f42_adc_base__GetInt();
void FCD_08f42_adc_base__RawDisable();
MX_UINT8 FCD_08f42_adc_base__GetByte();

/*========================================================================*\
   Use :v5__adc1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_03522_v5__adc1__RawSampleInt FCD_08f42_adc_base__RawSampleInt
#define FCD_03522_v5__adc1__RawAverageByte FCD_08f42_adc_base__RawAverageByte
#define FCD_03522_v5__adc1__GetString FCD_08f42_adc_base__GetString
#define FCD_03522_v5__adc1__GetAverageByte FCD_08f42_adc_base__GetAverageByte
#define FCD_03522_v5__adc1__RawAverageInt FCD_08f42_adc_base__RawAverageInt
#define FCD_03522_v5__adc1__GetAverageInt FCD_08f42_adc_base__GetAverageInt
#define FCD_03522_v5__adc1__GetVoltage FCD_08f42_adc_base__GetVoltage
#define FCD_03522_v5__adc1__RawEnable FCD_08f42_adc_base__RawEnable
#define FCD_03522_v5__adc1__RawSampleByte FCD_08f42_adc_base__RawSampleByte
#define FCD_03522_v5__adc1__GetInt FCD_08f42_adc_base__GetInt
#define FCD_03522_v5__adc1__RawDisable FCD_08f42_adc_base__RawDisable
#define FCD_03522_v5__adc1__GetByte FCD_08f42_adc_base__GetByte

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define ADC_1_MX_ADC_ACTIME 40
#define MX_ADC_REF 
#define ADC_1_MX_ADC_VREFVOL 500
#define MX_ADC_CHANNEL_7 
#define MX_ADC_TYPE_19 
#define ADC_1_MX_ADC_VREFOP 0
#define ADC_1_MX_ADC_CONVSP 3
#define MX_ADC_BITS_10 
#define ADC_1_MX_ADC_CHANNEL 7

#define FCV_0aae1_cal_adc__FALSE (0)
#define FCV_0aae1_cal_adc__TRUE (1)

void FC_CAL_ADC_Disable();
void FC_CAL_ADC_Enable(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_CAL_ADC_Sample(MX_UINT8 FCL_SAMPLE_MODE);

/*========================================================================*\
   Use :adc_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT16 FCD_08f41_adc_base__RawSampleInt();
MX_UINT8 FCD_08f41_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_08f41_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08f41_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_08f41_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_08f41_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_08f41_adc_base__GetVoltage();
void FCD_08f41_adc_base__RawEnable();
MX_UINT8 FCD_08f41_adc_base__RawSampleByte();
MX_UINT16 FCD_08f41_adc_base__GetInt();
void FCD_08f41_adc_base__RawDisable();
MX_UINT8 FCD_08f41_adc_base__GetByte();

/*========================================================================*\
   Use :v5__adc0
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_03521_v5__adc0__RawSampleInt FCD_08f41_adc_base__RawSampleInt
#define FCD_03521_v5__adc0__RawAverageByte FCD_08f41_adc_base__RawAverageByte
#define FCD_03521_v5__adc0__GetString FCD_08f41_adc_base__GetString
#define FCD_03521_v5__adc0__GetAverageByte FCD_08f41_adc_base__GetAverageByte
#define FCD_03521_v5__adc0__RawAverageInt FCD_08f41_adc_base__RawAverageInt
#define FCD_03521_v5__adc0__GetAverageInt FCD_08f41_adc_base__GetAverageInt
#define FCD_03521_v5__adc0__GetVoltage FCD_08f41_adc_base__GetVoltage
#define FCD_03521_v5__adc0__RawEnable FCD_08f41_adc_base__RawEnable
#define FCD_03521_v5__adc0__RawSampleByte FCD_08f41_adc_base__RawSampleByte
#define FCD_03521_v5__adc0__GetInt FCD_08f41_adc_base__GetInt
#define FCD_03521_v5__adc0__RawDisable FCD_08f41_adc_base__RawDisable
#define FCD_03521_v5__adc0__GetByte FCD_08f41_adc_base__GetByte

/*========================================================================*\
   Use :dash_IO_flasher1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :COMPort
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :v5__usbserial0
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define dev_name 40,3,'F',0,'l',0,'o',0,'w',0,'c',0,'o',0,'d',0,'e',0,' ',0,'U',0,'S',0,'B',0,' ',0,'S',0,'e',0,'r',0,'i',0,'a',0,'l',0
#define dev_name_count 40
#define dev_name_DS 'F','l','o','w','c','o','d','e',' ','U','S','B',' ','S','e','r','i','a','l'
#define dev_name_count_DS 19
#define MX_USB_TYPE3
#define timeout 10
#define RX_BUF_SZ (64)
#define MX_VID 4799
#define enumeration_tout 0
#define TX_BUF_SZ (64)
#define major_version 1
#define MX_PID 61456
#define dev_manufacturer 46,3,'M',0,'a',0,'t',0,'r',0,'i',0,'x',0,' ',0,'M',0,'u',0,'l',0,'t',0,'i',0,'m',0,'e',0,'d',0,'i',0,'a',0,' ',0,'L',0,'t',0,'d',0,'.',0
#define dev_manufacturer_count 46
#define dev_manufacturer_DS 'M','a','t','r','i','x',' ','M','u','l','t','i','m','e','d','i','a',' ','L','t','d','.'
#define dev_manufacturer_count_DS 22
#define minor_version 0


/*=----------------------------------------------------------------------=*\
   Use :v5__usbserial0
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_VERSION ((major_version << 8) | minor_version)

#ifdef MX_CAL_PIC							//8-bit PIC specific

	MX_UINT8 MX_USBNAME[dev_name_count] = {dev_name};		                    //Device name
	MX_UINT8 MX_USBMFR[dev_manufacturer_count] = {dev_manufacturer};			//Manufacturer

	// Global Defines
	#define CDC_TX_BUFFER_SIZE 	TX_BUF_SZ
	#define CDC_RX_BUFFER_SIZE 	RX_BUF_SZ
	#define CDC_DATA_ENDPOINT	3
	#define USB_HIGHEST_EP 		3
	#define USB_BUS_POWERED

	#ifdef MX_USB_TYPE1									//2455 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS	0x400
		#define USB_EP0_OUT_ADDR 	0x0500
		#define USB_EP0_IN_ADDR 	0x0508
		#define USB_EP2_IN_ADDR		0x0510
		#define USB_EP3_OUT_ADDR	0x0518
		#define USB_EP3_IN_ADDR		0x0520
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif

	#ifdef MX_USB_TYPE2									//2450 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS	0x400
		#define USB_EP0_OUT_ADDR 	0x0480
		#define USB_EP0_IN_ADDR 	0x0488
		#define USB_EP2_IN_ADDR		0x0490
		#define USB_EP3_OUT_ADDR	0x0498
		#define USB_EP3_IN_ADDR		0x04A0
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif

	#ifdef MX_USB_TYPE3									//14K50 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS	0x200
		#define USB_EP0_OUT_ADDR 	0x0280
		#define USB_EP0_IN_ADDR 	0x0288
		#define USB_EP2_IN_ADDR		0x0290
		#define USB_EP3_OUT_ADDR	0x0298
		#define USB_EP3_IN_ADDR		0x02A0
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif

	#ifdef MX_USB_TYPE4									//24J53 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS	0xD00
		#define USB_EP0_OUT_ADDR 	0x0E00
		#define USB_EP0_IN_ADDR 	0x0E08
		#define USB_EP2_IN_ADDR		0x0E10
		#define USB_EP3_OUT_ADDR	0x0E18
		#define USB_EP3_IN_ADDR		0x0E20
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif
	
	#ifdef MX_USB_TYPE5                                                             //16f1455 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS     0x2000
		#define USB_EP0_OUT_ADDR        0x2040
		#define USB_EP0_IN_ADDR         0x2048
		#define USB_EP2_IN_ADDR		    0x2050
		#define USB_EP3_OUT_ADDR	    0x2058
		#define USB_EP3_IN_ADDR		    0x2060
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif

	#ifdef MX_USB_TYPE6                                                             //18F45K50 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS     0x400
		#define USB_EP0_OUT_ADDR        0x0500
		#define USB_EP0_IN_ADDR         0x0508
		#define USB_EP2_IN_ADDR		    0x0510
		#define USB_EP3_OUT_ADDR	    0x0518
		#define USB_EP3_IN_ADDR		    0x0520
		#define PIRREG  		pir3
		#define PIEREG  		pie3
	#endif

	#ifndef USB_DESCRIPTOR_BASE_ADDRESS
		#error "Target device does not have USB functionality"
	#endif

	#ifdef HI_TECH_C
		#error "USB library only supported by the BoostC compiler"
	#endif

	#define USB_EP0_OUT_SIZE 	8
	#define USB_EP0_IN_SIZE 	8
	#define USB_EP2_IN_SIZE		8
	#define USB_EP3_OUT_SIZE	8
	#define USB_EP3_IN_SIZE		8

	#define USB_CALLBACK_ON_SOF
	#define USB_CALLBACK_ON_DEVICE_CONFIGURED
	#define USB_CALLBACK_ON_CTRL_CLASS
	#define USB_EP_DATA_CALLBACK

	//Serial Number
	MX_UINT8 MX_SERIAL[10] = {10,3,'0',0,'0',0,'0',0,'1',0};

	// USB library includes
	#include "../../../../CAL/PIC/USB/pic_utils.h"
	#include "../../../../CAL/PIC/USB/pic_usb_buffer_mgt.c"
	#include "../../../../CAL/PIC/USB/pic_usb.c"
	#include "../../../../CAL/PIC/USB/usb_cdc_class.c"
	#include "../../../../CAL/PIC/USB/usb_config_serial.c"

	// Variable to hold status of the USB connection
	MX_UINT8 CDC_USB_status = 0;

	// Variable to hold incoming data
	MX_UINT8 CDC_USB_Rx_String[CDC_RX_BUFFER_SIZE];

	void usb_device_configured_callback(void)
	{
		CDC_USB_status = 1;
	}

#endif

#ifdef MX_CAL_PIC16					//16-bit PIC specific

	#ifndef MX_USB_TYPE1
		#error "Your target device does not support USB components"
	#endif

	// Global Defines
	#define USB_BUS_SENSE       1
	#define self_power          1
	#define tris_usb_bus_sense	1
	#define tris_self_power		1

	#define USB_CONFIG	"usb_serial_config.h"

	// USB library includes
	#include "../../../CAL/PIC16BIT/USB/usb_serial_config.h"
	#include "../../../CAL/PIC16BIT/USB/usb.h"
	#include "../../../CAL/PIC16BIT/USB/usb_function_cdc.h"
	#include "../../../CAL/PIC16BIT/USB/GenericTypeDefs.h"
	#include "../../../CAL/PIC16BIT/USB/Compiler.h"
	#include "../../../CAL/PIC16BIT/USB/usb_device.h"
	#include "../../../CAL/PIC16BIT/USB/usb_device.c"
	#include "../../../CAL/PIC16BIT/USB/usb_ch9.h"
    #if defined(__dsPIC33E__) 
      #include "../../../CAL/PIC16BIT/USB/usb_hal_dspic33e.c"
    #elif defined(__PIC24E__)
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24e.c"
    #else
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24.c"
    #endif
	#include "../../../CAL/PIC16BIT/USB/usb_function_cdc.c"
	#include "../../../CAL/PIC16BIT/USB/usb_common.h"
	#include "../../../CAL/PIC16BIT/USB/usb_hal.h"
    #if defined(__dsPIC33E__) 
      #include "../../../CAL/PIC16BIT/USB/usb_hal_dspic33e.h"
    #elif defined(__PIC24E__)
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24e.h"
    #else
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24.h"
    #endif
	
	// Device name and manufacturer
	ROM struct{BYTE bLength;BYTE bDscType;WORD string[dev_name_count_DS];}sd001={sizeof(sd001),USB_DESCRIPTOR_STRING,{dev_name_DS}};
	ROM struct{BYTE bLength;BYTE bDscType;WORD string[dev_manufacturer_count_DS];}sd002={sizeof(sd002),USB_DESCRIPTOR_STRING,{dev_manufacturer_DS}};

	#include "../../../CAL/PIC16BIT/USB/usb_serial_descriptors.c"
    #include "../../../CAL/PIC16BIT/USB/usb_cdc_handler.c"

#endif


#ifdef MX_CAL_AVR					//AVR specific

#include "config.h"
#include "lib_mcu/usb/usb_drv.h"
#include "modules\usb\device_chap9\usb_standard_request.h"
#include "usb_specific_request.h"
#include "uart_usb_lib.h"

extern U8    rx_counter;
extern U8    tx_counter;

S_line_coding line_coding;
S_line_status line_status;      // for detection of serial state input lines
S_serial_state serial_state;    // for serial state output lines

#endif

MX_UINT8 FCD_056e1_v5__usbserial0__SendString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA);
void FCD_056e1_v5__usbserial0__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_TIMEOUT_MS, MX_UINT8 FCL_LENGTH);
MX_UINT8 FCD_056e1_v5__usbserial0__SendByte(MX_UINT8 FCL_DATA);
MX_UINT16 FCD_056e1_v5__usbserial0__ReadByte(MX_UINT8 FCL_TIMEOUT_MS);
MX_UINT8 FCD_056e1_v5__usbserial0__Initialise();

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :dash_scale_vert1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII6
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :PWM_Digital
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Parameters for macro ReadASCIILUT:
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_PWM_Digital__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Local variable definitions
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_pwm
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :PWM1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the overall period and prescaler of the output PWM signal.
       :
       :Parameters for macro ChangePeriod:
       :  Period : The maximum number that will represent 100% on, PIC/AVR: 0-255 16-bit PIC: 0-65535
       :  Prescaler : The scaler used to divide the system clock speed down to the PWM rate.
\*=----------------------------------------------------------------------=*/
void FCD_0df41_PWM1__ChangePeriod(MX_UINT16 FCL_PERIOD, MX_SINT16 FCL_PRESCALER)
{

	FC_CAL_PWM_ChangePeriod_1(FCL_PERIOD, FCL_PRESCALER);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables a PWM channel and allows the default output / input state to be resumed
\*=----------------------------------------------------------------------=*/
void FCD_0df41_PWM1__Disable()
{

	FCV_0df41_PWM1__ENABLED = 0;

	FC_CAL_PWM_Disable_1();

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the PWM duty cycle in terms of on/off based on the current period setting.
       :E.g. if period = 255 then duty of 128 is equal to 50% on and 50% off.
       :16-bit PIC users should use the 10bit duty function to access the full range.
       :
       :Parameters for macro SetDutyCycle:
       :  Duty : 8-bit PWM duty 0-255
\*=----------------------------------------------------------------------=*/
void FCD_0df41_PWM1__SetDutyCycle(MX_UINT8 FCL_DUTY)
{

	if (FCV_0df41_PWM1__ENABLED)
	{

		FC_CAL_PWM_SetDuty8Bit_1(FCL_DUTY);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Enables a PWM channel as an output overriding the default output pin state.
\*=----------------------------------------------------------------------=*/
void FCD_0df41_PWM1__Enable()
{

	FCV_0df41_PWM1__ENABLED = 1;

	FC_CAL_PWM_ChangePeriod_1(255, 1);

	FC_CAL_PWM_Enable_1();

}

/*=----------------------------------------------------------------------=*\
   Use :PIC/AVR - Sets the full scale PWM duty cycle based on the current period setting.
       :If period = 255 then Duty of 512 is equal to 50%.
       :
       :16-bit PICs have a 16-bit period range available.
       :If period = 65535 then Duty of 32768 is equal to 50%.
       :
       :Parameters for macro SetDutyCycle10Bit:
       :  Duty : PWM duty PIC/AVR: 0-1023 16-bit PIC: 0-65535
\*=----------------------------------------------------------------------=*/
void FCD_0df41_PWM1__SetDutyCycle10Bit(MX_UINT16 FCL_DUTY)
{

	if (FCV_0df41_PWM1__ENABLED)
	{

		FC_CAL_PWM_SetDuty10Bit_1(FCL_DUTY);

	// } else {

	}

}


/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :adc_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f42_adc_base__RawSampleInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as as tring
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_08f42_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_FLOAT FCL_SAMPLE;


	FCL_SAMPLE = FCD_08f42_adc_base__GetVoltage();

	FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL,20);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCR_RETVAL = FCD_08f42_adc_base__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_08f42_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT32 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f42_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCR_RETVAL = FCD_08f42_adc_base__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08f42_adc_base__GetVoltage()
{
	//Local variable definitions
	MX_UINT16 FCL_SAMPLE;
	MX_FLOAT FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCL_SAMPLE = FC_CAL_ADC_Sample(1);

	FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.004883);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_08f42_adc_base__RawEnable()
{

	FC_CAL_ADC_Enable(8, 3, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__RawSampleByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f42_adc_base__GetInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_08f42_adc_base__RawDisable()
{

	FC_CAL_ADC_Disable();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__GetByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :v5__adc1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :adc_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__RawSampleInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as as tring
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_FLOAT FCL_SAMPLE;


	FCL_SAMPLE = FCD_08f41_adc_base__GetVoltage();

	FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL,20);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCR_RETVAL = FCD_08f41_adc_base__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_08f41_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT32 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCR_RETVAL = FCD_08f41_adc_base__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08f41_adc_base__GetVoltage()
{
	//Local variable definitions
	MX_UINT16 FCL_SAMPLE;
	MX_FLOAT FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCL_SAMPLE = FC_CAL_ADC_Sample(1);

	FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.004883);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__RawEnable()
{

	FC_CAL_ADC_Enable(7, 3, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__RawSampleByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__GetInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__RawDisable()
{

	FC_CAL_ADC_Disable();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__GetByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :v5__adc0
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :COMPort
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :v5__usbserial0
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sends the specified data string to the host
       :
       :Parameters for macro SendString:
       :  Data[20] : Data string to send to the host
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_v5__usbserial0__SendString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)
{
	//Local variable definitions
	MX_UINT16 FCL_TIMEOUT = (0x0);
	MX_UINT8 FCL_LENGTH;
	MX_UINT8 FCR_RETVAL;


	FCL_LENGTH = FCI_GETLENGTH(FCL_DATA, FCLsz_DATA);

	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		MX_UINT8 n;

		while (usb_cdc_tx_empty() == 0 && FCL_TIMEOUT < 32000)	//Wait for outgoing buffer to empty
			FCL_TIMEOUT = FCL_TIMEOUT + 1;

		if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			return(1);

		// Flowcode strings are not necessarily null terminated
		// so we cannot use  usb_cdc_print_str(FCL_DATA);
		for(n = 0 ; (FCL_DATA[n] != 0)&&(n < FCL_LENGTH); n++)
		{
			usb_cdc_putc(FCL_DATA[n]);
		}

	  #endif

	  #ifdef MX_CAL_PIC16	//16-bit PIC specific

		if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1))
		{
			return(2);	    //USB Not Configured
		}
		else
		{
			CDCTxService();		//Required or every other send fails

			while (mUSBUSARTIsTxTrfReady() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
				FCL_TIMEOUT = FCL_TIMEOUT + 1;

			if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			{
				return(1);		//USB Not Ready
			}
			else
			{
				putUSBUSART(FCL_DATA, FCL_LENGTH);
			}
		}
		CDCTxService();

	  #endif

	#ifdef MX_CAL_AVR          //AVR specific

	        MX_UINT8 n;

	        if(!Is_device_enumerated()) {
	            return(2);
	        } else {
	            for(n = 0; (FCL_DATA[n] != 0) && (n < FCL_LENGTH); n++) {
	                FCL_TIMEOUT = 0;
	                while((!uart_usb_tx_ready()) && (FCL_TIMEOUT < 32000))
	                    FCL_TIMEOUT++;

	                if(FCL_TIMEOUT == 32000) {
	                    return(1);
	                } else {
	                    uart_usb_putchar(FCL_DATA[n]);
	                    Usb_ack_in_ready();
	                }
	            }
	        }

	#endif


	FCR_RETVAL = 0;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Retreives a string from the incoming data buffer. If data is available then the macro will return straight away. If there is no data available then the macro waits up the the period specified by the timeout before returning the value 255.
       :
       :Parameters for macro ReadString:
       :  Timeout_ms : Length of time to wait before timing out
       :  Length : Maximum number of bytes to try and read
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_056e1_v5__usbserial0__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_TIMEOUT_MS, MX_UINT8 FCL_LENGTH)
{
	//Local variable definitions
	MX_UINT8 FCL_WAIT_FOREVER = (0x0);


	  #ifdef MX_CAL_PIC			//8-bit PIC specific

		MX_UINT8 Rx_Length;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER)
		{
			Rx_Length = usb_cdc_rx_avail();		// get length of incoming data string
			if (Rx_Length)
			{
				if (Rx_Length > FCL_LENGTH)
					Rx_Length = FCL_LENGTH;

				usb_ep_get_rx_buffer(Rx_Length, FCR_RETVAL);	// copy data string to local buffer

				if (Rx_Length < FCL_LENGTH)
					FCR_RETVAL[Rx_Length] = 0;		//Add null MX_UINT8acter to end of string
				return;
			}
			else
			{
				Wdt_Delay_Ms(1);
				FCL_TIMEOUT_MS = FCL_TIMEOUT_MS - 1;
			}
		}

	  #endif

	  #ifdef MX_CAL_PIC16									//16-bit PIC specific

		MX_UINT8 inner = 0;
		MX_UINT16 numBytesRead = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while(numBytesRead == 0 && FCL_TIMEOUT_MS > 0)
		{
			numBytesRead = getsUSBUSART(FCR_RETVAL, FCL_LENGTH);
			if ((FCL_WAIT_FOREVER == 0) && (numBytesRead == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
		}

	  #endif

	  #ifdef MX_CAL_AVR			//AVR specific

		MX_UINT8 Rx_Length = 0;
		MX_UINT8 inner = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER) {
	        if(uart_usb_test_hit()) {
	            FCL_WAIT_FOREVER = 0;
	            while(uart_usb_test_hit() && (Rx_Length <= FCL_LENGTH)) {
	                FCR_RETVAL[Rx_Length++] = uart_usb_getchar();
	            }
	        } else {
				inner++;
				delay_us(10);
				if (inner == 100) {
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
	        }
	    }
		if (Rx_Length < FCL_LENGTH)
		    FCR_RETVAL[Rx_Length] = 0;		//Add null MX_UINT8acter to end of string

	  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Sends the specified data byte to the host
       :
       :Parameters for macro SendByte:
       :  data : Data byte to send to the host
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_v5__usbserial0__SendByte(MX_UINT8 FCL_DATA)
{
	//Local variable definitions
	MX_UINT16 FCL_TIMEOUT = (0x0);
	MX_UINT8 FCR_RETVAL;


	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		while (usb_cdc_tx_empty() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
			FCL_TIMEOUT = FCL_TIMEOUT + 1;

		if (FCL_TIMEOUT == 32000)			//Pipeline full or disconnected
			return(1);

		usb_cdc_putc(FCL_DATA);

	  #endif

	  #ifdef MX_CAL_PIC16		//16-bit PIC specific

	  	if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1))
	  	{
	  		return(2);		//USB Not Configured
	  	}
	  	else
	  	{
			CDCTxService();													//Required or every other send fails
			while (mUSBUSARTIsTxTrfReady() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
				FCL_TIMEOUT = FCL_TIMEOUT + 1;

			if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			{
				return(1);		//USB Not Ready
			}
			else
			{
				putUSBUSART(&FCL_DATA,1);
			}
		}
		CDCTxService();

	  #endif

	#ifdef MX_CAL_AVR          //AVR specific
	        if(!Is_device_enumerated()) {
	            return(2);
	        } else {
	            Usb_select_endpoint(TX_EP);
	            while((uart_usb_tx_ready() == 0) && (FCL_TIMEOUT < 32000))
	                FCL_TIMEOUT++;

	            if(FCL_TIMEOUT == 32000) {
	                return(1);
	            } else {
	                uart_usb_putchar(FCL_DATA);
	                Usb_ack_in_ready();
	            }
	        }
	#endif


	FCR_RETVAL = 0;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Retreives the byte from the incoming data buffer. If data is available then the macro will return straight away. If there is no data available then the macro waits up the the period specified by the timeout before returning the value 255.
       :
       :Parameters for macro ReadByte:
       :  Timeout_ms : Number of milliseconds to wait before timing out
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_056e1_v5__usbserial0__ReadByte(MX_UINT8 FCL_TIMEOUT_MS)
{
	//Local variable definitions
	MX_UINT8 FCL_WAIT_FOREVER = (0x0);
	MX_UINT16 FCR_RETVAL;


	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	#else

		FCR_RETVAL = 255;

	#endif

	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		static MX_UINT8 position = 0;
		static MX_UINT8 length = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		if (position == length)									// end of local string?
		{
			position = 0;

			length = usb_cdc_rx_avail();						// get length of incoming data string

			while (length == 0 && (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER))	// wait for timeout_ms
			{
				Wdt_Delay_Ms(1);
				length = usb_cdc_rx_avail();					// get length of incoming data string
				FCL_TIMEOUT_MS = FCL_TIMEOUT_MS - 1;			// decrement timeout_ms
			}

			if(length == 0)
				return (FCR_RETVAL);							// return no data flag 255 / 0xFF

			usb_ep_get_rx_buffer(length, CDC_USB_Rx_String);	// copy data string to local buffer
		}

		FCR_RETVAL = CDC_USB_Rx_String[position];

		position = position + 1;

		return (FCR_RETVAL);

	  #endif

	  #ifdef MX_CAL_PIC16									//16-bit PIC specific

		MX_UINT8 retval[1];
		MX_UINT8 inner = 0;
		MX_UINT16 numBytesRead = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while(numBytesRead == 0 && FCL_TIMEOUT_MS > 0)
		{
			numBytesRead = getsUSBUSART(retval,1);
			if ((FCL_WAIT_FOREVER == 0) && (numBytesRead == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
	        else
	            FCR_RETVAL = retval[0];
		}
		return (FCR_RETVAL);

	  #endif

	  #ifdef MX_CAL_AVR		//AVRspecific

	    MX_UINT8 rx_rdy = 0;
	    MX_UINT8 inner = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while((rx_rdy == 0) && (FCL_TIMEOUT_MS > 0))
		{
			rx_rdy = uart_usb_test_hit();
	        if(rx_rdy)
	            FCR_RETVAL = uart_usb_getchar();

			if ((FCL_WAIT_FOREVER == 0) && (rx_rdy == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
		}
		return (FCR_RETVAL);
	  #endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Starts up the USB communications and attempts to enumerate.
       :Returns 0 for a successful startup or 255 for a enumeration timeout.
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_v5__usbserial0__Initialise()
{
	//Local variable definitions
	MX_UINT16 FCL_DELAY_COUNTER = (0x0);
	MX_UINT8 FCR_RETVAL;


	#ifdef MX_CAL_PIC                                //8-bit PIC specific
	  #if defined(P18F24J50) || defined(P18F25J55) || defined(P18F26J50) || defined(P18F44J50) || defined(P18F45J50) || defined(P18F46J55) || defined(P18F87J50) ||  defined(P18F86J55) || defined(P18F86J50) || defined(P18F85J50) || defined(P18F67J50) || defined(P18F66J55) || defined(P18F66J50) || defined(P18F65J50)
	  //On the PIC18F87J50 Family of USB microcontrollers, the PLL will not power up and be enabled
	  //by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
	  //This allows the device to power up at a lower initial operating frequency, which can be
	  //advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
	  //operation.  On these devices, user firmware needs to manually set the OSCTUNE&lt;PLLEN&gt; bit to
	  //power up the PLL.
	  {
	      MX_UINT16 pll_startup_counter = 600;
	      OSCTUNEbits.PLLEN = 1;  //Enable the PLL and wait 2+ms until the PLL locks before enabling USB module
	      while(pll_startup_counter--);
	  }
	  //Device switches over automatically to PLL output after PLL is locked and ready.
	  #endif
	#endif

	#ifdef MX_CAL_PIC16                        //16-bit PIC specific
	  #if defined(P24FJ64GB004) || defined(P24FJ64GB002) || defined(P24FJ32GB004) || defined(P24FJ32GB002)
	  //On the PIC24FJ64GB004 Family of USB microcontrollers, the PLL will not power up and be enabled
	  //by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
	  //This allows the device to power up at a lower initial operating frequency, which can be
	  //advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
	  //operation.  On these devices, user firmware needs to manually set the CLKDIV&lt;PLLEN&gt; bit to
	  //power up the PLL.
	  {
	      MX_UINT16 pll_startup_counter = 600;
	      CLKDIVbits.PLLEN = 1;
	      while(pll_startup_counter--);
	  }
	  #endif
	#endif

	#ifdef MX_CAL_AVR                          //ATmega or AT90
	//  #if defined(AT90USB162)
	//  {
	      Usb_enable_regulator();
	//  }
	//  #endif
	#endif

	  #ifdef MX_CAL_PIC					//8-bit PIC specific
		usb_configure_structures();
		kill_interrupts();						//turn off interrupts just in case
		usb_cdc_setup();
		usb_setup();
		turn_peripheral_ints_on();
		turn_global_ints_on();
		usb_enable_module();
	  #elif defined MX_CAL_PIC16							//16-bit PIC specific
		USBDeviceInit();
		if(USB_BUS_SENSE && (USBGetDeviceState() == DETACHED_STATE))
			USBDeviceAttach();
	  #elif defined MX_CAL_AVR
	      usb_task_init();
	  #endif

	#if (0)

	//Code has been optimised out by the pre-processor
	#else

		#ifdef MX_CAL_PIC			//8-bit PIC specific
		  while(CDC_USB_status == 0);
		#elif defined MX_CAL_PIC16					//16-bit PIC specific
		  while(USBDeviceState != CONFIGURED_STATE);
		#elif defined MX_CAL_AVR
		  while(Is_device_enumerated() == 0) {
		    usb_task();
		  }
		  uart_usb_init();
		#endif

		FCR_RETVAL = 0;

	#endif

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/


/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()
{
ansel = 0x00;
anselh = 0x00;




	// Call Component Macro
	// Call Component Macro: PWM1::Enable()
	FCD_0df41_PWM1__Enable();

	// Call Component Macro
	// Call Component Macro: v5__usbserial0::Initialise()
	FCD_056e1_v5__usbserial0__Initialise();

	// Loop
	// Loop: While 1
	while (1)
	{

		// Call Component Macro
		// Call Component Macro: Operation=v5__usbserial0::ReadByte(10)
		FCV_OPERATION = FCD_056e1_v5__usbserial0__ReadByte(10);

		// Switch
		// Switch: Operation?
		switch (FCV_OPERATION)
		{
			case 0x31:
			{
				// Call Component Macro
				// Call Component Macro: ReadInput=v5__adc0::GetInt()
				FCV_READINPUT = FCD_03521_v5__adc0__GetInt();

				// Calculation
				// Calculation:
				//  //ReadInput = 1024
				//  ReadInput = ((ReadInput << 1) | 0x1001)
				//  OutString[0] = ReadInput
				//  OutString[1] = (ReadInput >> 8)
				FCV_READINPUT = ((FCV_READINPUT << 1) | 0x1001);
				FCV_OUTSTRING[0] = FCV_READINPUT;
				FCV_OUTSTRING[1] = (FCV_READINPUT >> 8);

				// Call Component Macro
				// Call Component Macro: v5__usbserial0::SendString(OutString)
				FCD_056e1_v5__usbserial0__SendString(FCV_OUTSTRING, FCVsz_OUTSTRING);

				break;
			}
			case 0x32:
			{
				// Call Component Macro
				// Call Component Macro: ReadInput=v5__adc1::GetInt()
				FCV_READINPUT = FCD_03522_v5__adc1__GetInt();

				// Calculation
				// Calculation:
				//  //ReadInput = 1024
				//  ReadInput = ((ReadInput << 1) | 0x1001)
				//  OutString[0] = ReadInput
				//  OutString[1] = (ReadInput >> 8)
				FCV_READINPUT = ((FCV_READINPUT << 1) | 0x1001);
				FCV_OUTSTRING[0] = FCV_READINPUT;
				FCV_OUTSTRING[1] = (FCV_READINPUT >> 8);

				// Call Component Macro
				// Call Component Macro: v5__usbserial0::SendString(OutString)
				FCD_056e1_v5__usbserial0__SendString(FCV_OUTSTRING, FCVsz_OUTSTRING);

				break;
			}
			// default:

		}


	}

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{

	

	#ifdef MX_CAL_PIC 
	  usb_handle_isr(); 
	#endif 
}




