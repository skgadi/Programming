;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)

{
    char i;
    for (i=0; i<delay; i++)
0D1A  6B6D      	CLRF Wdt_Delay__00039_1_i, 1
0D1C            label85
0D1C  516C      	MOVF Wdt_Delay__00039_arg_delay, W, 1
0D1E  616D      	CPFSLT Wdt_Delay__00039_1_i, 1
0D2C  2B6D      	INCF Wdt_Delay__00039_1_i, F, 1
0D2E  D7F6      	BRA	label85

    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
0D22  0004      	CLRWDT

        delay_ms(1);
0D24  0E01      	MOVLW 0x01
0D26  6F6E      	MOVWF delay_ms_00000_arg_del, 1
0D28  EC09F000  	CALL delay_ms_00000

    }
}
0D20  0012      	RETURN



void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



//************************************************************************************
//**  
//**  File name:     D:\GitHub\Programming\Flowcode\DAQCard\Ver000.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.4.0.0
//**  Date:          Tuesday, February 14, 2017 17:54:36
//**  Licence:       Professional
//**  Registered to: asdf
//**  Licence key:   DEEZ38
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 1
#define MX_USES_CHAR 2
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P18F14K50
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_19
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE3
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portb
#define MX_SPI_1_MISO_TRIS trisb
#define MX_SPI_1_MISO_PIN 0
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 7
#define MX_SPI_1_CLK_PORT portb
#define MX_SPI_1_CLK_TRIS trisb
#define MX_SPI_1_CLK_PIN 1
#define MX_SPI_1_SS_PORT porta
#define MX_SPI_1_SS_TRIS trisa
#define MX_SPI_1_SS_PIN 5
#define MX_UART_1
#define MX_UART_1_TX_PORT portb
#define MX_UART_1_TX_TRIS trisb
#define MX_UART_1_TX_PIN 7
#define MX_UART_1_RX_PORT portb
#define MX_UART_1_RX_TRIS trisb
#define MX_UART_1_RX_PIN 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portb
#define MX_I2C_1_SDA_TRIS trisb
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portb
#define MX_I2C_1_SCL_TRIS trisb
#define MX_I2C_1_SCL_PIN 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 5
#define MX_USB_TYPE3

//Functions
#define MX_CLK_SPEED 12000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic18.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x300000, 0x38
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0x1f
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0x1e
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xff
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x8
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0x88
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xff
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0x3
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xc0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0x3
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xe0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0x3
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0x40
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations


//Variable declarations
#define FCSZ_OUTSTRING 2
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_SINT16 FCV_READINPUT;
MX_UINT8 FCV_OUTSTR;
MX_UINT8 FCV_OPERATION;
MX_CHAR FCV_OUTSTRING[FCSZ_OUTSTRING];




//USBSerial(0): //Defines:

/**** Macro Substitutions ****
a = Vendor ID
b = Product ID
c = Device Name
d = Device manufacturer
e = Version Number A
f = Version Number B
g = Enumeration Wait Enable
h = Enumeration Wait Time
k = Length of Device Name String
l = Length of Device Manufacturer String
******************************/

	// Component Defines
	#define MX_VID 			0x12BF				//Eg 0x04D8
	#define MX_PID 			0xF010				//Eg 0x000C

	#define MX_VERSION		(1	<< 8) + 0	//Eg 0x0200 = 2.0
	#define MX_ENUMTIME		10				//Eg 1 - 255
	#define MX_ENUMWAIT		0				//Eg 1 or 0

	#ifdef FC_CAL_PIC							//8-bit PIC specific

		MX_UINT8 MX_USBNAME[40] = {40,3,'F',0,'l',0,'o',0,'w',0,'c',0,'o',0,'d',0,'e',0,' ',0,'U',0,'S',0,'B',0,' ',0,'S',0,'e',0,'r',0,'i',0,'a',0,'l',0};		//Device name
1032  0E28      	MOVLW 0x28
1034  0101      	MOVLB 0x01
1036  6F6E      	MOVWF gbl_MX_USBNAME, 1
1038  0E03      	MOVLW 0x03
103A  6F6F      	MOVWF gbl_MX_USBNAME+D'1', 1
103C  0E46      	MOVLW 0x46
103E  6F70      	MOVWF gbl_MX_USBNAME+D'2', 1
1040  6B71      	CLRF gbl_MX_USBNAME+D'3', 1
1042  0E6C      	MOVLW 0x6C
1044  6F72      	MOVWF gbl_MX_USBNAME+D'4', 1
1046  6B73      	CLRF gbl_MX_USBNAME+D'5', 1
1048  0E6F      	MOVLW 0x6F
104A  6F74      	MOVWF gbl_MX_USBNAME+D'6', 1
104C  6B75      	CLRF gbl_MX_USBNAME+D'7', 1
104E  0E77      	MOVLW 0x77
1050  6F76      	MOVWF gbl_MX_USBNAME+D'8', 1
1052  6B77      	CLRF gbl_MX_USBNAME+D'9', 1
1054  0E63      	MOVLW 0x63
1056  6F78      	MOVWF gbl_MX_USBNAME+D'10', 1
1058  6B79      	CLRF gbl_MX_USBNAME+D'11', 1
105A  0E6F      	MOVLW 0x6F
105C  6F7A      	MOVWF gbl_MX_USBNAME+D'12', 1
105E  6B7B      	CLRF gbl_MX_USBNAME+D'13', 1
1060  0E64      	MOVLW 0x64
1062  6F7C      	MOVWF gbl_MX_USBNAME+D'14', 1
1064  6B7D      	CLRF gbl_MX_USBNAME+D'15', 1
1066  0E65      	MOVLW 0x65
1068  6F7E      	MOVWF gbl_MX_USBNAME+D'16', 1
106A  6B7F      	CLRF gbl_MX_USBNAME+D'17', 1
106C  0E20      	MOVLW 0x20
106E  6F80      	MOVWF gbl_MX_USBNAME+D'18', 1
1070  6B81      	CLRF gbl_MX_USBNAME+D'19', 1
1072  0E55      	MOVLW 0x55
1074  6F82      	MOVWF gbl_MX_USBNAME+D'20', 1
1076  6B83      	CLRF gbl_MX_USBNAME+D'21', 1
1078  0E53      	MOVLW 0x53
107A  6F84      	MOVWF gbl_MX_USBNAME+D'22', 1
107C  6B85      	CLRF gbl_MX_USBNAME+D'23', 1
107E  0E42      	MOVLW 0x42
1080  6F86      	MOVWF gbl_MX_USBNAME+D'24', 1
1082  6B87      	CLRF gbl_MX_USBNAME+D'25', 1
1084  0E20      	MOVLW 0x20
1086  6F88      	MOVWF gbl_MX_USBNAME+D'26', 1
1088  6B89      	CLRF gbl_MX_USBNAME+D'27', 1
108A  0E53      	MOVLW 0x53
108C  6F8A      	MOVWF gbl_MX_USBNAME+D'28', 1
108E  6B8B      	CLRF gbl_MX_USBNAME+D'29', 1
1090  0E65      	MOVLW 0x65
1092  6F8C      	MOVWF gbl_MX_USBNAME+D'30', 1
1094  6B8D      	CLRF gbl_MX_USBNAME+D'31', 1
1096  0E72      	MOVLW 0x72
1098  6F8E      	MOVWF gbl_MX_USBNAME+D'32', 1
109A  6B8F      	CLRF gbl_MX_USBNAME+D'33', 1
109C  0E69      	MOVLW 0x69
109E  6F90      	MOVWF gbl_MX_USBNAME+D'34', 1
10A0  6B91      	CLRF gbl_MX_USBNAME+D'35', 1
10A2  0E61      	MOVLW 0x61
10A4  6F92      	MOVWF gbl_MX_USBNAME+D'36', 1
10A6  6B93      	CLRF gbl_MX_USBNAME+D'37', 1
10A8  0E6C      	MOVLW 0x6C
10AA  6F94      	MOVWF gbl_MX_USBNAME+D'38', 1
10AC  6B95      	CLRF gbl_MX_USBNAME+D'39', 1

		MX_UINT8 MX_USBMFR[0] = {46,3,'M',0,'a',0,'t',0,'r',0,'i',0,'x',0,' ',0,'M',0,'u',0,'l',0,'t',0,'i',0,'m',0,'e',0,'d',0,'i',0,'a',0,' ',0,'L',0,'t',0,'d',0,'.',0};			//Manufacturer
10AE  0E2E      	MOVLW 0x2E
10B0  6F40      	MOVWF gbl_MX_USBMFR, 1
10B2  0E03      	MOVLW 0x03
10B4  6F41      	MOVWF gbl_MX_USBMFR+D'1', 1
10B6  0E4D      	MOVLW 0x4D
10B8  6F42      	MOVWF gbl_MX_USBMFR+D'2', 1
10BA  6B43      	CLRF gbl_MX_USBMFR+D'3', 1
10BC  0E61      	MOVLW 0x61
10BE  6F44      	MOVWF gbl_MX_USBMFR+D'4', 1
10C0  6B45      	CLRF gbl_MX_USBMFR+D'5', 1
10C2  0E74      	MOVLW 0x74
10C4  6F46      	MOVWF gbl_MX_USBMFR+D'6', 1
10C6  6B47      	CLRF gbl_MX_USBMFR+D'7', 1
10C8  0E72      	MOVLW 0x72
10CA  6F48      	MOVWF gbl_MX_USBMFR+D'8', 1
10CC  6B49      	CLRF gbl_MX_USBMFR+D'9', 1
10CE  0E69      	MOVLW 0x69
10D0  6F4A      	MOVWF gbl_MX_USBMFR+D'10', 1
10D2  6B4B      	CLRF gbl_MX_USBMFR+D'11', 1
10D4  0E78      	MOVLW 0x78
10D6  6F4C      	MOVWF gbl_MX_USBMFR+D'12', 1
10D8  6B4D      	CLRF gbl_MX_USBMFR+D'13', 1
10DA  0E20      	MOVLW 0x20
10DC  6F4E      	MOVWF gbl_MX_USBMFR+D'14', 1
10DE  6B4F      	CLRF gbl_MX_USBMFR+D'15', 1
10E0  0E4D      	MOVLW 0x4D
10E2  6F50      	MOVWF gbl_MX_USBMFR+D'16', 1
10E4  6B51      	CLRF gbl_MX_USBMFR+D'17', 1
10E6  0E75      	MOVLW 0x75
10E8  6F52      	MOVWF gbl_MX_USBMFR+D'18', 1
10EA  6B53      	CLRF gbl_MX_USBMFR+D'19', 1
10EC  0E6C      	MOVLW 0x6C
10EE  6F54      	MOVWF gbl_MX_USBMFR+D'20', 1
10F0  6B55      	CLRF gbl_MX_USBMFR+D'21', 1
10F2  0E74      	MOVLW 0x74
10F4  6F56      	MOVWF gbl_MX_USBMFR+D'22', 1
10F6  6B57      	CLRF gbl_MX_USBMFR+D'23', 1
10F8  0E69      	MOVLW 0x69
10FA  6F58      	MOVWF gbl_MX_USBMFR+D'24', 1
10FC  6B59      	CLRF gbl_MX_USBMFR+D'25', 1
10FE  0E6D      	MOVLW 0x6D
1100  6F5A      	MOVWF gbl_MX_USBMFR+D'26', 1
1102  6B5B      	CLRF gbl_MX_USBMFR+D'27', 1
1104  0E65      	MOVLW 0x65
1106  6F5C      	MOVWF gbl_MX_USBMFR+D'28', 1
1108  6B5D      	CLRF gbl_MX_USBMFR+D'29', 1
110A  0E64      	MOVLW 0x64
110C  6F5E      	MOVWF gbl_MX_USBMFR+D'30', 1
110E  6B5F      	CLRF gbl_MX_USBMFR+D'31', 1
1110  0E69      	MOVLW 0x69
1112  6F60      	MOVWF gbl_MX_USBMFR+D'32', 1
1114  6B61      	CLRF gbl_MX_USBMFR+D'33', 1
1116  0E61      	MOVLW 0x61
1118  6F62      	MOVWF gbl_MX_USBMFR+D'34', 1
111A  6B63      	CLRF gbl_MX_USBMFR+D'35', 1
111C  0E20      	MOVLW 0x20
111E  6F64      	MOVWF gbl_MX_USBMFR+D'36', 1
1120  6B65      	CLRF gbl_MX_USBMFR+D'37', 1
1122  0E4C      	MOVLW 0x4C
1124  6F66      	MOVWF gbl_MX_USBMFR+D'38', 1
1126  6B67      	CLRF gbl_MX_USBMFR+D'39', 1
1128  0E74      	MOVLW 0x74
112A  6F68      	MOVWF gbl_MX_USBMFR+D'40', 1
112C  6B69      	CLRF gbl_MX_USBMFR+D'41', 1
112E  0E64      	MOVLW 0x64
1130  6F6A      	MOVWF gbl_MX_USBMFR+D'42', 1
1132  6B6B      	CLRF gbl_MX_USBMFR+D'43', 1
1134  0E2E      	MOVLW 0x2E
1136  6F6C      	MOVWF gbl_MX_USBMFR+D'44', 1
1138  6B6D      	CLRF gbl_MX_USBMFR+D'45', 1


		// Global Defines
		#define CDC_TX_BUFFER_SIZE 	64
		#define CDC_RX_BUFFER_SIZE 	64
		#define CDC_DATA_ENDPOINT	3
		#define USB_HIGHEST_EP 		3
		#define USB_BUS_POWERED

		#ifdef MX_USB_TYPE1									//2455 Family
			#define USB_DESCRIPTOR_BASE_ADDRESS	0x400
			#define USB_EP0_OUT_ADDR 	0x0500
			#define USB_EP0_IN_ADDR 	0x0508
			#define USB_EP2_IN_ADDR		0x0510
			#define USB_EP3_OUT_ADDR	0x0518
			#define USB_EP3_IN_ADDR		0x0520
		#endif

		#ifdef MX_USB_TYPE2									//2450 Family
			#define USB_DESCRIPTOR_BASE_ADDRESS	0x400
			#define USB_EP0_OUT_ADDR 	0x0480
			#define USB_EP0_IN_ADDR 	0x0488
			#define USB_EP2_IN_ADDR		0x0490
			#define USB_EP3_OUT_ADDR	0x0498
			#define USB_EP3_IN_ADDR		0x04A0
		#endif

		#ifdef MX_USB_TYPE3									//14K50 Family
			#define USB_DESCRIPTOR_BASE_ADDRESS	0x200
			#define USB_EP0_OUT_ADDR 	0x0280
			#define USB_EP0_IN_ADDR 	0x0288
			#define USB_EP2_IN_ADDR		0x0290
			#define USB_EP3_OUT_ADDR	0x0298
			#define USB_EP3_IN_ADDR		0x02A0
		#endif

		#ifdef MX_USB_TYPE4									//24J53 Family
			#define USB_DESCRIPTOR_BASE_ADDRESS	0xD00
			#define USB_EP0_OUT_ADDR 	0x0E00
			#define USB_EP0_IN_ADDR 	0x0E08
			#define USB_EP2_IN_ADDR		0x0E10
			#define USB_EP3_OUT_ADDR	0x0E18
			#define USB_EP3_IN_ADDR		0x0E20
		#endif

		#ifndef USB_DESCRIPTOR_BASE_ADDRESS
			#error "Target device does not have USB functionality"
		#endif

		#ifdef HI_TECH_C
			#error "USB library only supported by the BoostC compiler"
		#endif

		#define USB_EP0_OUT_SIZE 	8
		#define USB_EP0_IN_SIZE 	8
		#define USB_EP2_IN_SIZE		8
		#define USB_EP3_OUT_SIZE	8
		#define USB_EP3_IN_SIZE		8

		#define USB_CALLBACK_ON_SOF
		#define USB_CALLBACK_ON_DEVICE_CONFIGURED
		#define USB_CALLBACK_ON_CTRL_CLASS
		#define USB_EP_DATA_CALLBACK

		//Serial Number
		MX_UINT8 MX_SERIAL[10] = {10,3,'0',0,'0',0,'0',0,'1',0};
113A  0E0A      	MOVLW 0x0A
113C  0100      	MOVLB 0x00
113E  6FE0      	MOVWF gbl_MX_SERIAL, 1
1140  0E03      	MOVLW 0x03
1142  6FE1      	MOVWF gbl_MX_SERIAL+D'1', 1
1144  0E30      	MOVLW 0x30
1146  6FE2      	MOVWF gbl_MX_SERIAL+D'2', 1
1148  6BE3      	CLRF gbl_MX_SERIAL+D'3', 1
114A  0E30      	MOVLW 0x30
114C  6FE4      	MOVWF gbl_MX_SERIAL+D'4', 1
114E  6BE5      	CLRF gbl_MX_SERIAL+D'5', 1
1150  0E30      	MOVLW 0x30
1152  6FE6      	MOVWF gbl_MX_SERIAL+D'6', 1
1154  6BE7      	CLRF gbl_MX_SERIAL+D'7', 1
1156  0E31      	MOVLW 0x31
1158  6FE8      	MOVWF gbl_MX_SERIAL+D'8', 1
115A  6BE9      	CLRF gbl_MX_SERIAL+D'9', 1


		// USB library includes
		#include "USB/pic_utils.h"
		#include "USB/pic_usb_buffer_mgt.c"
		#include "USB/pic_usb.c"
		#include "USB/usb_cdc_class.c"
		#include "USB/usb_config_serial.c"

		// Variable to hold status of the USB connection
		MX_UINT8 CDC_USB_status = 0;
1212  6B63      	CLRF gbl_CDC_USB_status, 1


		// Variable to hold incoming data
		MX_UINT8 CDC_USB_Rx_String[CDC_RX_BUFFER_SIZE];

		void usb_device_configured_callback(void)

		{
			CDC_USB_status = 1;
02EC  0E01      	MOVLW 0x01
02EE  0102      	MOVLB 0x02
02F0  6F63      	MOVWF gbl_CDC_USB_status, 1

		}
02F2  0012      	RETURN


	#endif

	#ifdef FC_CAL_PIC16BIT						//16-bit PIC specific

		#ifndef MX_USB
			#error "Your target device does not support USB components"
		#endif

		// Global Defines
		#define USB_BUS_SENSE       1
		#define self_power          1
		#define tris_usb_bus_sense	1
		#define tris_self_power		1

		#define USB_CONFIG	"usb_serial_config.h"

		// USB library includes
		#include "../../USB/usb_serial_config.h"
		#include "../../USB/usb.h"
		#include "../../USB/usb_function_cdc.h"
		#include "../../USB/GenericTypeDefs.h"
		#include "../../USB/Compiler.h"
		#include "../../USB/usb_device.h"
		#include "../../USB/usb_device.c"
		#include "../../USB/usb_ch9.h"
		#include "../../USB/usb_cdc_handler.c"
		#include "../../USB/usb_hal_pic24.c"
		#include "../../USB/usb_function_cdc.c"
		#include "../../USB/usb_common.h"
		#include "../../USB/usb_hal.h"
		#include "../../USB/usb_hal_pic24.h"

		// Device name and manufacturer
		ROM struct{BYTE bLength;BYTE bDscType;WORD string[40];}sd001={sizeof(sd001),USB_DESCRIPTOR_STRING,{{40,3,'F',0,'l',0,'o',0,'w',0,'c',0,'o',0,'d',0,'e',0,' ',0,'U',0,'S',0,'B',0,' ',0,'S',0,'e',0,'r',0,'i',0,'a',0,'l',0};}};
		ROM struct{BYTE bLength;BYTE bDscType;WORD string[0];}sd002={sizeof(sd002),USB_DESCRIPTOR_STRING,{{46,3,'M',0,'a',0,'t',0,'r',0,'i',0,'x',0,' ',0,'M',0,'u',0,'l',0,'t',0,'i',0,'m',0,'e',0,'d',0,'i',0,'a',0,' ',0,'L',0,'t',0,'d',0,'.',0};}};

		#include "../../USB/usb_serial_descriptors.c"

	#endif




//USBSerial(0): //Macro function declarations

void FCD_USBSerial0_configure_system();
MX_UINT8 FCD_USBSerial0_Initialise_Serial();
MX_UINT8 FCD_USBSerial0_SendByte(MX_UINT8 byte);
MX_UINT8 FCD_USBSerial0_SendString(MX_STRING String, MX_UINT8 MSZ_String);
MX_UINT8 FCD_USBSerial0_ReadByte(MX_UINT8 timeout_ms);
void FCD_USBSerial0_ReadString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 timeout_ms, MX_UINT8 length);


//ADC(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Which ADC Channel
c = Acquisition time
d = Conversion Speed
e = VRef+ Option
f = VRef Voltage x 0.01V
******************************/

//Common Defines

#define ADC_2_MX_ADC_CHANNEL	3
#define ADC_2_MX_ADC_ACTIME	40
#define ADC_2_MX_ADC_CONVSP	3
#define ADC_2_MX_ADC_VREFOP	0
#define ADC_2_MX_ADC_VREFVOL	500

#ifndef MX_ADC_CHANNEL_3
 #define MX_ADC_CHANNEL_3			//Inform CAL ADC channel 3 is now in use.
#endif

#ifndef MX_ADC_REF					//Inform CAL ADC peripheral is now in use
 #define MX_ADC_REF
#endif

extern void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
extern MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
extern void FC_CAL_Disable_ADC (void);




//ADC(0): //Macro function declarations

void FCD_ADC0_SampleADC();
MX_UINT8 FCD_ADC0_ReadAsByte();
MX_UINT16 FCD_ADC0_ReadAsInt();
MX_FLOAT FCD_ADC0_ReadAsVoltage();
void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE);
void FCD_ADC0_ADC_RAW_Configure_Channel();
MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte();
MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int();
MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
void FCD_ADC0_ADC_RAW_Disable_Channel();


//ADC(1): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Which ADC Channel
c = Acquisition time
d = Conversion Speed
e = VRef+ Option
f = VRef Voltage x 0.01V
******************************/

//Common Defines

#define ADC_3_MX_ADC_CHANNEL	4
#define ADC_3_MX_ADC_ACTIME	40
#define ADC_3_MX_ADC_CONVSP	3
#define ADC_3_MX_ADC_VREFOP	0
#define ADC_3_MX_ADC_VREFVOL	500

#ifndef MX_ADC_CHANNEL_4
 #define MX_ADC_CHANNEL_4			//Inform CAL ADC channel 4 is now in use.
#endif

#ifndef MX_ADC_REF					//Inform CAL ADC peripheral is now in use
 #define MX_ADC_REF
#endif

extern void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
extern MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
extern void FC_CAL_Disable_ADC (void);




//ADC(1): //Macro function declarations

void FCD_ADC1_SampleADC();
MX_UINT8 FCD_ADC1_ReadAsByte();
MX_UINT16 FCD_ADC1_ReadAsInt();
MX_FLOAT FCD_ADC1_ReadAsVoltage();
void FCD_ADC1_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE);
void FCD_ADC1_ADC_RAW_Configure_Channel();
MX_UINT8 FCD_ADC1_ADC_RAW_Sample_Channel_Byte();
MX_UINT16 FCD_ADC1_ADC_RAW_Sample_Channel_Int();
MX_UINT8 FCD_ADC1_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
MX_UINT16 FCD_ADC1_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
void FCD_ADC1_ADC_RAW_Disable_Channel();



//USBSerial(0): //Macro implementations


void FCD_USBSerial0_configure_system()

{
	
	  #ifdef FC_CAL_PIC							//8-bit PIC specific
		kill_interrupts();						//turn off interrupts just in case
0DF8            label93
0DF8  9EF2      	BCF gbl_intcon,7
0DFA  BEF2      	BTFSC gbl_intcon,7
0DFC  D7FD      	BRA	label93

		usb_cdc_setup();
0DFE  ECD4F004  	CALL usb_cdc_se_0006F

		usb_setup();
0E02  ECA1F004  	CALL usb_setup_00000

		turn_peripheral_ints_on();
0E06  8CF2      	BSF gbl_intcon,6

		turn_global_ints_on();
0E08  8EF2      	BSF gbl_intcon,7

	  #endif

}
0E0A  0012      	RETURN


MX_UINT8 FCD_USBSerial0_Initialise_Serial()

{
	
	  #ifdef FC_CAL_PIC															//8-bit PIC specific
		usb_configure_structures();
0F18  EC4EF005  	CALL usb_config_00071

		FCD_USBSerial0_configure_system();
0F1C  ECFCF006  	CALL FCD_USBSer_00072

		usb_enable_module();
0F20  EC48F005  	CALL usb_enable_00051

	  #else																		//16-bit PIC specific
		USBDeviceInit();
		if(USB_BUS_SENSE && (USBGetDeviceState() == DETACHED_STATE))
			USBDeviceAttach();
	  #endif

		#if MX_ENUMWAIT == 1

			MX_UINT16 delay_counter = 0;

		  #ifdef FC_CAL_PIC														//8-bit PIC specific
			while(CDC_USB_status == 0 && delay_counter < 10000)					//Wait for USB to startup and enumerate
		  #else
		  	while(USBDeviceState != CONFIGURED_STATE && delay_counter < 10000)	//Wait for USB to startup and enumerate
		  #endif
			{
				delay_counter = delay_counter + 1;
				delay_10us(MX_ENUMTIME);										//Max wait
				delay_10us(MX_ENUMTIME);
				delay_10us(MX_ENUMTIME);
				delay_10us(MX_ENUMTIME);
				delay_10us(MX_ENUMTIME);
				delay_10us(MX_ENUMTIME);
				delay_10us(MX_ENUMTIME);
				delay_10us(MX_ENUMTIME);
				delay_10us(MX_ENUMTIME);
				delay_10us(MX_ENUMTIME);
			}

		  #ifdef FC_CAL_PIC														//8-bit PIC specific
			if (CDC_USB_status == 1)
		  #else																	//16-bit PIC specific
		  	if (USBDeviceState == CONFIGURED_STATE)
		  #endif
				return 0;
			return 0xFF;

		#else
		  #ifdef FC_CAL_PIC														//8-bit PIC specific
			while(CDC_USB_status == 0);
0F24            label110
0F24  5363      	MOVF gbl_CDC_USB_status, F, 1
0F26  E0FE      	BZ	label110

		  #else																	//16-bit PIC specific
		  	while(USBDeviceState != CONFIGURED_STATE);
		  #endif

		#endif
		return 0;
0F28  6B69      	CLRF CompTempVarRet2305, 1


}
0F2A  0012      	RETURN


MX_UINT8 FCD_USBSerial0_SendByte(MX_UINT8 byte)

{
	
		MX_UINT16 timeout = 0;
0ED6  6B6A      	CLRF FCD_USBSer_00074_1_timeout, 1
0ED8  6B6B      	CLRF FCD_USBSer_00074_1_timeout+D'1', 1


	  #ifdef FC_CAL_PIC														//8-bit PIC specific

		while (usb_cdc_tx_empty() == 0 && timeout < 32000)					//Wait for outgoing buffer to empty
0EDA            label106
0EDA  EC6DF006  	CALL usb_cdc_tx_0006D
0EDE  536E      	MOVF CompTempVarRet2292, F, 1
0EE0  E10C      	BNZ	label108
0EE2  0E7D      	MOVLW 0x7D
0EE4  5D6B      	SUBWF FCD_USBSer_00074_1_timeout+D'1', W, 1
0EE6  E102      	BNZ	label107
0EE8  0E00      	MOVLW 0x00
0EEA  5D6A      	SUBWF FCD_USBSer_00074_1_timeout, W, 1
0EEC            label107
0EEC  E206      	BC	label108
0EF8  D7F0      	BRA	label106
0EFA            label108

			timeout = timeout + 1;
0EEE  536A      	MOVF FCD_USBSer_00074_1_timeout, F, 1
0EF0  536B      	MOVF FCD_USBSer_00074_1_timeout+D'1', F, 1
0EF2  2B6A      	INCF FCD_USBSer_00074_1_timeout, F, 1
0EF4  B4D8      	BTFSC STATUS,Z
0EF6  2B6B      	INCF FCD_USBSer_00074_1_timeout+D'1', F, 1


		if (timeout == 32000)												//Pipeline full or disconnected
0EFA  0E00      	MOVLW 0x00
0EFC  636A      	CPFSEQ FCD_USBSer_00074_1_timeout, 1
0EFE  D006      	BRA	label109
0F00  0E7D      	MOVLW 0x7D
0F02  636B      	CPFSEQ FCD_USBSer_00074_1_timeout+D'1', 1
0F04  D003      	BRA	label109
0F0C            label109

			return(1);
0F06  0E01      	MOVLW 0x01
0F08  6F6C      	MOVWF CompTempVarRet2306, 1


		usb_cdc_putc(byte);
0F0C  5169      	MOVF FCD_USBSer_00074_arg_byte, W, 1
0F0E  6F72      	MOVWF usb_cdc_pu_0006B_arg_c, 1
0F10  EC02F005  	CALL usb_cdc_pu_0006B


	  #endif

	  #ifdef FC_CAL_PIC16BIT												//16-bit PIC specific

	  	if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1))
	  	{
	  		return(2);														//USB Not Configured
	  	}
	  	else
	  	{
			CDCTxService();													//Required or every other send fails
			while (mUSBUSARTIsTxTrfReady() == 0 && timeout < 32000)			//Wait for outgoing buffer to empty
				timeout = timeout + 1;

			if (timeout == 32000)											//Pipeline full or disconnected
			{
				return(1);													//USB Not Ready
			}
			else
			{
				putUSBUSART(&byte,1);
			}
		}
		CDCTxService();

	  #endif

		return(0);
0F14  6B6C      	CLRF CompTempVarRet2306, 1


}
0F0A  0012      	RETURN
0F16  0012      	RETURN


MX_UINT8 FCD_USBSerial0_SendString(MX_STRING String, MX_UINT8 MSZ_String)

{
		MX_UINT16 timeout = 0;
0E90  6B6C      	CLRF FCD_USBSer_00075_1_timeout, 1
0E92  6B6D      	CLRF FCD_USBSer_00075_1_timeout+D'1', 1


	  #ifdef FC_CAL_PIC														//8-bit PIC specific

		while (usb_cdc_tx_empty() == 0 && timeout < 32000)					//Wait for outgoing buffer to empty
0E94            label102
0E94  EC6DF006  	CALL usb_cdc_tx_0006D
0E98  536E      	MOVF CompTempVarRet2292, F, 1
0E9A  E10C      	BNZ	label104
0E9C  0E7D      	MOVLW 0x7D
0E9E  5D6D      	SUBWF FCD_USBSer_00075_1_timeout+D'1', W, 1
0EA0  E102      	BNZ	label103
0EA2  0E00      	MOVLW 0x00
0EA4  5D6C      	SUBWF FCD_USBSer_00075_1_timeout, W, 1
0EA6            label103
0EA6  E206      	BC	label104
0EB2  D7F0      	BRA	label102
0EB4            label104

			timeout = timeout + 1;
0EA8  536C      	MOVF FCD_USBSer_00075_1_timeout, F, 1
0EAA  536D      	MOVF FCD_USBSer_00075_1_timeout+D'1', F, 1
0EAC  2B6C      	INCF FCD_USBSer_00075_1_timeout, F, 1
0EAE  B4D8      	BTFSC STATUS,Z
0EB0  2B6D      	INCF FCD_USBSer_00075_1_timeout+D'1', F, 1


		if (timeout == 32000)												//Pipeline full or disconnected
0EB4  0E00      	MOVLW 0x00
0EB6  636C      	CPFSEQ FCD_USBSer_00075_1_timeout, 1
0EB8  D006      	BRA	label105
0EBA  0E7D      	MOVLW 0x7D
0EBC  636D      	CPFSEQ FCD_USBSer_00075_1_timeout+D'1', 1
0EBE  D003      	BRA	label105
0EC6            label105

			return(1);
0EC0  0E01      	MOVLW 0x01
0EC2  6F6E      	MOVWF CompTempVarRet2309, 1


		usb_cdc_print_str(String);
0EC6  5169      	MOVF FCD_USBSer_00075_arg_String, W, 1
0EC8  6F6F      	MOVWF usb_cdc_pr_0006E_arg_str, 1
0ECA  516A      	MOVF FCD_USBSer_00075_arg_String+D'1', W, 1
0ECC  6F70      	MOVWF usb_cdc_pr_0006E_arg_str+D'1', 1
0ECE  EC79F006  	CALL usb_cdc_pr_0006E


	  #endif

	  #ifdef FC_CAL_PIC16BIT												//16-bit PIC specific

		if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1))
		{
			return(2);														//USB Not Configured
		}
		else
		{
			CDCTxService();													//Required or every other send fails

			while (mUSBUSARTIsTxTrfReady() == 0 && timeout < 32000)			//Wait for outgoing buffer to empty
				timeout = timeout + 1;

			if (timeout == 32000)											//Pipeline full or disconnected
			{
				retval(1);													//USB Not Ready
			}
			else
			{
				putUSBUSART(String,MSZ_String);
			}
		}
		CDCTxService();

	  #endif

		return 0;
0ED2  6B6E      	CLRF CompTempVarRet2309, 1

}
0EC4  0012      	RETURN
0ED4  0012      	RETURN


MX_UINT8 FCD_USBSerial0_ReadByte(MX_UINT8 timeout_ms)

{
	
		MX_UINT8 waitforever = 0;
0E0C  6B6A      	CLRF FCD_USBSer_00076_1_waitforever, 1


	  #ifdef FC_CAL_PIC											//8-bit PIC specific

		static MX_UINT8 position = 0;
0E0E  B164      	BTFSC CompGblVar65,0, 1
0E10  D002      	BRA	label94
0E12  6B67      	CLRF FCD_USBSer_00076_1_position, 1
0E14  8164      	BSF CompGblVar65,0, 1
0E16            label94
102E  9164      	BCF CompGblVar65,0, 1

		static MX_UINT8 length = 0;
0E16  B364      	BTFSC CompGblVar66,1, 1
0E18  D002      	BRA	label95
0E1A  6B68      	CLRF FCD_USBSer_00076_1_length, 1
0E1C  8364      	BSF CompGblVar66,1, 1
0E1E            label95
1030  9364      	BCF CompGblVar66,1, 1

		MX_UINT8 retval = 255;
0E1E  696B      	SETF FCD_USBSer_00076_1_retval, 1


		if(timeout_ms == 255)
0E20  2969      	INCF FCD_USBSer_00076_arg_timeout_ms, W, 1
0E22  E102      	BNZ	label96
0E28            label96

			waitforever = 1;
0E24  0E01      	MOVLW 0x01
0E26  6F6A      	MOVWF FCD_USBSer_00076_1_waitforever, 1


		if (position == length)									// end of local string?
0E28  5168      	MOVF FCD_USBSer_00076_1_length, W, 1
0E2A  6367      	CPFSEQ FCD_USBSer_00076_1_position, 1
0E2C  D023      	BRA	label101
0E74            label101

		{
			position = 0;
0E2E  6B67      	CLRF FCD_USBSer_00076_1_position, 1


			length = usb_cdc_rx_avail();						// get length of incoming data string
0E30  EC74F006  	CALL usb_cdc_rx_0006C
0E34  516C      	MOVF CompTempVarRet2291, W, 1
0E36  6F68      	MOVWF FCD_USBSer_00076_1_length, 1


			while (length == 0 && (timeout_ms || waitforever))	// wait for timeout_ms
0E38            label97
0E38  5368      	MOVF FCD_USBSer_00076_1_length, F, 1
0E3A  E10F      	BNZ	label99
0E3C  5369      	MOVF FCD_USBSer_00076_arg_timeout_ms, F, 1
0E3E  E102      	BNZ	label98
0E40  536A      	MOVF FCD_USBSer_00076_1_waitforever, F, 1
0E42  E00B      	BZ	label99
0E44            label98
0E58  D7EF      	BRA	label97
0E5A            label99

			{
				Wdt_Delay_Ms(1);
0E44  0E01      	MOVLW 0x01
0E46  6F6C      	MOVWF Wdt_Delay__00039_arg_delay, 1
0E48  EC8DF006  	CALL Wdt_Delay__00039

				length = usb_cdc_rx_avail();					// get length of incoming data string
0E4C  EC74F006  	CALL usb_cdc_rx_0006C
0E50  516C      	MOVF CompTempVarRet2291, W, 1
0E52  6F68      	MOVWF FCD_USBSer_00076_1_length, 1

				timeout_ms = timeout_ms - 1;					// decrement timeout_ms
0E54  0569      	DECF FCD_USBSer_00076_arg_timeout_ms, W, 1
0E56  6F69      	MOVWF FCD_USBSer_00076_arg_timeout_ms, 1

			}

			if(length == 0)
0E5A  5368      	MOVF FCD_USBSer_00076_1_length, F, 1
0E5C  E103      	BNZ	label100
0E64            label100

				return (retval);								// return no data flag 255 / 0xFF
0E5E  516B      	MOVF FCD_USBSer_00076_1_retval, W, 1
0E60  6F6C      	MOVWF CompTempVarRet2312, 1


			usb_ep_get_rx_buffer(length, CDC_USB_Rx_String);	// copy data string to local buffer
0E64  5168      	MOVF FCD_USBSer_00076_1_length, W, 1
0E66  6F6D      	MOVWF usb_ep_get_00070_arg_length, 1
0E68  0E01      	MOVLW HIGH(gbl_CDC_USB_Rx_String+D'0')
0E6A  6F6F      	MOVWF usb_ep_get_00070_arg_buffer+D'1', 1
0E6C  0E00      	MOVLW LOW(gbl_CDC_USB_Rx_String+D'0')
0E6E  6F6E      	MOVWF usb_ep_get_00070_arg_buffer, 1
0E70  EC28F005  	CALL usb_ep_get_00070

		}

		retval = CDC_USB_Rx_String[position];
0E74  0101      	MOVLB 0x01
0E76  EE01F000  	LFSR 0x00, gbl_CDC_USB_Rx_String
0E7A  50E9      	MOVF FSR0L, W
0E7C  0102      	MOVLB 0x02
0E7E  5167      	MOVF FCD_USBSer_00076_1_position, W, 1
0E80  26E9      	ADDWF FSR0L, F
0E82  50EF      	MOVF INDF0, W
0E84  6F6B      	MOVWF FCD_USBSer_00076_1_retval, 1


		position = position + 1;
0E86  2967      	INCF FCD_USBSer_00076_1_position, W, 1
0E88  6F67      	MOVWF FCD_USBSer_00076_1_position, 1


		return (retval);
0E8A  516B      	MOVF FCD_USBSer_00076_1_retval, W, 1
0E8C  6F6C      	MOVWF CompTempVarRet2312, 1


	  #endif

	  #ifdef FC_CAL_PIC16BIT									//16-bit PIC specific

		MX_UINT8 retval[1];
		MX_UINT8 inner = 0;
		MX_UINT16 numBytesRead = 0;

		retval[0] = 255;

		if(timeout_ms == 255)
			waitforever = 1;

		while(numBytesRead == 0 && timeout_ms > 0)
		{
			numBytesRead = getsUSBUSART(retval,1);
			if (waitforever == 0 && numBytesRead == 0)
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					timeout_ms--;
				}
			}
		}
		return (retval[0]);

	  #endif

}
0E62  0012      	RETURN
0E8E  0012      	RETURN


void FCD_USBSerial0_ReadString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 timeout_ms, MX_UINT8 length)
{
		MX_UINT8 waitforever = 0;

	  #ifdef FC_CAL_PIC											//8-bit PIC specific

		MX_UINT8 Rx_Length;

		if(length > FCR_RETVAL_SIZE)
			length = FCR_RETVAL_SIZE;

		if(timeout_ms == 255)
			waitforever = 1;

		while (timeout_ms || waitforever)
		{
			Rx_Length = usb_cdc_rx_avail();						// get length of incoming data string
			if (Rx_Length)
			{
				if (Rx_Length > length)
					Rx_Length = length;

				usb_ep_get_rx_buffer(Rx_Length, FCR_RETVAL);	// copy data string to local buffer

				if (Rx_Length < length)
					FCR_RETVAL[Rx_Length] = 0;					//Add null MX_UINT8acter to end of string
				return;
			}
			else
			{
				Wdt_Delay_Ms(1);
				timeout_ms = timeout_ms - 1;
			}
		}

	  #endif

	  #ifdef FC_CAL_PIC16BIT									//16-bit PIC specific

		MX_UINT8 inner = 0;
		MX_UINT16 numBytesRead = 0;

		if(length > FCR_RETVAL_SIZE)
			length = FCR_RETVAL_SIZE;

		if(timeout_ms == 255)
			waitforever = 1;

		while(numBytesRead == 0 && timeout_ms > 0)
		{
			numBytesRead = getsUSBUSART(FCR_RETVAL, length);
			if (waitforever == 0 && numBytesRead == 0)
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					timeout_ms--;
				}
			}
		}

	  #endif

}



//ADC(0): //Macro implementations


void FCD_ADC0_SampleADC()
{
	
	    //unused

}

MX_UINT8 FCD_ADC0_ReadAsByte()
{
	
		MX_UINT8 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_2_MX_ADC_CHANNEL , ADC_2_MX_ADC_CONVSP , ADC_2_MX_ADC_VREFOP , ADC_2_MX_ADC_ACTIME );

		retVal = FC_CAL_Sample_ADC( 0 );				//Perform Sample - Return as byte

		FC_CAL_Disable_ADC ();

		return (retVal);

}

MX_UINT16 FCD_ADC0_ReadAsInt()

{
	
		MX_UINT16 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_2_MX_ADC_CHANNEL , ADC_2_MX_ADC_CONVSP , ADC_2_MX_ADC_VREFOP , ADC_2_MX_ADC_ACTIME );
0F54  0E03      	MOVLW 0x03
0F56  0102      	MOVLB 0x02
0F58  6F6B      	MOVWF FC_CAL_Ena_00079_arg_Channel, 1
0F5A  6F6C      	MOVWF FC_CAL_Ena_00079_arg_Conv_Speed, 1
0F5C  6B6D      	CLRF FC_CAL_Ena_00079_arg_Vref, 1
0F5E  0E28      	MOVLW 0x28
0F60  6F6E      	MOVWF FC_CAL_Ena_00079_arg_T_Charge, 1
0F62  ECB9F006  	CALL FC_CAL_Ena_00079


		retVal = FC_CAL_Sample_ADC( 1 );				//Perform Sample - Return as MX_UINT16
0F66  0E01      	MOVLW 0x01
0F68  6F6B      	MOVWF FC_CAL_Sam_0007A_arg_Sample_Mode, 1
0F6A  EC98F006  	CALL FC_CAL_Sam_0007A
0F6E  516E      	MOVF CompTempVarRet2320, W, 1
0F70  6F69      	MOVWF FCD_ADC0_R_0007E_1_retVal, 1
0F72  516F      	MOVF CompTempVarRet2320+D'1', W, 1
0F74  6F6A      	MOVWF FCD_ADC0_R_0007E_1_retVal+D'1', 1


		FC_CAL_Disable_ADC ();
0F76  ECF1F006  	CALL FC_CAL_Dis_0007B


		return (retVal);
0F7A  5169      	MOVF FCD_ADC0_R_0007E_1_retVal, W, 1
0F7C  6F6B      	MOVWF CompTempVarRet2327, 1
0F7E  516A      	MOVF FCD_ADC0_R_0007E_1_retVal+D'1', W, 1
0F80  6F6C      	MOVWF CompTempVarRet2327+D'1', 1


}
0F82  0012      	RETURN


MX_FLOAT FCD_ADC0_ReadAsVoltage()
{
	
		MX_UINT16 iSample;
		MX_FLOAT fSample, fVoltage, fVperDiv;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_2_MX_ADC_CHANNEL , ADC_2_MX_ADC_CONVSP , ADC_2_MX_ADC_VREFOP , ADC_2_MX_ADC_ACTIME );

	  #ifdef MX_ADC_BITS_8
		iSample = FC_CAL_Sample_ADC( 0 );								//Perform Sample - Return as byte
	  #else
		iSample = FC_CAL_Sample_ADC( 1 );								//Perform Sample - Return as MX_UINT16
	  #endif

	  	FC_CAL_Disable_ADC ();											//Switch off ADC peripheral
		fVoltage = flt_fromi( ADC_2_MX_ADC_VREFVOL );						//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = flt_mul(fVoltage, 0.01);								//Convert reference voltage count to actual voltage (0 - 5)

	  #ifdef MX_ADC_BITS_8
		fVperDiv = flt_mul(fVoltage, 0.00390625);						//Convert actual voltage to voltage per division (VRef / 256)
	  #endif
	  #ifdef MX_ADC_BITS_10
		fVperDiv = flt_mul(fVoltage, 0.000976);							//Convert actual voltage to voltage per division (VRef / 1024)
	  #endif
	  #ifdef MX_ADC_BITS_12
		fVperDiv = flt_mul(fVoltage, 0.00024414);						//Convert actual voltage to voltage per division (VRef / 4096)
	  #endif

		fSample = flt_fromi(iSample);									//Convert to floating point variable
		fVoltage = flt_mul(fSample, fVperDiv);							//Calculate floating point voltage

		return (fVoltage);

}

void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE)
{
	
		MX_FLOAT fVoltage;

		fVoltage = FCD_ADC0_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}

void FCD_ADC0_ADC_RAW_Configure_Channel()
{
	
		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_2_MX_ADC_CHANNEL , ADC_2_MX_ADC_CONVSP , ADC_2_MX_ADC_VREFOP , ADC_2_MX_ADC_ACTIME );

}

MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte()
{
	
		return FC_CAL_Sample_ADC( 0 );									//Perform Sample - Return as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int()
{
	
		return FC_CAL_Sample_ADC( 1 );									//Perform Sample - Return as MX_UINT16

}

MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 0 );					//Perform Sample - Return as byte - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0xFF);										//Return average as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 1 );					//Perform Sample - Return as MX_UINT16 - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0x1FFF);										//Return average as MX_SINT16

}

void FCD_ADC0_ADC_RAW_Disable_Channel()
{
	
		FC_CAL_Disable_ADC ();											//Disable ADC Channel

}



//ADC(1): //Macro implementations


void FCD_ADC1_SampleADC()
{
	
	    //unused

}

MX_UINT8 FCD_ADC1_ReadAsByte()

{
	
		MX_UINT8 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_3_MX_ADC_CHANNEL , ADC_3_MX_ADC_CONVSP , ADC_3_MX_ADC_VREFOP , ADC_3_MX_ADC_ACTIME );
0F2C  0E04      	MOVLW 0x04
0F2E  0102      	MOVLB 0x02
0F30  6F6B      	MOVWF FC_CAL_Ena_00079_arg_Channel, 1
0F32  0E03      	MOVLW 0x03
0F34  6F6C      	MOVWF FC_CAL_Ena_00079_arg_Conv_Speed, 1
0F36  6B6D      	CLRF FC_CAL_Ena_00079_arg_Vref, 1
0F38  0E28      	MOVLW 0x28
0F3A  6F6E      	MOVWF FC_CAL_Ena_00079_arg_T_Charge, 1
0F3C  ECB9F006  	CALL FC_CAL_Ena_00079


		retVal = FC_CAL_Sample_ADC( 0 );				//Perform Sample - Return as byte
0F40  6B6B      	CLRF FC_CAL_Sam_0007A_arg_Sample_Mode, 1
0F42  EC98F006  	CALL FC_CAL_Sam_0007A
0F46  516E      	MOVF CompTempVarRet2320, W, 1
0F48  6F69      	MOVWF FCD_ADC1_R_00089_1_retVal, 1


		FC_CAL_Disable_ADC ();
0F4A  ECF1F006  	CALL FC_CAL_Dis_0007B


		return (retVal);
0F4E  5169      	MOVF FCD_ADC1_R_00089_1_retVal, W, 1
0F50  6F6A      	MOVWF CompTempVarRet2354, 1


}
0F52  0012      	RETURN


MX_UINT16 FCD_ADC1_ReadAsInt()
{
	
		MX_UINT16 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_3_MX_ADC_CHANNEL , ADC_3_MX_ADC_CONVSP , ADC_3_MX_ADC_VREFOP , ADC_3_MX_ADC_ACTIME );

		retVal = FC_CAL_Sample_ADC( 1 );				//Perform Sample - Return as MX_UINT16

		FC_CAL_Disable_ADC ();

		return (retVal);

}

MX_FLOAT FCD_ADC1_ReadAsVoltage()
{
	
		MX_UINT16 iSample;
		MX_FLOAT fSample, fVoltage, fVperDiv;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_3_MX_ADC_CHANNEL , ADC_3_MX_ADC_CONVSP , ADC_3_MX_ADC_VREFOP , ADC_3_MX_ADC_ACTIME );

	  #ifdef MX_ADC_BITS_8
		iSample = FC_CAL_Sample_ADC( 0 );								//Perform Sample - Return as byte
	  #else
		iSample = FC_CAL_Sample_ADC( 1 );								//Perform Sample - Return as MX_UINT16
	  #endif

	  	FC_CAL_Disable_ADC ();											//Switch off ADC peripheral
		fVoltage = flt_fromi( ADC_3_MX_ADC_VREFVOL );						//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = flt_mul(fVoltage, 0.01);								//Convert reference voltage count to actual voltage (0 - 5)

	  #ifdef MX_ADC_BITS_8
		fVperDiv = flt_mul(fVoltage, 0.00390625);						//Convert actual voltage to voltage per division (VRef / 256)
	  #endif
	  #ifdef MX_ADC_BITS_10
		fVperDiv = flt_mul(fVoltage, 0.000976);							//Convert actual voltage to voltage per division (VRef / 1024)
	  #endif
	  #ifdef MX_ADC_BITS_12
		fVperDiv = flt_mul(fVoltage, 0.00024414);						//Convert actual voltage to voltage per division (VRef / 4096)
	  #endif

		fSample = flt_fromi(iSample);									//Convert to floating point variable
		fVoltage = flt_mul(fSample, fVperDiv);							//Calculate floating point voltage

		return (fVoltage);

}

void FCD_ADC1_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE)
{
	
		MX_FLOAT fVoltage;

		fVoltage = FCD_ADC1_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}

void FCD_ADC1_ADC_RAW_Configure_Channel()
{
	
		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_3_MX_ADC_CHANNEL , ADC_3_MX_ADC_CONVSP , ADC_3_MX_ADC_VREFOP , ADC_3_MX_ADC_ACTIME );

}

MX_UINT8 FCD_ADC1_ADC_RAW_Sample_Channel_Byte()
{
	
		return FC_CAL_Sample_ADC( 0 );									//Perform Sample - Return as byte

}

MX_UINT16 FCD_ADC1_ADC_RAW_Sample_Channel_Int()
{
	
		return FC_CAL_Sample_ADC( 1 );									//Perform Sample - Return as MX_UINT16

}

MX_UINT8 FCD_ADC1_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 0 );					//Perform Sample - Return as byte - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0xFF);										//Return average as byte

}

MX_UINT16 FCD_ADC1_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 1 );					//Perform Sample - Return as MX_UINT16 - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0x1FFF);										//Return average as MX_SINT16

}

void FCD_ADC1_ADC_RAW_Disable_Channel()
{
	
		FC_CAL_Disable_ADC ();											//Disable ADC Channel

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void main()

{
	//Initialization
	ansel = 0x00;
0F84  6A7E      	CLRF gbl_ansel

anselh = 0x00;
0F86  6A7F      	CLRF gbl_anselh


	
	  #ifdef FC_CAL_PIC								//8-bit PIC specific
	    #if defined(P18F24J50) || defined(P18F25J55) || defined(P18F26J50) || defined(P18F44J50) || defined(P18F45J50) || defined(P18F46J55) || defined(P18F87J50) ||  defined(P18F86J55) || defined(P18F86J50) || defined(P18F85J50) || defined(P18F67J50) || defined(P18F66J55) || defined(P18F66J50) || defined(P18F65J50)
		//On the PIC18F87J50 Family of USB microcontrollers, the PLL will not power up and be enabled
		//by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
		//This allows the device to power up at a lower initial operating frequency, which can be
		//advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
		//operation.  On these devices, user firmware needs to manually set the OSCTUNE<PLLEN> bit to
		//power up the PLL.
	    {
	        MX_UINT16 pll_startup_counter = 600;
	        OSCTUNEbits.PLLEN = 1;  //Enable the PLL and wait 2+ms until the PLL locks before enabling USB module
	        while(pll_startup_counter--);
	    }
	    //Device switches over automatically to PLL output after PLL is locked and ready.
	    #endif
	  #endif

	  #ifdef FC_CAL_PIC16BIT						//16-bit PIC specific
	    #if defined(P24FJ64GB004) || defined(P24FJ64GB002) || defined(P24FJ32GB004) || defined(P24FJ32GB002)
		//On the PIC24FJ64GB004 Family of USB microcontrollers, the PLL will not power up and be enabled
		//by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
		//This allows the device to power up at a lower initial operating frequency, which can be
		//advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
		//operation.  On these devices, user firmware needs to manually set the CLKDIV<PLLEN> bit to
		//power up the PLL.
	    {
	        MX_UINT16 pll_startup_counter = 600;
	        CLKDIVbits.PLLEN = 1;
	        while(pll_startup_counter--);
	    }
	    #endif
	  #endif


	//Interrupt initialization code
	


	//Call Component Macro
	//Call Component Macro: Initialise_Serial()
	FCD_USBSerial0_Initialise_Serial();
0F88  EC8CF007  	CALL FCD_USBSer_00073


	//Loop
	//Loop: While 1
	while (1)
0F8C            label111
0FDE  D7D6      	BRA	label111

	{

		//Call Component Macro
		//Call Component Macro: Operation=ReadByte(10)
		FCV_OPERATION = FCD_USBSerial0_ReadByte(10);
0F8C  0E0A      	MOVLW 0x0A
0F8E  6F69      	MOVWF FCD_USBSer_00076_arg_timeout_ms, 1
0F90  EC06F007  	CALL FCD_USBSer_00076
0F94  516C      	MOVF CompTempVarRet2312, W, 1
0F96  6F53      	MOVWF gbl_FCV_OPERATION, 1


		//Switch
		//Switch: Operation?
		switch (FCV_OPERATION)
		{
			case 0x31:
0F98  0E31      	MOVLW 0x31
0F9A  6353      	CPFSEQ gbl_FCV_OPERATION, 1
0F9C  D001      	BRA	label112
0F9E  D004      	BRA	label113
0FA0            label112
0FA6  D013      	BRA	label114
0FA8            label113

			{
				//Call Component Macro
				//Call Component Macro: ReadInput=ReadAsInt()
				FCV_READINPUT = FCD_ADC0_ReadAsInt();
0FA8  ECAAF007  	CALL FCD_ADC0_R_0007E
0FAC  516B      	MOVF CompTempVarRet2327, W, 1
0FAE  6F38      	MOVWF gbl_FCV_READINPUT, 1
0FB0  516C      	MOVF CompTempVarRet2327+D'1', W, 1
0FB2  6F39      	MOVWF gbl_FCV_READINPUT+D'1', 1


				#if 0 // Disabled code
				//Calculation
				//Calculation:
				//  OutStr = OutStr + 1
				FCV_OUTSTR = FCV_OUTSTR + 1;

				#endif // #if 0: Disabled code
				#if 0 // Disabled code
				//Call Component Macro
				//Call Component Macro: SendByte(OutStr)
				FCD_USBSerial0_SendByte(FCV_OUTSTR);

				#endif // #if 0: Disabled code
				//Calculation
				//Calculation:
				//  OutString[0] = (ReadInput)
				//  OutString[1] = (ReadInput >> 8)
				FCV_OUTSTRING[0] = (FCV_READINPUT);
0FB4  5138      	MOVF gbl_FCV_READINPUT, W, 1
0FB6  6F3A      	MOVWF gbl_FCV_OUTSTRING, 1

				FCV_OUTSTRING[1] = (FCV_READINPUT >> 8);
0FB8  5139      	MOVF gbl_FCV_READINPUT+D'1', W, 1
0FBA  6F3B      	MOVWF gbl_FCV_OUTSTRING+D'1', 1


				//Call Component Macro
				//Call Component Macro: SendString(OutString)
				FCD_USBSerial0_SendString(FCV_OUTSTRING, FCSZ_OUTSTRING);
0FBC  0E02      	MOVLW HIGH(gbl_FCV_OUTSTRING+D'0')
0FBE  6F6A      	MOVWF FCD_USBSer_00075_arg_String+D'1', 1
0FC0  0E3A      	MOVLW LOW(gbl_FCV_OUTSTRING+D'0')
0FC2  6F69      	MOVWF FCD_USBSer_00075_arg_String, 1
0FC4  0E02      	MOVLW 0x02
0FC6  6F6B      	MOVWF FCD_USBSer_00075_arg_MSZ_String, 1
0FC8  EC48F007  	CALL FCD_USBSer_00075


				break;
0FCC  D7DF      	BRA	label111

			}
			case 0x32:
0FA0  0E32      	MOVLW 0x32
0FA2  6353      	CPFSEQ gbl_FCV_OPERATION, 1
0FA4  D7F3      	BRA	label111
0FCE            label114

			{
				//Call Component Macro
				//Call Component Macro: OutStr=ReadAsByte()
				FCV_OUTSTR = FCD_ADC1_ReadAsByte();
0FCE  EC96F007  	CALL FCD_ADC1_R_00089
0FD2  516A      	MOVF CompTempVarRet2354, W, 1
0FD4  6F52      	MOVWF gbl_FCV_OUTSTR, 1


				//Call Component Macro
				//Call Component Macro: SendByte(OutStr)
				FCD_USBSerial0_SendByte(FCV_OUTSTR);
0FD6  5152      	MOVF gbl_FCV_OUTSTR, W, 1
0FD8  6F69      	MOVWF FCD_USBSer_00074_arg_byte, 1
0FDA  EC6BF007  	CALL FCD_USBSer_00074


				break;

			}
			// default:

		}


	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
	
	  #ifdef FC_CAL_PIC							//8-bit PIC specific
		usb_handle_isr();
1218  CFEAF001  	MOVFF FSR0H,  Int1Context
121C  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
1220  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
1224  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
1228  EC82F004  	CALL usb_handle_0004C

	  #endif


}
122C  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
1230  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
1234  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
1238  C001FFEA  	MOVFF Int1Context,  FSR0H
123C  0011      	RETFIE 1





/*********************************************************************
 *                    Flowcode USB Component Code
 *
 * File: pic_usb_buffer_mgt.c
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 031008 | BR | Created
 * 190711 | BR | Confirmed current version
 ********************************************************************/

#include "pic_usb_buffer_mgt.h"

#if (USB_DESCRIPTOR_BASE_ADDRESS == 0x200)
	#define USBEP0O		0x200
	#define USBEP0I		0x204
	#define USBEP1O		0x208
	#define USBEP1I		0x20C
	#define USBEP2O		0x210
	#define USBEP2I		0x214
	#define USBEP3O		0x218
	#define USBEP3I		0x21C
#endif

#if (USB_DESCRIPTOR_BASE_ADDRESS == 0x400)
	#define USBEP0O		0x400
	#define USBEP0I		0x404
	#define USBEP1O		0x408
	#define USBEP1I		0x40C
	#define USBEP2O		0x410
	#define USBEP2I		0x414
	#define USBEP3O		0x418
	#define USBEP3I		0x41C
#endif

buffer_descriptor bd0out@USBEP0O;
buffer_descriptor bd0in @USBEP0I;
buffer_descriptor bd1out@USBEP1O;
buffer_descriptor bd1in @USBEP1I;
buffer_descriptor bd2out@USBEP2O;
buffer_descriptor bd2in @USBEP2I;
buffer_descriptor bd3out@USBEP3O;
buffer_descriptor bd3in @USBEP3I;

uns8 buffer_0_out[USB_EP0_OUT_SIZE]@ USB_EP0_OUT_ADDR;
uns8 buffer_0_in [USB_EP0_IN_SIZE] @ USB_EP0_IN_ADDR;

#ifdef USB_EP1_IN_SIZE
	uns8 buffer_1_in [USB_EP1_IN_SIZE] @USB_EP1_IN_ADDR;
#endif
#ifdef USB_EP1_OUT_SIZE
	uns8 buffer_1_out [USB_EP1_OUT_SIZE] @ USB_EP1_OUT_ADDR;
#endif
#ifdef USB_EP2_IN_SIZE
	uns8 buffer_2_in [USB_EP2_IN_SIZE] @ USB_EP2_IN_ADDR;
#endif
#ifdef USB_EP2_OUT_SIZE
	uns8 buffer_2_out [USB_EP2_OUT_SIZE] @ USB_EP2_OUT_ADDR;
#endif
#ifdef USB_EP3_IN_SIZE
	uns8 buffer_3_in [USB_EP3_IN_SIZE] @ USB_EP3_IN_ADDR;
#endif
#ifdef USB_EP3_OUT_SIZE
	uns8 buffer_3_out [USB_EP3_OUT_SIZE] @ USB_EP3_OUT_ADDR;
#endif

buffer_descriptor * ep_in_bd_location[USB_HIGHEST_EP + 1];
buffer_descriptor * ep_out_bd_location[USB_HIGHEST_EP + 1];

uns8 * ep_in_buffer_location[USB_HIGHEST_EP + 1] = {
	// we always have EP0

	&buffer_0_in,	// ep 0 in buffer location
115C  0E02      	MOVLW HIGH(gbl_buffer_0_in+D'0')
115E  0102      	MOVLB 0x02
1160  6F57      	MOVWF CompGblVar60, 1
1162  0E88      	MOVLW LOW(gbl_buffer_0_in+D'0')
1164  0101      	MOVLB 0x01
1166  6FB7      	MOVWF gbl_ep_in_buffer_location, 1
1168  0102      	MOVLB 0x02
116A  5157      	MOVF CompGblVar60, W, 1
116C  0101      	MOVLB 0x01
116E  6FB8      	MOVWF gbl_ep_in_buffer_location+D'1', 1


	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_IN_SIZE
			&buffer_1_in,	// ep 1 in buffer location
		#else
			0,
1170  6BB9      	CLRF gbl_ep_in_buffer_location+D'2', 1
1172  6BBA      	CLRF gbl_ep_in_buffer_location+D'3', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_IN_SIZE
			&buffer_2_in,	// ep 2 in buffer location
1174  0E02      	MOVLW HIGH(gbl_buffer_2_in+D'0')
1176  0102      	MOVLB 0x02
1178  6F58      	MOVWF CompGblVar61, 1
117A  0E90      	MOVLW LOW(gbl_buffer_2_in+D'0')
117C  0101      	MOVLB 0x01
117E  6FBB      	MOVWF gbl_ep_in_buffer_location+D'4', 1
1180  0102      	MOVLB 0x02
1182  5158      	MOVF CompGblVar61, W, 1
1184  0101      	MOVLB 0x01
1186  6FBC      	MOVWF gbl_ep_in_buffer_location+D'5', 1

		#else
			0,
		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_IN_SIZE
			&buffer_3_in,	// ep 3 in buffer location
1188  0E02      	MOVLW HIGH(gbl_buffer_3_in+D'0')
118A  0102      	MOVLB 0x02
118C  6F59      	MOVWF CompGblVar62, 1
118E  0EA0      	MOVLW LOW(gbl_buffer_3_in+D'0')
1190  0101      	MOVLB 0x01
1192  6FBD      	MOVWF gbl_ep_in_buffer_location+D'6', 1
1194  0102      	MOVLB 0x02
1196  5159      	MOVF CompGblVar62, W, 1
1198  0101      	MOVLB 0x01
119A  6FBE      	MOVWF gbl_ep_in_buffer_location+D'7', 1

		#else
			0,
		#endif
	#endif
};

uns8 * ep_out_buffer_location[USB_HIGHEST_EP + 1] = {
	// we always have EP0

	&buffer_0_out,	// ep 0 in buffer location
119C  0E02      	MOVLW HIGH(gbl_buffer_0_out+D'0')
119E  0102      	MOVLB 0x02
11A0  6F5A      	MOVWF CompGblVar63, 1
11A2  0E80      	MOVLW LOW(gbl_buffer_0_out+D'0')
11A4  0101      	MOVLB 0x01
11A6  6FBF      	MOVWF gbl_ep_out_buffer_location, 1
11A8  0102      	MOVLB 0x02
11AA  515A      	MOVF CompGblVar63, W, 1
11AC  0101      	MOVLB 0x01
11AE  6FC0      	MOVWF gbl_ep_out_buffer_location+D'1', 1


	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_OUT_SIZE
			&buffer_1_out,	// ep 1 in buffer location
		#else
			0,
11B0  6BC1      	CLRF gbl_ep_out_buffer_location+D'2', 1
11B2  6BC2      	CLRF gbl_ep_out_buffer_location+D'3', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_OUT_SIZE
			&buffer_2_out,	// ep 2 in buffer location
		#else
			0,
11B4  6BC3      	CLRF gbl_ep_out_buffer_location+D'4', 1
11B6  6BC4      	CLRF gbl_ep_out_buffer_location+D'5', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_OUT_SIZE
			&buffer_3_out,	// ep 3 in buffer location
11B8  0E02      	MOVLW HIGH(gbl_buffer_3_out+D'0')
11BA  0102      	MOVLB 0x02
11BC  6F5B      	MOVWF CompGblVar64, 1
11BE  0E98      	MOVLW LOW(gbl_buffer_3_out+D'0')
11C0  0101      	MOVLB 0x01
11C2  6FC5      	MOVWF gbl_ep_out_buffer_location+D'6', 1
11C4  0102      	MOVLB 0x02
11C6  515B      	MOVF CompGblVar64, W, 1
11C8  0101      	MOVLB 0x01
11CA  6FC6      	MOVWF gbl_ep_out_buffer_location+D'7', 1

		#else
			0,
		#endif
	#endif
};


uns16 ep_in_buffer_size[USB_HIGHEST_EP + 1] = {
	USB_EP0_IN_SIZE,
11CC  0E08      	MOVLW 0x08
11CE  6FC7      	MOVWF gbl_ep_in_buffer_size, 1
11D0  6BC8      	CLRF gbl_ep_in_buffer_size+D'1', 1


	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_IN_SIZE
			USB_EP1_IN_SIZE,
		#else
			0,
11D2  6BC9      	CLRF gbl_ep_in_buffer_size+D'2', 1
11D4  6BCA      	CLRF gbl_ep_in_buffer_size+D'3', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_IN_SIZE
			USB_EP2_IN_SIZE,
11D6  0E08      	MOVLW 0x08
11D8  6FCB      	MOVWF gbl_ep_in_buffer_size+D'4', 1
11DA  6BCC      	CLRF gbl_ep_in_buffer_size+D'5', 1

		#else
			0,
		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_IN_SIZE
			USB_EP3_IN_SIZE,
11DC  0E08      	MOVLW 0x08
11DE  6FCD      	MOVWF gbl_ep_in_buffer_size+D'6', 1
11E0  6BCE      	CLRF gbl_ep_in_buffer_size+D'7', 1

		#else
			0,
		#endif
	#endif
};



uns16 ep_out_buffer_size[USB_HIGHEST_EP + 1] = {
	USB_EP0_OUT_SIZE,
11E2  0E08      	MOVLW 0x08
11E4  6FCF      	MOVWF gbl_ep_out_buffer_size, 1
11E6  6BD0      	CLRF gbl_ep_out_buffer_size+D'1', 1


	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_OUT_SIZE
			USB_EP1_OUT_SIZE,
		#else
			0,
11E8  6BD1      	CLRF gbl_ep_out_buffer_size+D'2', 1
11EA  6BD2      	CLRF gbl_ep_out_buffer_size+D'3', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_OUT_SIZE
			USB_EP2_OUT_SIZE,
		#else
			0,
11EC  6BD3      	CLRF gbl_ep_out_buffer_size+D'4', 1
11EE  6BD4      	CLRF gbl_ep_out_buffer_size+D'5', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_OUT_SIZE
			USB_EP3_OUT_SIZE,
11F0  0E08      	MOVLW 0x08
11F2  6FD5      	MOVWF gbl_ep_out_buffer_size+D'6', 1
11F4  6BD6      	CLRF gbl_ep_out_buffer_size+D'7', 1

		#else
			0,
		#endif
	#endif
};

/*********************************************************************
 *                    Flowcode USB Component Code
 *
 * File: pic_usb.c
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 031008 | BR | Created
 * 170409 | BR | Ammended Standard Request function to fix timeout bug in Linux systems
 * 010509 | BR | Slight change to allow 18FXXK50 devices to work correctly.
 * 190711 | BR | Confirmed current version
 ********************************************************************/

#include <memory.h>
#include "pic_usb.h"
#include "pic_usb_buffer_mgt.h"


// globally accessible variables

usb_state_type usb_state = st_POWERED;
11F6  0102      	MOVLB 0x02
11F8  6B54      	CLRF gbl_usb_state, 1


setup_data_packet usb_sdp;

uns8 usb_address;
control_mode_type control_mode;
uns16 delivery_bytes_to_send,
	  delivery_bytes_max_send,
		delivery_bytes_sent;
uns8 *delivery_ptr;
uns8 delivery_buffer_size;
uns8 *delivery_buffer;
buffer_descriptor *delivery_bd;

usb_status_type usb_status;

void usb_configure_endpoints()

{

#ifdef USB_EP1
	set_bit  (uep1, EPHSHK);		// EP handshaking on
	#ifdef USB_EP1_OUT_SIZE
		set_bit(uep1, EPOUTEN);		// EP OUT enabled
	#else
		clear_bit(uep1, EPOUTEN);	// EP OUT disabled
	#endif
	#ifdef USB_EP1_IN_SIZE
		set_bit(uep1, EPINEN);		// EP IN enabled
	#else
		clear_bit(uep1, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep1, EPCONDIS);		// control transfers off

	// for IN
	#ifdef USB_EP1_IN_SIZE
		set_bit(bd1in.stat, DTS);		// turn on data togle sync TOGGLE
		clear_bit(bd1in.stat, KEN);		// clear the keep bit
		clear_bit(bd1in.stat, INCDIS);	// clear the increment disable
		clear_bit(bd1in.stat, DTSEN);
		clear_bit(bd1in.stat, BSTALL);	// clear stall bit
		clear_bit(bd1in.stat, BC9);
		clear_bit(bd1in.stat, BC8);

		clear_bit(bd1in.stat, UOWN);	// uC owns the buffer
	#endif
	// for OUT
	#ifdef USB_EP1_OUT_SIZE
		bd1out.count = USB_EP1_OUT_SIZE;
		bd1out.addr  = USB_EP1_OUT_ADDR;

		clear_bit(bd1out.stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd1out.stat, KEN);	// clear the keep bit
		clear_bit(bd1out.stat, INCDIS);	// clear the increment disable
		clear_bit(bd1out.stat, DTSEN);
		clear_bit(bd1out.stat, BSTALL);	// clear stall bit
		clear_bit(bd1out.stat, BC9);
		clear_bit(bd1out.stat, BC8);
		set_bit  (bd1out.stat, UOWN);	// SIE owns the buffer

	#endif
#endif

#ifdef USB_EP2
	set_bit  (uep2, EPHSHK);		// EP handshaking on
02F4  010F      	MOVLB 0x0F
02F6  8955      	BSF gbl_uep2,4, 1

	#ifdef USB_EP2_OUT_SIZE
		set_bit(uep2, EPOUTEN);		// EP OUT enabled
	#else
		clear_bit(uep2, EPOUTEN);	// EP OUT disabled
02F8  9555      	BCF gbl_uep2,2, 1

	#endif
	#ifdef USB_EP2_IN_SIZE
		set_bit(uep2, EPINEN);		// EP IN enabled
02FA  8355      	BSF gbl_uep2,1, 1

	#else
		clear_bit(uep2, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep2, EPCONDIS);		// control transfers off
02FC  8755      	BSF gbl_uep2,3, 1


	// for IN
	#ifdef USB_EP2_IN_SIZE

		set_bit(bd2in.stat, DTS);		// turn on data togle sync TOGGLE
02FE  0102      	MOVLB 0x02
0300  8D14      	BSF gbl_bd2in,6, 1

		clear_bit(bd2in.stat, KEN);		// clear the keep bit
0302  9B14      	BCF gbl_bd2in,5, 1

		clear_bit(bd2in.stat, INCDIS);	// clear the increment disable
0304  9914      	BCF gbl_bd2in,4, 1

		clear_bit(bd2in.stat, DTSEN);
0306  9714      	BCF gbl_bd2in,3, 1

		clear_bit(bd2in.stat, BSTALL);	// clear stall bit
0308  9514      	BCF gbl_bd2in,2, 1

		clear_bit(bd2in.stat, BC9);
030A  9314      	BCF gbl_bd2in,1, 1

		clear_bit(bd2in.stat, BC8);
030C  9114      	BCF gbl_bd2in,0, 1


		clear_bit(bd2in.stat, UOWN);	// uC owns the buffer
030E  9F14      	BCF gbl_bd2in,7, 1

	#endif
	// for OUT
	#ifdef USB_EP2_OUT_SIZE
		bd2out.count = USB_EP2_OUT_SIZE;
		bd2out.addr  = USB_EP2_OUT_ADDR;

		clear_bit(bd2out.stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd2out.stat, KEN);	// clear the keep bit
		clear_bit(bd2out.stat, INCDIS);	// clear the increment disable
		clear_bit(bd2out.stat, DTSEN);
		clear_bit(bd2out.stat, BSTALL);	// clear stall bit
		clear_bit(bd2out.stat, BC9);
		clear_bit(bd2out.stat, BC8);
		set_bit  (bd2out.stat, UOWN);	// SIE owns the buffer
	#endif
#endif

#ifdef USB_EP3
	set_bit  (uep3, EPHSHK);		// EP handshaking on
0310  010F      	MOVLB 0x0F
0312  8956      	BSF gbl_uep3,4, 1

	#ifdef USB_EP3_OUT_SIZE
		set_bit(uep3, EPOUTEN);		// EP OUT enabled
0314  8556      	BSF gbl_uep3,2, 1

	#else
		clear_bit(uep3, EPOUTEN);	// EP OUT disabled
	#endif
	#ifdef USB_EP3_IN_SIZE
		set_bit(uep3, EPINEN);		// EP IN enabled
0316  8356      	BSF gbl_uep3,1, 1

	#else
		clear_bit(uep3, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep3, EPCONDIS);		// control transfers off
0318  8756      	BSF gbl_uep3,3, 1

	// for IN
	#ifdef USB_EP3_IN_SIZE
		set_bit(bd3in.stat, DTS);		// ready for toggle
031A  0102      	MOVLB 0x02
031C  8D1C      	BSF gbl_bd3in,6, 1

		clear_bit(bd3in.stat, KEN);		// clear the keep bit
031E  9B1C      	BCF gbl_bd3in,5, 1

		clear_bit(bd3in.stat, INCDIS);	// clear the increment disable
0320  991C      	BCF gbl_bd3in,4, 1

		clear_bit(bd3in.stat, DTSEN);
0322  971C      	BCF gbl_bd3in,3, 1

		clear_bit(bd3in.stat, BSTALL);	// clear stall bit
0324  951C      	BCF gbl_bd3in,2, 1

		clear_bit(bd3in.stat, BC9);
0326  931C      	BCF gbl_bd3in,1, 1

		clear_bit(bd3in.stat, BC8);
0328  911C      	BCF gbl_bd3in,0, 1


		clear_bit(bd3in.stat, UOWN);	// uC owns the buffer
032A  9F1C      	BCF gbl_bd3in,7, 1

	#endif
	// for OUT
	#ifdef USB_EP3_OUT_SIZE
		bd3out.count = USB_EP3_OUT_SIZE;
032C  0E08      	MOVLW 0x08
032E  6F19      	MOVWF gbl_bd3out+D'1', 1

		bd3out.addr  = USB_EP3_OUT_ADDR;
0330  0E98      	MOVLW 0x98
0332  6F1A      	MOVWF gbl_bd3out+D'2', 1
0334  0E02      	MOVLW 0x02
0336  6F1B      	MOVWF gbl_bd3out+D'3', 1


		clear_bit(bd3out.stat, DTS);	// turn on data togle sync TOGGLE
0338  9D18      	BCF gbl_bd3out,6, 1

		clear_bit(bd3out.stat, KEN);	// clear the keep bit
033A  9B18      	BCF gbl_bd3out,5, 1

		clear_bit(bd3out.stat, INCDIS);	// clear the increment disable
033C  9918      	BCF gbl_bd3out,4, 1

		clear_bit(bd3out.stat, DTSEN);
033E  9718      	BCF gbl_bd3out,3, 1

		clear_bit(bd3out.stat, BSTALL);	// clear stall bit
0340  9518      	BCF gbl_bd3out,2, 1

		clear_bit(bd3out.stat, BC9);
0342  9318      	BCF gbl_bd3out,1, 1

		clear_bit(bd3out.stat, BC8);
0344  9118      	BCF gbl_bd3out,0, 1

		set_bit  (bd3out.stat, UOWN);	// SIE owns the buffer
0346  8F18      	BSF gbl_bd3out,7, 1

	#endif

#endif

}
0348  0012      	RETURN


void usb_stall_ep0()

{
	set_bit(bd0in.stat, BSTALL);	// stall
00DC  0102      	MOVLB 0x02
00DE  8504      	BSF gbl_bd0in,2, 1

	set_bit(bd0in.stat, UOWN);		// SIE owns the buffer
00E0  8F04      	BSF gbl_bd0in,7, 1

	set_bit(bd0out.stat, BSTALL);	// stall
00E2  8500      	BSF gbl_bd0out,2, 1

	set_bit(bd0out.stat, UOWN);		// SIE owns the buffer
00E4  8F00      	BSF gbl_bd0out,7, 1

}
00E6  0012      	RETURN


void usb_send_data(uns8 ep, uns8 *data, uns8 send_count, bit first)

{
	uns8 count;
	buffer_descriptor *bd;
	uns8 *buffer;

	// this is going to be an IN transaction

	// need to grab buffer descriptor
	buffer = ep_in_buffer_location[ep];
014C  0101      	MOVLB 0x01
014E  EE01F0B7  	LFSR 0x00, gbl_ep_in_buffer_location
0152  50E9      	MOVF FSR0L, W
0154  0102      	MOVLB 0x02
0156  517F      	MOVF usb_send_d_00052_arg_ep, W, 1
0158  6FB1      	MOVWF CompTempVar2242, 1
015A  90D8      	BCF STATUS,C
015C  35B1      	RLCF CompTempVar2242, W, 1
015E  26E9      	ADDWF FSR0L, F
0160  50EE      	MOVF POSTINC0, W
0162  6FAF      	MOVWF usb_send_d_00052_1_buffer, 1
0164  50EF      	MOVF INDF0, W
0166  6FB0      	MOVWF usb_send_d_00052_1_buffer+D'1', 1


	bd = ep_in_bd_location[ep];
0168  0101      	MOVLB 0x01
016A  EE01F0A7  	LFSR 0x00, gbl_ep_in_bd_location
016E  50E9      	MOVF FSR0L, W
0170  0102      	MOVLB 0x02
0172  517F      	MOVF usb_send_d_00052_arg_ep, W, 1
0174  6FB1      	MOVWF CompTempVar2245, 1
0176  90D8      	BCF STATUS,C
0178  35B1      	RLCF CompTempVar2245, W, 1
017A  26E9      	ADDWF FSR0L, F
017C  50EE      	MOVF POSTINC0, W
017E  6FAD      	MOVWF usb_send_d_00052_1_bd, 1
0180  50EF      	MOVF INDF0, W
0182  6FAE      	MOVWF usb_send_d_00052_1_bd+D'1', 1


	if (test_bit(bd->stat, UOWN))
0184  51AE      	MOVF usb_send_d_00052_1_bd+D'1', W, 1
0186  6EEA      	MOVWF FSR0H
0188  51AD      	MOVF usb_send_d_00052_1_bd, W, 1
018A  6EE9      	MOVWF FSR0L
018C  BEEF      	BTFSC INDF0,7

	{
		return;
	}

	count = 0;
0190  6BAC      	CLRF usb_send_d_00052_1_count, 1

	while ((count < send_count))
0192            label13
0192  51AA      	MOVF usb_send_d_00052_arg_send_count, W, 1
0194  61AC      	CPFSLT usb_send_d_00052_1_count, 1
0196  D013      	BRA	label14
01BC  D7EA      	BRA	label13
01BE            label14

	{
	    buffer[count] = data[count];
0198  51A9      	MOVF usb_send_d_00052_arg_data+D'1', W, 1
019A  6EEA      	MOVWF FSR0H
019C  51A8      	MOVF usb_send_d_00052_arg_data, W, 1
019E  6EE9      	MOVWF FSR0L
01A0  51AC      	MOVF usb_send_d_00052_1_count, W, 1
01A2  6FB1      	MOVWF CompTempVar2248, 1
01A4  51B1      	MOVF CompTempVar2248, W, 1
01A6  26E9      	ADDWF FSR0L, F
01A8  50EF      	MOVF INDF0, W
01AA  6FB2      	MOVWF CompTempVar2249, 1
01AC  51B0      	MOVF usb_send_d_00052_1_buffer+D'1', W, 1
01AE  6EEA      	MOVWF FSR0H
01B0  51AF      	MOVF usb_send_d_00052_1_buffer, W, 1
01B2  25AC      	ADDWF usb_send_d_00052_1_count, W, 1
01B4  6EE9      	MOVWF FSR0L
01B6  51B2      	MOVF CompTempVar2249, W, 1
01B8  6EEF      	MOVWF INDF0

	    count++;
01BA  2BAC      	INCF usb_send_d_00052_1_count, F, 1

	}

	bd->count = count;
01BE  51AE      	MOVF usb_send_d_00052_1_bd+D'1', W, 1
01C0  6EEA      	MOVWF FSR0H
01C2  29AD      	INCF usb_send_d_00052_1_bd, W, 1
01C4  6EE9      	MOVWF FSR0L
01C6  51AC      	MOVF usb_send_d_00052_1_count, W, 1
01C8  6EEF      	MOVWF INDF0

	bd->addr = (uns16)buffer;
01CA  06E9      	DECF FSR0L, F
01CC  0E02      	MOVLW 0x02
01CE  26E9      	ADDWF FSR0L, F
01D0  2AE9      	INCF FSR0L, F
01D2  51AF      	MOVF usb_send_d_00052_1_buffer, W, 1
01D4  6FB1      	MOVWF CompTempVar2250, 1
01D6  51B0      	MOVF usb_send_d_00052_1_buffer+D'1', W, 1
01D8  6EEF      	MOVWF INDF0
01DA  06E9      	DECF FSR0L, F
01DC  51B1      	MOVF CompTempVar2250, W, 1
01DE  6EEF      	MOVWF INDF0

	if (first)
01E0  A1AB      	BTFSS usb_send_d_00052_arg_first,0, 1
01E2  D005      	BRA	label15
01EE            label15

	{
		clear_bit(bd->stat, DTS);
01E4  51AE      	MOVF usb_send_d_00052_1_bd+D'1', W, 1
01E6  6EEA      	MOVWF FSR0H
01E8  51AD      	MOVF usb_send_d_00052_1_bd, W, 1
01EA  6EE9      	MOVWF FSR0L
01EC  9CEF      	BCF INDF0,6

	}
	if (test_bit(bd->stat, DTS))
01EE  51AE      	MOVF usb_send_d_00052_1_bd+D'1', W, 1
01F0  6EEA      	MOVWF FSR0H
01F2  51AD      	MOVF usb_send_d_00052_1_bd, W, 1
01F4  6EE9      	MOVWF FSR0L
01F6  ACEF      	BTFSS INDF0,6
01F8  D006      	BRA	label16
0206            label16

		clear_bit(bd->stat, DTS);
01FA  51AE      	MOVF usb_send_d_00052_1_bd+D'1', W, 1
01FC  6EEA      	MOVWF FSR0H
01FE  51AD      	MOVF usb_send_d_00052_1_bd, W, 1
0200  6EE9      	MOVWF FSR0L
0202  9CEF      	BCF INDF0,6

	else set_bit(bd->stat, DTS);
0204  D005      	BRA	label17
0206  51AE      	MOVF usb_send_d_00052_1_bd+D'1', W, 1
0208  6EEA      	MOVWF FSR0H
020A  51AD      	MOVF usb_send_d_00052_1_bd, W, 1
020C  6EE9      	MOVWF FSR0L
020E  8CEF      	BSF INDF0,6
0210            label17

	clear_bit(bd->stat, KEN);		// clear the keep bit
0210  51AE      	MOVF usb_send_d_00052_1_bd+D'1', W, 1
0212  6EEA      	MOVWF FSR0H
0214  51AD      	MOVF usb_send_d_00052_1_bd, W, 1
0216  6EE9      	MOVWF FSR0L
0218  9AEF      	BCF INDF0,5

	clear_bit(bd->stat, INCDIS);	// clear the increment disable
021A  98EF      	BCF INDF0,4

	set_bit  (bd->stat, DTSEN);
021C  86EF      	BSF INDF0,3

	clear_bit(bd->stat, BSTALL);	// clear stall bit
021E  94EF      	BCF INDF0,2

	clear_bit(bd->stat, BC9);
0220  92EF      	BCF INDF0,1

	clear_bit(bd->stat, BC8);
0222  90EF      	BCF INDF0,0


	set_bit  (bd->stat, UOWN);		// SIE owns the buffer
0224  8EEF      	BSF INDF0,7

}
018E  0012      	RETURN
0226  0012      	RETURN




void usb_send_data_chunk()

{

uns8 count;

	count = 0;
004A  0102      	MOVLB 0x02
004C  6BAA      	CLRF usb_send_d_00054_1_count, 1

	while ((count < delivery_buffer_size) &&
004E            label4
004E  515C      	MOVF gbl_delivery_buffer_size, W, 1
0050  61AA      	CPFSLT usb_send_d_00054_1_count, 1
0052  D01F      	BRA	label7
0090  D7DE      	BRA	label4
0092            label7

			(delivery_bytes_sent < delivery_bytes_to_send) &&
0054  513D      	MOVF gbl_delivery_bytes_to_send+D'1', W, 1
0056  5D41      	SUBWF gbl_delivery_bytes_sent+D'1', W, 1
0058  E102      	BNZ	label5
005A  513C      	MOVF gbl_delivery_bytes_to_send, W, 1
005C  5D40      	SUBWF gbl_delivery_bytes_sent, W, 1
005E            label5
005E  E219      	BC	label7

			(delivery_bytes_sent < delivery_bytes_max_send)) {
0060  513F      	MOVF gbl_delivery_bytes_max_send+D'1', W, 1
0062  5D41      	SUBWF gbl_delivery_bytes_sent+D'1', W, 1
0064  E102      	BNZ	label6
0066  513E      	MOVF gbl_delivery_bytes_max_send, W, 1
0068  5D40      	SUBWF gbl_delivery_bytes_sent, W, 1
006A            label6
006A  E213      	BC	label7

	    delivery_buffer[count] = *delivery_ptr;
006C  5143      	MOVF gbl_delivery_ptr+D'1', W, 1
006E  6EEA      	MOVWF FSR0H
0070  5142      	MOVF gbl_delivery_ptr, W, 1
0072  6EE9      	MOVWF FSR0L
0074  50EF      	MOVF INDF0, W
0076  6FAB      	MOVWF CompTempVar2258, 1
0078  5145      	MOVF gbl_delivery_buffer+D'1', W, 1
007A  6EEA      	MOVWF FSR0H
007C  5144      	MOVF gbl_delivery_buffer, W, 1
007E  25AA      	ADDWF usb_send_d_00054_1_count, W, 1
0080  6EE9      	MOVWF FSR0L
0082  51AB      	MOVF CompTempVar2258, W, 1
0084  6EEF      	MOVWF INDF0

	    delivery_ptr++;
0086  4B42      	INFSNZ gbl_delivery_ptr, F, 1
0088  2B43      	INCF gbl_delivery_ptr+D'1', F, 1

	    delivery_bytes_sent++;
008A  4B40      	INFSNZ gbl_delivery_bytes_sent, F, 1
008C  2B41      	INCF gbl_delivery_bytes_sent+D'1', F, 1

	    count++;
008E  2BAA      	INCF usb_send_d_00054_1_count, F, 1

	}

	if ((count < delivery_buffer_size) &&
0092  515C      	MOVF gbl_delivery_buffer_size, W, 1
0094  61AA      	CPFSLT usb_send_d_00054_1_count, 1
0096  D00F      	BRA	label10
00B6            label10

			((delivery_bytes_sent == delivery_bytes_max_send) ||
0098  513E      	MOVF gbl_delivery_bytes_max_send, W, 1
009A  6340      	CPFSEQ gbl_delivery_bytes_sent, 1
009C  D004      	BRA	label8
009E  513F      	MOVF gbl_delivery_bytes_max_send+D'1', W, 1
00A0  6341      	CPFSEQ gbl_delivery_bytes_sent+D'1', 1
00A2  D001      	BRA	label8
00A4  D006      	BRA	label9
00A6            label8

			(delivery_bytes_sent == delivery_bytes_to_send))) {
00A6  513C      	MOVF gbl_delivery_bytes_to_send, W, 1
00A8  6340      	CPFSEQ gbl_delivery_bytes_sent, 1
00AA  D005      	BRA	label10
00AC  513D      	MOVF gbl_delivery_bytes_to_send+D'1', W, 1
00AE  6341      	CPFSEQ gbl_delivery_bytes_sent+D'1', 1
00B0  D002      	BRA	label10
00B2            label9

		control_mode = cm_CTRL_READ_AWAITING_STATUS;	// we're done with data stage
00B2  0E05      	MOVLW 0x05
00B4  6F56      	MOVWF gbl_control_mode, 1

	}

	bd0in.count = count;
00B6  51AA      	MOVF usb_send_d_00054_1_count, W, 1
00B8  6F05      	MOVWF gbl_bd0in+D'1', 1

	bd0in.addr = (uns16)&buffer_0_in;
00BA  0E02      	MOVLW HIGH(gbl_buffer_0_in+D'0')
00BC  6F07      	MOVWF gbl_bd0in+D'3', 1
00BE  0E88      	MOVLW LOW(gbl_buffer_0_in+D'0')
00C0  6F06      	MOVWF gbl_bd0in+D'2', 1

	if (test_bit(bd0in.stat, DTS))
00C2  AD04      	BTFSS gbl_bd0in,6, 1
00C4  D002      	BRA	label11
00CA            label11

		clear_bit(bd0in.stat, DTS);
00C6  9D04      	BCF gbl_bd0in,6, 1

	else set_bit(bd0in.stat, DTS);
00C8  D001      	BRA	label12
00CA  8D04      	BSF gbl_bd0in,6, 1
00CC            label12

	clear_bit(bd0in.stat, KEN);		// clear the keep bit
00CC  9B04      	BCF gbl_bd0in,5, 1

	clear_bit(bd0in.stat, INCDIS);	// clear the increment disable
00CE  9904      	BCF gbl_bd0in,4, 1

	set_bit  (bd0in.stat, DTSEN);
00D0  8704      	BSF gbl_bd0in,3, 1

	clear_bit(bd0in.stat, BSTALL);	// clear stall bit
00D2  9504      	BCF gbl_bd0in,2, 1

	clear_bit(bd0in.stat, BC9);
00D4  9304      	BCF gbl_bd0in,1, 1

	clear_bit(bd0in.stat, BC8);
00D6  9104      	BCF gbl_bd0in,0, 1


	set_bit  (bd0in.stat, UOWN);	// SIE owns the buffer
00D8  8F04      	BSF gbl_bd0in,7, 1

}
00DA  0012      	RETURN



void usb_send_empty_data_pkt()

{
	delivery_buffer_size = USB_EP0_IN_SIZE;
011E  0E08      	MOVLW 0x08
0120  0102      	MOVLB 0x02
0122  6F5C      	MOVWF gbl_delivery_buffer_size, 1

	delivery_bd = &bd0in;
0124  0E02      	MOVLW HIGH(gbl_bd0in+D'0')
0126  6F47      	MOVWF gbl_delivery_bd+D'1', 1
0128  0E04      	MOVLW LOW(gbl_bd0in+D'0')
012A  6F46      	MOVWF gbl_delivery_bd, 1

	delivery_buffer = &buffer_0_in;
012C  0E02      	MOVLW HIGH(gbl_buffer_0_in+D'0')
012E  6F45      	MOVWF gbl_delivery_buffer+D'1', 1
0130  0E88      	MOVLW LOW(gbl_buffer_0_in+D'0')
0132  6F44      	MOVWF gbl_delivery_buffer, 1

	delivery_bytes_sent = 0;
0134  6B40      	CLRF gbl_delivery_bytes_sent, 1
0136  6B41      	CLRF gbl_delivery_bytes_sent+D'1', 1

	delivery_bytes_to_send = 0;
0138  6B3C      	CLRF gbl_delivery_bytes_to_send, 1
013A  6B3D      	CLRF gbl_delivery_bytes_to_send+D'1', 1

	delivery_bytes_max_send = 0;
013C  6B3E      	CLRF gbl_delivery_bytes_max_send, 1
013E  6B3F      	CLRF gbl_delivery_bytes_max_send+D'1', 1

	delivery_ptr = (uns8 *) 0;
0140  6B42      	CLRF gbl_delivery_ptr, 1
0142  6B43      	CLRF gbl_delivery_ptr+D'1', 1

	clear_bit(bd0in.stat, DTS);		// ready to get toggled
0144  9D04      	BCF gbl_bd0in,6, 1

	usb_send_data_chunk();
0146  EC25F000  	CALL usb_send_d_00054

}
014A  0012      	RETURN


uns8 buffer_byte;

void usb_send_one_byte(uns8 data)

{
	delivery_buffer_size = USB_EP0_IN_SIZE;
00E8  0E08      	MOVLW 0x08
00EA  6F5C      	MOVWF gbl_delivery_buffer_size, 1

	delivery_bytes_sent = 0;
00EC  6B40      	CLRF gbl_delivery_bytes_sent, 1
00EE  6B41      	CLRF gbl_delivery_bytes_sent+D'1', 1

	delivery_bytes_to_send = 1;
00F0  0E01      	MOVLW 0x01
00F2  6F3C      	MOVWF gbl_delivery_bytes_to_send, 1
00F4  6B3D      	CLRF gbl_delivery_bytes_to_send+D'1', 1

	delivery_bytes_max_send = 0;
00F6  6B3E      	CLRF gbl_delivery_bytes_max_send, 1
00F8  6B3F      	CLRF gbl_delivery_bytes_max_send+D'1', 1

	buffer_byte = data;
00FA  51A9      	MOVF usb_send_o_00066_arg_data, W, 1
00FC  6F5E      	MOVWF gbl_buffer_byte, 1

	delivery_ptr = (uns8 *) &buffer_byte;
00FE  0E02      	MOVLW HIGH(gbl_buffer_byte+D'0')
0100  6F43      	MOVWF gbl_delivery_ptr+D'1', 1
0102  0E5E      	MOVLW LOW(gbl_buffer_byte+D'0')
0104  6F42      	MOVWF gbl_delivery_ptr, 1

	delivery_bd = &bd0in;
0106  0E02      	MOVLW HIGH(gbl_bd0in+D'0')
0108  6F47      	MOVWF gbl_delivery_bd+D'1', 1
010A  0E04      	MOVLW LOW(gbl_bd0in+D'0')
010C  6F46      	MOVWF gbl_delivery_bd, 1

	delivery_buffer = &buffer_0_in;
010E  0E02      	MOVLW HIGH(gbl_buffer_0_in+D'0')
0110  6F45      	MOVWF gbl_delivery_buffer+D'1', 1
0112  0E88      	MOVLW LOW(gbl_buffer_0_in+D'0')
0114  6F44      	MOVWF gbl_delivery_buffer, 1


	clear_bit(bd0in.stat, DTS);		// ready to get toggled
0116  9D04      	BCF gbl_bd0in,6, 1

	usb_send_data_chunk();
0118  EC25F000  	CALL usb_send_d_00054

}
011C  0012      	RETURN


void usb_prime_ep0_out()

{
	bd0out.count = USB_EP0_OUT_SIZE;
048E  0E08      	MOVLW 0x08
0490  0102      	MOVLB 0x02
0492  6F01      	MOVWF gbl_bd0out+D'1', 1

	bd0out.addr = USB_EP0_OUT_ADDR;
0494  0E80      	MOVLW 0x80
0496  6F02      	MOVWF gbl_bd0out+D'2', 1
0498  0E02      	MOVLW 0x02
049A  6F03      	MOVWF gbl_bd0out+D'3', 1

	set_bit(bd0out.stat, DTS);		// turn on data togle sync TOGGLE
049C  8D00      	BSF gbl_bd0out,6, 1

	clear_bit(bd0out.stat, KEN);	// clear the keep bit
049E  9B00      	BCF gbl_bd0out,5, 1

	clear_bit(bd0out.stat, INCDIS);	// clear the increment disable
04A0  9900      	BCF gbl_bd0out,4, 1

	set_bit  (bd0out.stat, DTSEN);
04A2  8700      	BSF gbl_bd0out,3, 1

	clear_bit(bd0out.stat, BSTALL);	// clear stall bit
04A4  9500      	BCF gbl_bd0out,2, 1

	clear_bit(bd0out.stat, BC9);
04A6  9300      	BCF gbl_bd0out,1, 1

	clear_bit(bd0out.stat, BC8);
04A8  9100      	BCF gbl_bd0out,0, 1


	set_bit  (bd0out.stat, UOWN);	// SIE owns the buffer
04AA  8F00      	BSF gbl_bd0out,7, 1

}
04AC  0012      	RETURN


void usb_handle_standard_request(setup_data_packet sdp)

{
	switch (sdp.bRequest)

	{
		case req_Get_Descriptor:
04AE  0E06      	MOVLW 0x06
04B0  6378      	CPFSEQ usb_handle_00068_arg_sdp+D'1', 1
04B2  D001      	BRA	label37
04B4  D00F      	BRA	label41
04B6            label37
04D4            label41

			uns8 descriptor_type = sdp.wValue >> 8; 	// high byte is descriptor
04D4  517A      	MOVF usb_handle_00068_arg_sdp+D'3', W, 1
04D6  6F7F      	MOVWF usb_handle_00068_1_descrip_00069, 1

			uns8 descriptor_num  = sdp.wValue & 0xff; 	// low byte is particular descriptor
04D8  5179      	MOVF usb_handle_00068_arg_sdp+D'2', W, 1
04DA  6FA8      	MOVWF usb_handle_00068_1_descrip_0006A, 1


			usb_get_descriptor_callback(descriptor_type, descriptor_num, &delivery_ptr, &delivery_bytes_to_send);
04DC  517F      	MOVF usb_handle_00068_1_descrip_00069, W, 1
04DE  6FA9      	MOVWF usb_get_de_0005A_arg_descr_0005B, 1
04E0  51A8      	MOVF usb_handle_00068_1_descrip_0006A, W, 1
04E2  6FAA      	MOVWF usb_get_de_0005A_arg_descr_0005C, 1
04E4  0E02      	MOVLW HIGH(gbl_delivery_ptr+D'0')
04E6  6FAC      	MOVWF usb_get_de_0005A_arg_rtn_d_0005D+D'1', 1
04E8  0E42      	MOVLW LOW(gbl_delivery_ptr+D'0')
04EA  6FAB      	MOVWF usb_get_de_0005A_arg_rtn_d_0005D, 1
04EC  0E02      	MOVLW HIGH(gbl_delivery_bytes_to_send+D'0')
04EE  6FAE      	MOVWF usb_get_de_0005A_arg_rtn_d_0005E+D'1', 1
04F0  0E3C      	MOVLW LOW(gbl_delivery_bytes_to_send+D'0')
04F2  6FAD      	MOVWF usb_get_de_0005A_arg_rtn_d_0005E, 1
04F4  EC14F001  	CALL usb_get_de_0005A

			if (delivery_ptr != 0)
04F8  5342      	MOVF gbl_delivery_ptr, F, 1
04FA  E102      	BNZ	label42
04FC  5343      	MOVF gbl_delivery_ptr+D'1', F, 1
04FE  E016      	BZ	label43
0500            label42
052C            label43

			{	// we've got something
				control_mode = cm_CTRL_READ_DATA_STAGE;
0500  0E03      	MOVLW 0x03
0502  6F56      	MOVWF gbl_control_mode, 1

				delivery_bytes_max_send = sdp.wLength;	// maximum host wants
0504  517D      	MOVF usb_handle_00068_arg_sdp+D'6', W, 1
0506  6F3E      	MOVWF gbl_delivery_bytes_max_send, 1
0508  517E      	MOVF usb_handle_00068_arg_sdp+D'7', W, 1
050A  6F3F      	MOVWF gbl_delivery_bytes_max_send+D'1', 1

				delivery_bytes_sent = 0;				// clear our sent countr
050C  6B40      	CLRF gbl_delivery_bytes_sent, 1
050E  6B41      	CLRF gbl_delivery_bytes_sent+D'1', 1

				delivery_buffer_size = USB_EP0_IN_SIZE;
0510  0E08      	MOVLW 0x08
0512  6F5C      	MOVWF gbl_delivery_buffer_size, 1

				delivery_bd = &bd0in;
0514  0E02      	MOVLW HIGH(gbl_bd0in+D'0')
0516  6F47      	MOVWF gbl_delivery_bd+D'1', 1
0518  0E04      	MOVLW LOW(gbl_bd0in+D'0')
051A  6F46      	MOVWF gbl_delivery_bd, 1

				delivery_buffer = (uns8 *)USB_EP0_IN_ADDR;
051C  0E88      	MOVLW 0x88
051E  6F44      	MOVWF gbl_delivery_buffer, 1
0520  0E02      	MOVLW 0x02
0522  6F45      	MOVWF gbl_delivery_buffer+D'1', 1

				clear_bit(bd0in.stat, DTS);				// ready to get toggled
0524  9D04      	BCF gbl_bd0in,6, 1

				usb_send_data_chunk();
0526  EC25F000  	CALL usb_send_d_00054

			}
			else
			{
				usb_stall_ep0();
052C  EC6EF000  	CALL usb_stall__00055

			}

			break;
		case req_Set_Address:
04B6  0E05      	MOVLW 0x05
04B8  6378      	CPFSEQ usb_handle_00068_arg_sdp+D'1', 1
04BA  D001      	BRA	label38
04BC  D03A      	BRA	label44
04BE            label38
0532            label44

			usb_address = sdp.wValue & 0xff;
0532  5179      	MOVF usb_handle_00068_arg_sdp+D'2', W, 1
0534  6F55      	MOVWF gbl_usb_address, 1

			usb_status = us_SET_ADDRESS;
0536  0E01      	MOVLW 0x01
0538  6F5D      	MOVWF gbl_usb_status, 1


			// Send a status ack - when we confirm that, THEN change address
			usb_send_status_ack();
053A  EC8FF000  	CALL usb_send_e_00053

			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
053E  0E06      	MOVLW 0x06
0540  6F56      	MOVWF gbl_control_mode, 1

			break;
		case req_Set_Configuration:
04BE  0E09      	MOVLW 0x09
04C0  6378      	CPFSEQ usb_handle_00068_arg_sdp+D'1', 1
04C2  D001      	BRA	label39
04C4  D03F      	BRA	label45
04C6            label39
0544            label45

			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
0544  0E06      	MOVLW 0x06
0546  6F56      	MOVWF gbl_control_mode, 1

			usb_send_status_ack();
0548  EC8FF000  	CALL usb_send_e_00053

			usb_state = st_CONFIGURED;
054C  0E03      	MOVLW 0x03
054E  6F54      	MOVWF gbl_usb_state, 1

			// device is up - so now get the endpoints happy
			usb_configure_endpoints();
0550  EC7AF001  	CALL usb_config_00065

			// and do a call back to let the app know we're ready
			#ifdef USB_CALLBACK_ON_DEVICE_CONFIGURED
				usb_device_configured_callback();
0554  EC76F001  	CALL usb_device_00064

			#endif
			break;
		case req_Get_Interface:
04C6  0E0A      	MOVLW 0x0A
04C8  6378      	CPFSEQ usb_handle_00068_arg_sdp+D'1', 1
04CA  D001      	BRA	label40
04CC  D046      	BRA	label46
04CE            label40
055A            label46

				control_mode = cm_CTRL_READ_DATA_STAGE;
055A  0E03      	MOVLW 0x03
055C  6F56      	MOVWF gbl_control_mode, 1

				usb_send_one_byte(1);
055E  0E01      	MOVLW 0x01
0560  6FA9      	MOVWF usb_send_o_00066_arg_data, 1
0562  EC74F000  	CALL usb_send_o_00066

		case req_Get_Status:
04CE  5378      	MOVF usb_handle_00068_arg_sdp+D'1', F, 1
04D0  E04A      	BZ	label47
0566            label47

				#ifdef USB_SELF_POWERED
					usb_send_one_byte(1);
				#else
					usb_send_one_byte(0);	// bus powered
0566  6BA9      	CLRF usb_send_o_00066_arg_data, 1
0568  EC74F000  	CALL usb_send_o_00066

				#endif
				break;
		default:
04D2  D04D      	BRA	label48
056E            label48

			usb_stall_ep0();
056E  EC6EF000  	CALL usb_stall__00055

			break;

	}
}
052A  0012      	RETURN
0530  0012      	RETURN
0542  0012      	RETURN
0558  0012      	RETURN
056C  0012      	RETURN
0572  0012      	RETURN



void usb_handle_transaction()

{
	uns8 end_point, pid;
	end_point = ustat >> 3;
069E  3063      	RRCF gbl_ustat, W
06A0  0102      	MOVLB 0x02
06A2  6F75      	MOVWF usb_handle_0004D_1_end_point, 1
06A4  3375      	RRCF usb_handle_0004D_1_end_point, F, 1
06A6  3375      	RRCF usb_handle_0004D_1_end_point, F, 1
06A8  0E1F      	MOVLW 0x1F
06AA  1775      	ANDWF usb_handle_0004D_1_end_point, F, 1


	//read USTAT for endpoint information
	if (test_bit(ustat, DIR))
06AC  A463      	BTFSS gbl_ustat,2
06AE  D008      	BRA	label57
06C0            label57

	{
		pid = (bd0in.stat >> 2) & 0x0f;		// mask out pid
06B0  3104      	RRCF gbl_bd0in, W, 1
06B2  6F76      	MOVWF usb_handle_0004D_1_pid, 1
06B4  3376      	RRCF usb_handle_0004D_1_pid, F, 1
06B6  0E3F      	MOVLW 0x3F
06B8  1776      	ANDWF usb_handle_0004D_1_pid, F, 1
06BA  0E0F      	MOVLW 0x0F
06BC  1776      	ANDWF usb_handle_0004D_1_pid, F, 1

	}
	else
06BE  D008      	BRA	label58
06D0            label58

	{
		pid = (bd0out.stat >> 2) & 0x0f;	// mask out pid
06C0  3100      	RRCF gbl_bd0out, W, 1
06C2  6F77      	MOVWF CompTempVar2215, 1
06C4  3377      	RRCF CompTempVar2215, F, 1
06C6  0E3F      	MOVLW 0x3F
06C8  1777      	ANDWF CompTempVar2215, F, 1
06CA  0E0F      	MOVLW 0x0F
06CC  1577      	ANDWF CompTempVar2215, W, 1
06CE  6F76      	MOVWF usb_handle_0004D_1_pid, 1

	}

	if (end_point == 0)
06D0  5375      	MOVF usb_handle_0004D_1_end_point, F, 1
06D2  A4D8      	BTFSS STATUS,Z
06D4  D0B2      	BRA	label72
083A            label72

	{
		if (pid == pid_SETUP)
06D6  0E0D      	MOVLW 0x0D
06D8  6376      	CPFSEQ usb_handle_0004D_1_pid, 1
06DA  D05C      	BRA	label61
0794            label61

		{

			memcpy(/*dst*/ (void*)&usb_sdp, /*src*/ (void *)&buffer_0_out, 8);
06DC  0E01      	MOVLW HIGH(gbl_usb_sdp+D'0')
06DE  6F7E      	MOVWF memcpy8_00000_arg_dst+D'1', 1
06E0  0E9F      	MOVLW LOW(gbl_usb_sdp+D'0')
06E2  6F7D      	MOVWF memcpy8_00000_arg_dst, 1
06E4  0E02      	MOVLW HIGH(gbl_buffer_0_out+D'0')
06E6  6FA9      	MOVWF memcpy8_00000_arg_src+D'1', 1
06E8  0E80      	MOVLW LOW(gbl_buffer_0_out+D'0')
06EA  6FA8      	MOVWF memcpy8_00000_arg_src, 1
06EC  0E08      	MOVLW 0x08
06EE  6F7F      	MOVWF memcpy8_00000_arg_len, 1
06F0  EC25F002  	CALL memcpy8_00000


			usb_prime_ep0_out();
06F4  EC47F002  	CALL usb_prime__00067


			if (!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE1) && // std request
06F8  0101      	MOVLB 0x01
06FA  BD9F      	BTFSC gbl_usb_sdp,6, 1
06FC  D024      	BRA	label59
0746            label59

				!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE0)) {
06FE  BB9F      	BTFSC gbl_usb_sdp,5, 1
0700  D022      	BRA	label59


				usb_handle_standard_request(usb_sdp);
0702  51A6      	MOVF gbl_usb_sdp+D'7', W, 1
0704  0102      	MOVLB 0x02
0706  6F7E      	MOVWF usb_handle_00068_arg_sdp+D'7', 1
0708  0101      	MOVLB 0x01
070A  51A5      	MOVF gbl_usb_sdp+D'6', W, 1
070C  0102      	MOVLB 0x02
070E  6F7D      	MOVWF usb_handle_00068_arg_sdp+D'6', 1
0710  0101      	MOVLB 0x01
0712  51A4      	MOVF gbl_usb_sdp+D'5', W, 1
0714  0102      	MOVLB 0x02
0716  6F7C      	MOVWF usb_handle_00068_arg_sdp+D'5', 1
0718  0101      	MOVLB 0x01
071A  51A3      	MOVF gbl_usb_sdp+D'4', W, 1
071C  0102      	MOVLB 0x02
071E  6F7B      	MOVWF usb_handle_00068_arg_sdp+D'4', 1
0720  0101      	MOVLB 0x01
0722  51A2      	MOVF gbl_usb_sdp+D'3', W, 1
0724  0102      	MOVLB 0x02
0726  6F7A      	MOVWF usb_handle_00068_arg_sdp+D'3', 1
0728  0101      	MOVLB 0x01
072A  51A1      	MOVF gbl_usb_sdp+D'2', W, 1
072C  0102      	MOVLB 0x02
072E  6F79      	MOVWF usb_handle_00068_arg_sdp+D'2', 1
0730  0101      	MOVLB 0x01
0732  51A0      	MOVF gbl_usb_sdp+D'1', W, 1
0734  0102      	MOVLB 0x02
0736  6F78      	MOVWF usb_handle_00068_arg_sdp+D'1', 1
0738  0101      	MOVLB 0x01
073A  519F      	MOVF gbl_usb_sdp, W, 1
073C  0102      	MOVLB 0x02
073E  6F77      	MOVWF usb_handle_00068_arg_sdp, 1
0740  EC57F002  	CALL usb_handle_00068

			}
			else if (!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE1) && // class request
0744  D025      	BRA	label60
0746  BD9F      	BTFSC gbl_usb_sdp,6, 1
0748  D023      	BRA	label60
0790            label60

				test_bit(usb_sdp.bmRequestType, REQUEST_TYPE0)) {
074A  AB9F      	BTFSS gbl_usb_sdp,5, 1
074C  D021      	BRA	label60


				#ifdef USB_CALLBACK_ON_CTRL_CLASS
					usb_handle_class_request(usb_sdp);
074E  51A6      	MOVF gbl_usb_sdp+D'7', W, 1
0750  0102      	MOVLB 0x02
0752  6F7E      	MOVWF usb_handle_00059_arg_sdp+D'7', 1
0754  0101      	MOVLB 0x01
0756  51A5      	MOVF gbl_usb_sdp+D'6', W, 1
0758  0102      	MOVLB 0x02
075A  6F7D      	MOVWF usb_handle_00059_arg_sdp+D'6', 1
075C  0101      	MOVLB 0x01
075E  51A4      	MOVF gbl_usb_sdp+D'5', W, 1
0760  0102      	MOVLB 0x02
0762  6F7C      	MOVWF usb_handle_00059_arg_sdp+D'5', 1
0764  0101      	MOVLB 0x01
0766  51A3      	MOVF gbl_usb_sdp+D'4', W, 1
0768  0102      	MOVLB 0x02
076A  6F7B      	MOVWF usb_handle_00059_arg_sdp+D'4', 1
076C  0101      	MOVLB 0x01
076E  51A2      	MOVF gbl_usb_sdp+D'3', W, 1
0770  0102      	MOVLB 0x02
0772  6F7A      	MOVWF usb_handle_00059_arg_sdp+D'3', 1
0774  0101      	MOVLB 0x01
0776  51A1      	MOVF gbl_usb_sdp+D'2', W, 1
0778  0102      	MOVLB 0x02
077A  6F79      	MOVWF usb_handle_00059_arg_sdp+D'2', 1
077C  0101      	MOVLB 0x01
077E  51A0      	MOVF gbl_usb_sdp+D'1', W, 1
0780  0102      	MOVLB 0x02
0782  6F78      	MOVWF usb_handle_00059_arg_sdp+D'1', 1
0784  0101      	MOVLB 0x01
0786  519F      	MOVF gbl_usb_sdp, W, 1
0788  0102      	MOVLB 0x02
078A  6F77      	MOVWF usb_handle_00059_arg_sdp, 1
078C  ECBAF002  	CALL usb_handle_00059

				#endif
			}

			clear_bit(ucon, PKTDIS);
0790  9864      	BCF gbl_ucon,4


		}
		else if (pid == pid_IN)
0794  0E09      	MOVLW 0x09
0796  6376      	CPFSEQ usb_handle_0004D_1_pid, 1
0798  D020      	BRA	label65
07DA            label65

		{
			if (control_mode == cm_CTRL_READ_DATA_STAGE)
079A  0E03      	MOVLW 0x03
079C  6356      	CPFSEQ gbl_control_mode, 1
079E  D003      	BRA	label62
07A6            label62

			{
				// it's ours, so send next chunk
				usb_send_data_chunk();
07A0  EC25F000  	CALL usb_send_d_00054

			}
			else if (control_mode == cm_CTRL_WRITE_SENDING_STATUS)
07A6  0E06      	MOVLW 0x06
07A8  6356      	CPFSEQ gbl_control_mode, 1
07AA  D00C      	BRA	label63
07C4            label63

			{
				control_mode = cm_IDLE;
07AC  6B56      	CLRF gbl_control_mode, 1

				if (usb_status == us_SET_ADDRESS)
07AE  055D      	DECF gbl_usb_status, W, 1
07B0  A4D8      	BTFSS STATUS,Z

				{
					usb_state = st_ADDRESS;
07B4  0E02      	MOVLW 0x02
07B6  6F54      	MOVWF gbl_usb_state, 1

					uaddr = usb_address;
07B8  5155      	MOVF gbl_usb_address, W, 1
07BA  010F      	MOVLB 0x0F
07BC  6F5C      	MOVWF gbl_uaddr, 1

					usb_status = us_IDLE;
07BE  0102      	MOVLB 0x02
07C0  6B5D      	CLRF gbl_usb_status, 1

				}
			}
			else if (control_mode == cm_CTRL_READ_AWAITING_STATUS)
07C4  0E05      	MOVLW 0x05
07C6  6356      	CPFSEQ gbl_control_mode, 1
07C8  D002      	BRA	label64
07CE            label64

			{
				// Must have been last IN of the read, so still waiting for status
				nop(); // boostc bug
07CA  0000      	NOP

			}
			else if (control_mode == cm_CTRL_READ_DATA_STAGE_CLASS)
07CE  0E04      	MOVLW 0x04
07D0  6356      	CPFSEQ gbl_control_mode, 1

			{
				// Must be more to come
				#ifdef USB_CALLBACK_ON_CTRL_CLASS
					usb_handle_ctrl_read_class();
07D4  ECF5F002  	CALL usb_handle_00057

				#else
					nop(); // otherwise boostc bug
				#endif
			}
		}
		else if (pid == pid_ACK)
07DA  0E02      	MOVLW 0x02
07DC  6376      	CPFSEQ usb_handle_0004D_1_pid, 1
07DE  D011      	BRA	label68
0802            label68

		{
			if (control_mode == cm_CTRL_READ_DATA_STAGE)
07E0  0E03      	MOVLW 0x03
07E2  6356      	CPFSEQ gbl_control_mode, 1
07E4  D003      	BRA	label66
07EC            label66

			{
				usb_send_data_chunk();
07E6  EC25F000  	CALL usb_send_d_00054

			}
			else if (control_mode == cm_CTRL_READ_DATA_STAGE_CLASS)
07EC  0E04      	MOVLW 0x04
07EE  6356      	CPFSEQ gbl_control_mode, 1
07F0  D003      	BRA	label67
07F8            label67

			{
				#ifdef USB_CALLBACK_ON_CTRL_CLASS
					usb_handle_ctrl_read_class();
07F2  ECF5F002  	CALL usb_handle_00057

				#else
					nop(); // boostc bug
				#endif
			}
			else if (control_mode == cm_CTRL_WRITE_SENDING_STATUS)
07F8  0E06      	MOVLW 0x06
07FA  6356      	CPFSEQ gbl_control_mode, 1

			{
				control_mode = cm_IDLE;
07FE  6B56      	CLRF gbl_control_mode, 1

			}

		}
		else if (pid == pid_OUT)
0802  0576      	DECF usb_handle_0004D_1_pid, W, 1
0804  A4D8      	BTFSS STATUS,Z

		{
			// We've done an out

			if (control_mode == cm_CTRL_READ_AWAITING_STATUS)
0808  0E05      	MOVLW 0x05
080A  6356      	CPFSEQ gbl_control_mode, 1
080C  D002      	BRA	label69
0812            label69

			{
				control_mode = cm_IDLE;
080E  6B56      	CLRF gbl_control_mode, 1

			}
			else if (control_mode == cm_CTRL_WRITE_DATA_STAGE_CLASS)
0810  D011      	BRA	label71
0812  0E02      	MOVLW 0x02
0814  6356      	CPFSEQ gbl_control_mode, 1
0816  D00A      	BRA	label70
082C            label70

			{
				#ifdef USB_CALLBACK_ON_CTRL_CLASS
					usb_handle_ctrl_write_class((uns8 *)&buffer_0_out, bd0out.count);
0818  0E02      	MOVLW HIGH(gbl_buffer_0_out+D'0')
081A  6F78      	MOVWF usb_handle_00058_arg_data+D'1', 1
081C  0E80      	MOVLW LOW(gbl_buffer_0_out+D'0')
081E  6F77      	MOVWF usb_handle_00058_arg_data, 1
0820  5101      	MOVF gbl_bd0out+D'1', W, 1
0822  6F79      	MOVWF usb_handle_00058_arg_count, 1
0824  6B7A      	CLRF usb_handle_00058_arg_count+D'1', 1
0826  ECDBF002  	CALL usb_handle_00058

					// !! should include bc bits here for total count
				#else
					nop();
				#endif
			}
			else if (control_mode == cm_CTRL_READ_DATA_STAGE)
082A  D004      	BRA	label71
082C  0E03      	MOVLW 0x03
082E  6356      	CPFSEQ gbl_control_mode, 1
0830  D001      	BRA	label71
0834            label71

			{
				control_mode = cm_IDLE;
0832  6B56      	CLRF gbl_control_mode, 1

			}
			usb_prime_ep0_out();
0834  EC47F002  	CALL usb_prime__00067

		}

	}
	else
	{
		buffer_descriptor *bd;
		if (test_bit(ustat, DIR))
083A  A463      	BTFSS gbl_ustat,2
083C  D01A      	BRA	label73
0872            label73

		{
			// in
			#ifdef USB_EP_DATA_CALLBACK
				bd = ep_in_bd_location[end_point];
083E  0101      	MOVLB 0x01
0840  EE01F0A7  	LFSR 0x00, gbl_ep_in_bd_location
0844  50E9      	MOVF FSR0L, W
0846  0102      	MOVLB 0x02
0848  5175      	MOVF usb_handle_0004D_1_end_point, W, 1
084A  6F79      	MOVWF CompTempVar2224, 1
084C  90D8      	BCF STATUS,C
084E  3579      	RLCF CompTempVar2224, W, 1
0850  26E9      	ADDWF FSR0L, F
0852  50EE      	MOVF POSTINC0, W
0854  6F77      	MOVWF usb_handle_0004D_64_bd, 1
0856  50EF      	MOVF INDF0, W
0858  6F78      	MOVWF usb_handle_0004D_64_bd+D'1', 1

				usb_ep_data_in_callback(end_point, bd->count);
085A  5175      	MOVF usb_handle_0004D_1_end_point, W, 1
085C  6F79      	MOVWF usb_ep_dat_00062_arg_end_point, 1
085E  5178      	MOVF usb_handle_0004D_64_bd+D'1', W, 1
0860  6EEA      	MOVWF FSR0H
0862  5177      	MOVF usb_handle_0004D_64_bd, W, 1
0864  6EE9      	MOVWF FSR0L
0866  50EC      	MOVF PREINC0, W
0868  6F7A      	MOVWF usb_ep_dat_00062_arg_byte_count, 1
086A  6B7B      	CLRF usb_ep_dat_00062_arg_byte_count+D'1', 1
086C  ECFDF002  	CALL usb_ep_dat_00062

			#else
				nop();
			#endif
		}
		else
		{
			// out
			bd = ep_out_bd_location[end_point];
0872  0101      	MOVLB 0x01
0874  EE01F0AF  	LFSR 0x00, gbl_ep_out_bd_location
0878  50E9      	MOVF FSR0L, W
087A  0102      	MOVLB 0x02
087C  5175      	MOVF usb_handle_0004D_1_end_point, W, 1
087E  6F79      	MOVWF CompTempVar2227, 1
0880  90D8      	BCF STATUS,C
0882  3579      	RLCF CompTempVar2227, W, 1
0884  26E9      	ADDWF FSR0L, F
0886  50EE      	MOVF POSTINC0, W
0888  6F77      	MOVWF usb_handle_0004D_64_bd, 1
088A  50EF      	MOVF INDF0, W
088C  6F78      	MOVWF usb_handle_0004D_64_bd+D'1', 1

			// issue callback
			#ifdef USB_EP_DATA_CALLBACK
				usb_ep_data_out_callback(end_point, ep_out_buffer_location[end_point],
088E  5175      	MOVF usb_handle_0004D_1_end_point, W, 1
0890  6F79      	MOVWF usb_ep_dat_00061_arg_end_point, 1
0892  0101      	MOVLB 0x01
0894  EE01F0BF  	LFSR 0x00, gbl_ep_out_buffer_location
0898  50E9      	MOVF FSR0L, W
089A  0102      	MOVLB 0x02
089C  5175      	MOVF usb_handle_0004D_1_end_point, W, 1
089E  6F7E      	MOVWF CompTempVar2234, 1
08A0  90D8      	BCF STATUS,C
08A2  357E      	RLCF CompTempVar2234, W, 1
08A4  26E9      	ADDWF FSR0L, F
08A6  50EE      	MOVF POSTINC0, W
08A8  6F7A      	MOVWF usb_ep_dat_00061_arg_buffer, 1
08AA  50EF      	MOVF INDF0, W
08AC  6F7B      	MOVWF usb_ep_dat_00061_arg_buffer+D'1', 1
08B6  50EC      	MOVF PREINC0, W
08B8  6F7C      	MOVWF usb_ep_dat_00061_arg_byte_count, 1
08BA  6B7D      	CLRF usb_ep_dat_00061_arg_byte_count+D'1', 1
08BC  EC00F003  	CALL usb_ep_dat_00061

									bd->count);
08AE  5178      	MOVF usb_handle_0004D_64_bd+D'1', W, 1
08B0  6EEA      	MOVWF FSR0H
08B2  5177      	MOVF usb_handle_0004D_64_bd, W, 1
08B4  6EE9      	MOVWF FSR0L

			#endif
			// re-prime endpoint
			bd->count = ep_out_buffer_size[end_point];
08C0  0101      	MOVLB 0x01
08C2  EE01F0CF  	LFSR 0x00, gbl_ep_out_buffer_size
08C6  50E9      	MOVF FSR0L, W
08C8  0102      	MOVLB 0x02
08CA  5175      	MOVF usb_handle_0004D_1_end_point, W, 1
08CC  6F79      	MOVWF CompTempVar2237, 1
08CE  90D8      	BCF STATUS,C
08D0  3779      	RLCF CompTempVar2237, F, 1
08D2  5179      	MOVF CompTempVar2237, W, 1
08D4  26E9      	ADDWF FSR0L, F
08D6  50EE      	MOVF POSTINC0, W
08D8  6F7A      	MOVWF CompTempVar2239, 1
08DA  50EF      	MOVF INDF0, W
08DC  6F7B      	MOVWF CompTempVar2239+D'1', 1
08DE  5178      	MOVF usb_handle_0004D_64_bd+D'1', W, 1
08E0  6EEA      	MOVWF FSR0H
08E2  2977      	INCF usb_handle_0004D_64_bd, W, 1
08E4  6EE9      	MOVWF FSR0L
08E6  517A      	MOVF CompTempVar2239, W, 1
08E8  6EEF      	MOVWF INDF0


			// Address shouldn't change, so don't need to update it

			clear_bit(bd->stat, DTS);		// turn on data togle sync TOGGLE
08EA  06E9      	DECF FSR0L, F
08EC  9CEF      	BCF INDF0,6

			clear_bit(bd->stat, KEN);		// clear the keep bit
08EE  9AEF      	BCF INDF0,5

			clear_bit(bd->stat, INCDIS);	// clear the increment disable
08F0  98EF      	BCF INDF0,4

			clear_bit(bd->stat, DTSEN);
08F2  96EF      	BCF INDF0,3

			clear_bit(bd->stat, BSTALL);	// clear stall bit
08F4  94EF      	BCF INDF0,2

			clear_bit(bd->stat, BC9);
08F6  92EF      	BCF INDF0,1

			clear_bit(bd->stat, BC8);
08F8  90EF      	BCF INDF0,0

			set_bit  (bd->stat, UOWN);		// SIE owns the buffer
08FA  8EEF      	BSF INDF0,7

		}
	}
}
0792  0012      	RETURN
07A4  0012      	RETURN
07B2  0012      	RETURN
07C2  0012      	RETURN
07CC  0012      	RETURN
07D2  0012      	RETURN
07D8  0012      	RETURN
07EA  0012      	RETURN
07F6  0012      	RETURN
07FC  0012      	RETURN
0800  0012      	RETURN
0806  0012      	RETURN
0838  0012      	RETURN
0870  0012      	RETURN
08FC  0012      	RETURN



void usb_handle_reset()

{
	usb_address = 0;
0656  0102      	MOVLB 0x02
0658  6B55      	CLRF gbl_usb_address, 1

	//uaddr = 0;

	control_mode = cm_IDLE;
065A  6B56      	CLRF gbl_control_mode, 1

	usb_status   = us_IDLE;
065C  6B5D      	CLRF gbl_usb_status, 1


	// clear fifo
	clear_bit(uir, TRNIF);
065E  9662      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
0660  9662      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
0662  9662      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
0664  9662      	BCF gbl_uir,3


	// init buffers

	// EP0 OUT
	bd0out.count = USB_EP0_OUT_SIZE;	// 8 byte buffer
0666  0E08      	MOVLW 0x08
0668  6F01      	MOVWF gbl_bd0out+D'1', 1

	bd0out.addr = USB_EP0_OUT_ADDR;
066A  0E80      	MOVLW 0x80
066C  6F02      	MOVWF gbl_bd0out+D'2', 1
066E  0E02      	MOVLW 0x02
0670  6F03      	MOVWF gbl_bd0out+D'3', 1


	clear_bit(bd0out.stat, DTS);	// turn on data togle sync TOGGLE
0672  9D00      	BCF gbl_bd0out,6, 1

	clear_bit(bd0out.stat, KEN);	// clear the keep bit
0674  9B00      	BCF gbl_bd0out,5, 1

	clear_bit(bd0out.stat, INCDIS);	// clear the increment disable
0676  9900      	BCF gbl_bd0out,4, 1

	clear_bit  (bd0out.stat, DTSEN);	// !!!!!!
0678  9700      	BCF gbl_bd0out,3, 1

	clear_bit(bd0out.stat, BSTALL);	// clear stall bit
067A  9500      	BCF gbl_bd0out,2, 1

	clear_bit(bd0out.stat, BC9);
067C  9300      	BCF gbl_bd0out,1, 1

	clear_bit(bd0out.stat, BC8);
067E  9100      	BCF gbl_bd0out,0, 1


	set_bit  (bd0out.stat, UOWN);	// SIE owns the buffer
0680  8F00      	BSF gbl_bd0out,7, 1

								// since we expect frist transaction to be SETUP
	// EP0 IN
	bd0in.count = USB_EP0_IN_SIZE;	// 8 byte buffer
0682  0E08      	MOVLW 0x08
0684  6F05      	MOVWF gbl_bd0in+D'1', 1

	bd0in.addr = USB_EP0_IN_ADDR;
0686  0E88      	MOVLW 0x88
0688  6F06      	MOVWF gbl_bd0in+D'2', 1
068A  0E02      	MOVLW 0x02
068C  6F07      	MOVWF gbl_bd0in+D'3', 1

	clear_bit(bd0in.stat, DTS);	// turn on data togle sync TOGGLE
068E  9D04      	BCF gbl_bd0in,6, 1

	clear_bit(bd0in.stat, KEN);	// clear the keep bit
0690  9B04      	BCF gbl_bd0in,5, 1

	clear_bit(bd0in.stat, INCDIS);	// clear the increment disable
0692  9904      	BCF gbl_bd0in,4, 1

	clear_bit(bd0in.stat, BSTALL);	// clear stall bit
0694  9504      	BCF gbl_bd0in,2, 1

	clear_bit(bd0in.stat, BC9);
0696  9304      	BCF gbl_bd0in,1, 1

	clear_bit(bd0in.stat, BC8);
0698  9104      	BCF gbl_bd0in,0, 1


	clear_bit(bd0in.stat, UOWN);	// uC owns the buffer
069A  9F04      	BCF gbl_bd0in,7, 1

}
069C  0012      	RETURN



void usb_handle_stall()

{
}
0654  0012      	RETURN



void usb_handle_isr()

{
	if (test_bit(pir2, USBIF))			//USB Interrupt?
0904  A4A1      	BTFSS gbl_pir2,2

	{
		clear_bit(pir2, USBIF);			//Clear USB Interrupt
0908  94A1      	BCF gbl_pir2,2


		if (test_bit(uir, IDLEIF))		//USB Idle Interrupt?
090A  B862      	BTFSC gbl_uir,4

		{
			clear_bit(uir, IDLEIF);		//Clear Idle
090C  9862      	BCF gbl_uir,4

		}

		if (test_bit(uir, TRNIF))		//USB Transaction detected?
090E  A662      	BTFSS gbl_uir,3
0910  D003      	BRA	label74
0918            label74

		{
			usb_handle_transaction();	//Handle the transaction
0912  EC4FF003  	CALL usb_handle_0004D

			clear_bit(uir, TRNIF);		//Clear the interrupt
0916  9662      	BCF gbl_uir,3

		}

		if (test_bit(uir, URSTIF))		//USB Reset detected?
0918  A062      	BTFSS gbl_uir,0
091A  D003      	BRA	label75
0922            label75

		{
			usb_handle_reset();			//Deal with the reset
091C  EC2BF003  	CALL usb_handle_0004E

			clear_bit(uir, URSTIF);		//Clear the interrupt
0920  9062      	BCF gbl_uir,0

		}

		if (test_bit(uir, STALLIF))		//USB Stall detected?
0922  AA62      	BTFSS gbl_uir,5
0924  D003      	BRA	label76
092C            label76

		{
			usb_handle_stall();			//Handle the stall
0926  EC2AF003  	CALL usb_handle_0004F

			clear_bit(uir, STALLIF);	//Clear the interrupt
092A  9A62      	BCF gbl_uir,5

		}
		if (test_bit(uir, SOFIF))		//USB Start of frame detected?
092C  AC62      	BTFSS gbl_uir,6

		{
			#ifdef USB_CALLBACK_ON_SOF
				usb_SOF_callback(ufrml);	// sourceboost defines this
0930  010F      	MOVLB 0x0F
0932  515D      	MOVF gbl_ufrml, W, 1
0934  0102      	MOVLB 0x02
0936  6F75      	MOVWF usb_SOF_ca_00050_arg_frame, 1
0938  6B76      	CLRF usb_SOF_ca_00050_arg_frame+D'1', 1
093A  EC7FF004  	CALL usb_SOF_ca_00050

			#endif
			clear_bit(uir, SOFIF);		//Clear the interrupt
093E  9C62      	BCF gbl_uir,6

		}
	}
}
0906  0012      	RETURN
092E  0012      	RETURN
0940  0012      	RETURN



void usb_setup()

{
	usb_state = st_POWERED;
0942  0102      	MOVLB 0x02
0944  6B54      	CLRF gbl_usb_state, 1


	// init hardware
	clear_bit(ucfg, 3);	// enable internal tranceiver   -- BR Modded from UTRDIS to 3 for K50 devices
0946  9661      	BCF gbl_ucfg,3

	set_bit(ucfg, FSEN);	// clear for low speed, set for high speed
0948  8461      	BSF gbl_ucfg,2

	set_bit  (ucfg, UPUEN);	// enable on-chip pull-ups
094A  8861      	BSF gbl_ucfg,4


	clear_bit(ucfg, PPB1);	// disable double buffering for now
094C  9261      	BCF gbl_ucfg,1

	clear_bit(ucfg, PPB0);
094E  9061      	BCF gbl_ucfg,0


	// Config buffer descriptor table
	ep_in_bd_location[0] = &bd0in;
0950  0E02      	MOVLW HIGH(gbl_bd0in+D'0')
0952  0101      	MOVLB 0x01
0954  6FA8      	MOVWF gbl_ep_in_bd_location+D'1', 1
0956  0E04      	MOVLW LOW(gbl_bd0in+D'0')
0958  6FA7      	MOVWF gbl_ep_in_bd_location, 1

	#if USB_HIGHEST_EP >= 1
		ep_in_bd_location[1] = &bd1in;
095A  0E02      	MOVLW HIGH(gbl_bd1in+D'0')
095C  6FAA      	MOVWF gbl_ep_in_bd_location+D'3', 1
095E  0E0C      	MOVLW LOW(gbl_bd1in+D'0')
0960  6FA9      	MOVWF gbl_ep_in_bd_location+D'2', 1

	#endif
	#if USB_HIGHEST_EP >= 2
		ep_in_bd_location[2] = &bd2in;
0962  0E02      	MOVLW HIGH(gbl_bd2in+D'0')
0964  6FAC      	MOVWF gbl_ep_in_bd_location+D'5', 1
0966  0E14      	MOVLW LOW(gbl_bd2in+D'0')
0968  6FAB      	MOVWF gbl_ep_in_bd_location+D'4', 1

	#endif
	#if USB_HIGHEST_EP >= 3
		ep_in_bd_location[3] = &bd3in;
096A  0E02      	MOVLW HIGH(gbl_bd3in+D'0')
096C  6FAE      	MOVWF gbl_ep_in_bd_location+D'7', 1
096E  0E1C      	MOVLW LOW(gbl_bd3in+D'0')
0970  6FAD      	MOVWF gbl_ep_in_bd_location+D'6', 1

	#endif
	#if USB_HIGHEST_EP >= 4
		ep_in_bd_location[4] = &bd4in;
	#endif

	ep_out_bd_location[0] = &bd0out;
0972  0E02      	MOVLW HIGH(gbl_bd0out+D'0')
0974  6FB0      	MOVWF gbl_ep_out_bd_location+D'1', 1
0976  0E00      	MOVLW LOW(gbl_bd0out+D'0')
0978  6FAF      	MOVWF gbl_ep_out_bd_location, 1

	#if USB_HIGHEST_EP >= 1
		ep_out_bd_location[1] = &bd1out;
097A  0E02      	MOVLW HIGH(gbl_bd1out+D'0')
097C  6FB2      	MOVWF gbl_ep_out_bd_location+D'3', 1
097E  0E08      	MOVLW LOW(gbl_bd1out+D'0')
0980  6FB1      	MOVWF gbl_ep_out_bd_location+D'2', 1

	#endif
	#if USB_HIGHEST_EP >= 2
		ep_out_bd_location[2] = &bd2out;
0982  0E02      	MOVLW HIGH(gbl_bd2out+D'0')
0984  6FB4      	MOVWF gbl_ep_out_bd_location+D'5', 1
0986  0E10      	MOVLW LOW(gbl_bd2out+D'0')
0988  6FB3      	MOVWF gbl_ep_out_bd_location+D'4', 1

	#endif
	#if USB_HIGHEST_EP >= 3
		ep_out_bd_location[3] = &bd3out;
098A  0E02      	MOVLW HIGH(gbl_bd3out+D'0')
098C  6FB6      	MOVWF gbl_ep_out_bd_location+D'7', 1
098E  0E18      	MOVLW LOW(gbl_bd3out+D'0')
0990  6FB5      	MOVWF gbl_ep_out_bd_location+D'6', 1

	#endif
	#if USB_HIGHEST_EP >= 4
		ep_out_bd_location[4] = &bd4out;
	#endif

	// init endpoints
	set_bit(uep0,   EPHSHK);	// EP0 handshaking on
0992  010F      	MOVLB 0x0F
0994  8953      	BSF gbl_uep0,4, 1

	set_bit(uep0,   EPOUTEN);	// EP0 OUT enable
0996  8553      	BSF gbl_uep0,2, 1

	set_bit(uep0,   EPINEN); 	// EP0 IN enable
0998  8353      	BSF gbl_uep0,1, 1

	clear_bit(uep0, EPCONDIS);	// EP0 control transfers on (and IN and OUT)
099A  9753      	BCF gbl_uep0,3, 1


	// init interrupts
	set_bit(uie,  STALLIE);		// interrupt on stall
099C  8A60      	BSF gbl_uie,5

	set_bit(uie,  TRNIE);		// on transaction complete
099E  8660      	BSF gbl_uie,3

	set_bit(uie,  URSTIE);		// on reset
09A0  8060      	BSF gbl_uie,0

	set_bit(pie2, USBIE);		// general USB interrupts
09A2  84A0      	BSF gbl_pie2,2

	#ifdef USB_CALLBACK_ON_SOF
		set_bit(uie, SOFIE);
09A4  8C60      	BSF gbl_uie,6

	#endif

}
09A6  0012      	RETURN


void usb_enable_module()

{
	// enable usb module
	uir = 0;
0A90  6A62      	CLRF gbl_uir

	set_bit(ucon, USBEN);		// enable USB serial interface engine (SIE)
0A92  8664      	BSF gbl_ucon,3

	usb_state = st_DEFAULT;
0A94  0E01      	MOVLW 0x01
0A96  0102      	MOVLB 0x02
0A98  6F54      	MOVWF gbl_usb_state, 1

}
0A9A  0012      	RETURN



usb_state_type usb_get_state()
{
	return usb_state;
}
}
/*********************************************************************
 *                    Flowcode USB Component Code
 *
 * File: usb_cdc_class.c
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 031008 | BR | Created
 * 190711 | BR | Confirmed current version
 ********************************************************************/

// USB includes
#include "pic_usb.h"
#include "pic_usb_buffer_mgt.h"

// local includes
#include "usb_cdc_class.h"

// system includes
#include <memory.h>

// class definitions

#define req_SEND_ENCAPSULATED_COMMAND	0x00
#define req_GET_ENCAPSULATED_RESPONSE	0x01
#define	req_SET_COMM_FEATURE			0x02
#define req_GET_COMM_FEATURE			0x03
#define req_CLEAR_COMM_FEATURE			0x04
#define req_SET_LINE_CODING				0x20
#define req_GET_LINE_CODING				0x21
#define req_SET_CONTROL_LINE_STATE		0x22
#define req_SEND_BREAK					0x23

typedef  union _long_union{
		long as_long;
		uns8 as_byte_array[4];
} long_union;


typedef struct _line_coding {
	long_union	dte_rate;
	uns8	stop_bits;	// 0=1 stop bit, 1=1.5 stop bits, 2=2 stop bits
	uns8	parity;		// 0=None, 1=Odd, 2=Even, 3=Mark, 4=Space
	uns8	data_bits;	// 5,6,7,8 or 16 bits
}	line_coding;

/** Transmit fifo  */
uns8 cdc_tx_buffer[CDC_TX_BUFFER_SIZE];
/** Transmit fifo start point */
uns8 cdc_tx_start=0;
11FA  6B5F      	CLRF gbl_cdc_tx_start, 1

/** Transmit fifo end point */
uns8 cdc_tx_end=0;
11FC  6B60      	CLRF gbl_cdc_tx_end, 1


/** Receive fifo */
uns8 cdc_rx_buffer[CDC_RX_BUFFER_SIZE];
/** Receive fifo start point */
uns8 cdc_rx_start = 0;
11FE  6B61      	CLRF gbl_cdc_rx_start, 1

/** Receive fifo end point */
uns8 cdc_rx_end = 0;
1200  6B62      	CLRF gbl_cdc_rx_end, 1



uns8 class_data[8];	// we'll dump all our class data in here

void usb_handle_class_request(setup_data_packet sdp) {


	switch (sdp.bRequest) {

		case req_SET_LINE_CODING:
0574  0E20      	MOVLW 0x20
0576  6378      	CPFSEQ usb_handle_00059_arg_sdp+D'1', 1
0578  D001      	BRA	label49
057A  D008      	BRA	label51
057C            label49
058C            label51

			// we now expect the line coding to arrive in the data stage
			control_mode = cm_CTRL_WRITE_DATA_STAGE_CLASS;
058C  0E02      	MOVLW 0x02
058E  6F56      	MOVWF gbl_control_mode, 1

			break;
		case req_GET_LINE_CODING:
057C  0E21      	MOVLW 0x21
057E  6378      	CPFSEQ usb_handle_00059_arg_sdp+D'1', 1
0580  D001      	BRA	label50
0582  D007      	BRA	label52
0584            label50
0592            label52

			control_mode = cm_CTRL_READ_DATA_STAGE_CLASS;
0592  0E04      	MOVLW 0x04
0594  6F56      	MOVWF gbl_control_mode, 1

			//  need to prime ep0 IN with some funky data here
			usb_send_data(/*ep*/ 0, /*data*/ &class_data, /*count*/ 8, /*first*/ 1);
0596  6B7F      	CLRF usb_send_d_00052_arg_ep, 1
0598  0E01      	MOVLW HIGH(gbl_class_data+D'0')
059A  6FA9      	MOVWF usb_send_d_00052_arg_data+D'1', 1
059C  0ED7      	MOVLW LOW(gbl_class_data+D'0')
059E  6FA8      	MOVWF usb_send_d_00052_arg_data, 1
05A0  0E08      	MOVLW 0x08
05A2  6FAA      	MOVWF usb_send_d_00052_arg_send_count, 1
05A4  81AB      	BSF usb_send_d_00052_arg_first,0, 1
05A6  ECA6F000  	CALL usb_send_d_00052

			// actually we know this will be the last packet, so go straight to waiting for the status ack
			break;
		case req_SET_CONTROL_LINE_STATE:
0584  0E22      	MOVLW 0x22
0586  6378      	CPFSEQ usb_handle_00059_arg_sdp+D'1', 1
058A  D010      	BRA	label53
05AC            label53

			// no data, so just ack the status
			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
05AC  0E06      	MOVLW 0x06
05AE  6F56      	MOVWF gbl_control_mode, 1

			usb_send_status_ack();
05B0  EC8FF000  	CALL usb_send_e_00053

			break;
		default:
	}
}
0588  0012      	RETURN
0590  0012      	RETURN
05AA  0012      	RETURN
05B4  0012      	RETURN


void usb_handle_ctrl_write_class(uns8 *data, uns16 count) {


	switch (usb_sdp.bRequest) {

		case req_SET_LINE_CODING:
05B6  0E20      	MOVLW 0x20
05B8  0101      	MOVLB 0x01
05BA  63A0      	CPFSEQ gbl_usb_sdp+D'1', 1

			// dump it into class_data
			memcpy(/* dst */ (void *)&class_data,/* src */ (void *)data, count);
05BE  0E01      	MOVLW HIGH(gbl_class_data+D'0')
05C0  0102      	MOVLB 0x02
05C2  6F7E      	MOVWF memcpy8_00000_arg_dst+D'1', 1
05C4  0ED7      	MOVLW LOW(gbl_class_data+D'0')
05C6  6F7D      	MOVWF memcpy8_00000_arg_dst, 1
05C8  5177      	MOVF usb_handle_00058_arg_data, W, 1
05CA  6FA8      	MOVWF memcpy8_00000_arg_src, 1
05CC  5178      	MOVF usb_handle_00058_arg_data+D'1', W, 1
05CE  6FA9      	MOVWF memcpy8_00000_arg_src+D'1', 1
05D0  5179      	MOVF usb_handle_00058_arg_count, W, 1
05D2  6F7F      	MOVWF memcpy8_00000_arg_len, 1
05D4  EC25F002  	CALL memcpy8_00000


			// Now we need to send an ACK status back
			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
05D8  0E06      	MOVLW 0x06
05DA  6F56      	MOVWF gbl_control_mode, 1

			usb_send_status_ack();
05DC  EC8FF000  	CALL usb_send_e_00053

			line_coding *my_lc;
			my_lc = (line_coding*) &class_data;
05E0  0E01      	MOVLW HIGH(gbl_class_data+D'0')
05E2  6F7C      	MOVWF usb_handle_00058_1_my_lc+D'1', 1
05E4  0ED7      	MOVLW LOW(gbl_class_data+D'0')
05E6  6F7B      	MOVWF usb_handle_00058_1_my_lc, 1

			break;
	}
}
05BC  0012      	RETURN
05E8  0012      	RETURN


void usb_handle_ctrl_read_class()

{
		switch (usb_sdp.bRequest)
		{
			case req_GET_LINE_CODING:
05EA  0E21      	MOVLW 0x21
05EC  0101      	MOVLB 0x01
05EE  63A0      	CPFSEQ gbl_usb_sdp+D'1', 1

				// we know we've already sent everything, so now wait for status
				control_mode = cm_CTRL_READ_AWAITING_STATUS;
05F2  0E05      	MOVLW 0x05
05F4  0102      	MOVLB 0x02
05F6  6F56      	MOVWF gbl_control_mode, 1

				break;
			default:
		}

}
05F0  0012      	RETURN
05F8  0012      	RETURN


void usb_ep_data_out_callback(uns8 end_point, uns8 *buffer, uns16 byte_count)

{
	uns8 cdc_rx_next;

	// We have some data!
	if (end_point == CDC_DATA_ENDPOINT)
0600  0E03      	MOVLW 0x03
0602  6379      	CPFSEQ usb_ep_dat_00061_arg_end_point, 1

	{	// it's the data end point

		uns8 count;
		for (count = 0; count < byte_count; count++)
0606  6B7F      	CLRF usb_ep_dat_00061_2_count, 1
0608            label54
0608  517C      	MOVF usb_ep_dat_00061_arg_byte_count, W, 1
060A  617F      	CPFSLT usb_ep_dat_00061_2_count, 1
060C  517D      	MOVF usb_ep_dat_00061_arg_byte_count+D'1', W, 1
060E  B4D8      	BTFSC STATUS,Z
0650  2B7F      	INCF usb_ep_dat_00061_2_count, F, 1
0652  D7DA      	BRA	label54

		{
			cdc_rx_next = cdc_rx_end + 1;	// get next buffer position
0612  2962      	INCF gbl_cdc_rx_end, W, 1
0614  6F7E      	MOVWF usb_ep_dat_00061_1_cdc_rx_next, 1

			if (cdc_rx_next == CDC_RX_BUFFER_SIZE)
0616  0E40      	MOVLW 0x40
0618  637E      	CPFSEQ usb_ep_dat_00061_1_cdc_rx_next, 1
061A  D001      	BRA	label55
061E            label55

			{	// if we're at the end
				cdc_rx_next = 0;	// then wrap to the beginning
061C  6B7E      	CLRF usb_ep_dat_00061_1_cdc_rx_next, 1

			}
			if (cdc_rx_next != cdc_rx_start)
061E  5161      	MOVF gbl_cdc_rx_start, W, 1
0620  637E      	CPFSEQ usb_ep_dat_00061_1_cdc_rx_next, 1
0622  6361      	CPFSEQ gbl_cdc_rx_start, 1
0624  D015      	BRA	label56
0650            label56

			{ // if space in the fifo
				cdc_rx_buffer[cdc_rx_end] = buffer[count]; // put it in
0626  517B      	MOVF usb_ep_dat_00061_arg_buffer+D'1', W, 1
0628  6EEA      	MOVWF FSR0H
062A  517A      	MOVF usb_ep_dat_00061_arg_buffer, W, 1
062C  6EE9      	MOVWF FSR0L
062E  517F      	MOVF usb_ep_dat_00061_2_count, W, 1
0630  6FA8      	MOVWF CompTempVar2274, 1
0632  51A8      	MOVF CompTempVar2274, W, 1
0634  26E9      	ADDWF FSR0L, F
0636  50EF      	MOVF INDF0, W
0638  6FA9      	MOVWF CompTempVar2275, 1
063A  0100      	MOVLB 0x00
063C  EE00F0A0  	LFSR 0x00, gbl_cdc_rx_buffer
0640  50E9      	MOVF FSR0L, W
0642  0102      	MOVLB 0x02
0644  5162      	MOVF gbl_cdc_rx_end, W, 1
0646  26E9      	ADDWF FSR0L, F
0648  51A9      	MOVF CompTempVar2275, W, 1
064A  6EEF      	MOVWF INDF0

				cdc_rx_end = cdc_rx_next;  // and move pointer along
064C  517E      	MOVF usb_ep_dat_00061_1_cdc_rx_next, W, 1
064E  6F62      	MOVWF gbl_cdc_rx_end, 1

			} // else... just ignore it, we've lost a byte, no room in the inn
		}
	}
}
0604  0012      	RETURN
0610  0012      	RETURN


void usb_ep_data_in_callback(uns8 end_point, uns16 byte_count) {

	// data has been sent, so do we need to send more?
	usb_cdc_handle_tx();
05FA  ECA5F001  	CALL usb_cdc_ha_00063

}
05FE  0012      	RETURN



void usb_ep_get_rx_buffer(char length, char *buffer)

{
	uns8 count;

	if (length > 64)
0A50  0E40      	MOVLW 0x40
0A52  656D      	CPFSGT usb_ep_get_00070_arg_length, 1
0A54  D002      	BRA	label81
0A5A            label81

		length = 64;		// check for buffer overflow length
0A56  0E40      	MOVLW 0x40
0A58  6F6D      	MOVWF usb_ep_get_00070_arg_length, 1


	for (count = 0; count < length; count++)
0A5A  6B70      	CLRF usb_ep_get_00070_1_count, 1
0A5C            label82
0A5C  516D      	MOVF usb_ep_get_00070_arg_length, W, 1
0A5E  6170      	CPFSLT usb_ep_get_00070_1_count, 1
0A60  D014      	BRA	label83
0A86  2B70      	INCF usb_ep_get_00070_1_count, F, 1
0A88  D7E9      	BRA	label82
0A8A            label83

	{
		buffer[count] = cdc_rx_buffer[count];
0A62  0100      	MOVLB 0x00
0A64  EE00F0A0  	LFSR 0x00, gbl_cdc_rx_buffer
0A68  50E9      	MOVF FSR0L, W
0A6A  0102      	MOVLB 0x02
0A6C  5170      	MOVF usb_ep_get_00070_1_count, W, 1
0A6E  6F71      	MOVWF CompTempVar2303, 1
0A70  5171      	MOVF CompTempVar2303, W, 1
0A72  26E9      	ADDWF FSR0L, F
0A74  50EF      	MOVF INDF0, W
0A76  6F72      	MOVWF CompTempVar2304, 1
0A78  516F      	MOVF usb_ep_get_00070_arg_buffer+D'1', W, 1
0A7A  6EEA      	MOVWF FSR0H
0A7C  516E      	MOVF usb_ep_get_00070_arg_buffer, W, 1
0A7E  2570      	ADDWF usb_ep_get_00070_1_count, W, 1
0A80  6EE9      	MOVWF FSR0L
0A82  5172      	MOVF CompTempVar2304, W, 1
0A84  6EEF      	MOVWF INDF0

	}
	cdc_rx_end = cdc_rx_start;
0A8A  5161      	MOVF gbl_cdc_rx_start, W, 1
0A8C  6F62      	MOVWF gbl_cdc_rx_end, 1

}
0A8E  0012      	RETURN



void usb_cdc_putc(uns8 c) {

uns8 cdc_tx_next;
bit  my_store_gie;
#ifdef CDC_IDE_DEBUG
return;
#endif

	cdc_tx_next = cdc_tx_end + 1;	// get next buffer position
0A04  2960      	INCF gbl_cdc_tx_end, W, 1
0A06  6F73      	MOVWF usb_cdc_pu_0006B_1_cdc_tx_next, 1

	if (cdc_tx_next == CDC_TX_BUFFER_SIZE) {	// if we're at the end
0A08  0E40      	MOVLW 0x40
0A0A  6373      	CPFSEQ usb_cdc_pu_0006B_1_cdc_tx_next, 1
0A0C  D001      	BRA	label77
0A10            label77

		cdc_tx_next = 0;	// wrap to the beginning
0A0E  6B73      	CLRF usb_cdc_pu_0006B_1_cdc_tx_next, 1

	}

	if ((!intcon.GIE) && (cdc_tx_next == cdc_tx_start)) {
0A10  BEF2      	BTFSC gbl_intcon,7
0A12  D004      	BRA	label78
0A14  515F      	MOVF gbl_cdc_tx_start, W, 1
0A16  6373      	CPFSEQ usb_cdc_pu_0006B_1_cdc_tx_next, 1
0A18  D001      	BRA	label78
0A1C            label78

		return;
	}
	while (cdc_tx_next == cdc_tx_start) {
0A1C  515F      	MOVF gbl_cdc_tx_start, W, 1
0A1E  6373      	CPFSEQ usb_cdc_pu_0006B_1_cdc_tx_next, 1
0A20  D001      	BRA	label79
0A22  D7FC      	BRA	label78
0A24            label79

	}
	my_store_gie = intcon.GIE;	// store interrupt state
0A24  9174      	BCF usb_cdc_pu_0006B_1_my_store_gie,0, 1
0A26  BEF2      	BTFSC gbl_intcon,7
0A28  8174      	BSF usb_cdc_pu_0006B_1_my_store_gie,0, 1
0A2A            label80

	kill_interrupts();	// turn off global interrupts
0A2A  9EF2      	BCF gbl_intcon,7
0A2C  BEF2      	BTFSC gbl_intcon,7
0A2E  D7FD      	BRA	label80


	cdc_tx_buffer[cdc_tx_end] = c; // put it in
0A30  0100      	MOVLB 0x00
0A32  EE00F060  	LFSR 0x00, gbl_cdc_tx_buffer
0A36  50E9      	MOVF FSR0L, W
0A38  0102      	MOVLB 0x02
0A3A  5160      	MOVF gbl_cdc_tx_end, W, 1
0A3C  26E9      	ADDWF FSR0L, F
0A3E  5172      	MOVF usb_cdc_pu_0006B_arg_c, W, 1
0A40  6EEF      	MOVWF INDF0

	cdc_tx_end = cdc_tx_next;  // move pointer along
0A42  5173      	MOVF usb_cdc_pu_0006B_1_cdc_tx_next, W, 1
0A44  6F60      	MOVWF gbl_cdc_tx_end, 1


	intcon.GIE = my_store_gie;	// restore interrupt state
0A46  B174      	BTFSC usb_cdc_pu_0006B_1_my_store_gie,0, 1
0A48  8EF2      	BSF gbl_intcon,7
0A4A  A174      	BTFSS usb_cdc_pu_0006B_1_my_store_gie,0, 1
0A4C  9EF2      	BCF gbl_intcon,7


}
0A1A  0012      	RETURN
0A4E  0012      	RETURN



void usb_cdc_handle_tx()

{
uns8 cdc_tx_next;
uns8 count;
uns16 buffer_size;
uns8 *buffer;
buffer_descriptor *bd;

	bd = ep_in_bd_location[CDC_DATA_ENDPOINT];
034A  0101      	MOVLB 0x01
034C  51AD      	MOVF gbl_ep_in_bd_location+D'6', W, 1
034E  0102      	MOVLB 0x02
0350  6FAA      	MOVWF usb_cdc_ha_00063_1_bd, 1
0352  0101      	MOVLB 0x01
0354  51AE      	MOVF gbl_ep_in_bd_location+D'7', W, 1
0356  0102      	MOVLB 0x02
0358  6FAB      	MOVWF usb_cdc_ha_00063_1_bd+D'1', 1

	if (test_bit(bd->stat, UOWN)) {	// if there's already something in play
035A  51AB      	MOVF usb_cdc_ha_00063_1_bd+D'1', W, 1
035C  6EEA      	MOVWF FSR0H
035E  51AA      	MOVF usb_cdc_ha_00063_1_bd, W, 1
0360  6EE9      	MOVWF FSR0L
0362  BEEF      	BTFSC INDF0,7

		return;	// give up
	}

	buffer_size = ep_in_buffer_size[CDC_DATA_ENDPOINT];
0366  0101      	MOVLB 0x01
0368  51CD      	MOVF gbl_ep_in_buffer_size+D'6', W, 1
036A  0102      	MOVLB 0x02
036C  6F7E      	MOVWF usb_cdc_ha_00063_1_buffer_size, 1
036E  0101      	MOVLB 0x01
0370  51CE      	MOVF gbl_ep_in_buffer_size+D'7', W, 1
0372  0102      	MOVLB 0x02
0374  6F7F      	MOVWF usb_cdc_ha_00063_1_buffer_size+D'1', 1

	buffer = ep_in_buffer_location[CDC_DATA_ENDPOINT];
0376  0101      	MOVLB 0x01
0378  51BD      	MOVF gbl_ep_in_buffer_location+D'6', W, 1
037A  0102      	MOVLB 0x02
037C  6FA8      	MOVWF usb_cdc_ha_00063_1_buffer, 1
037E  0101      	MOVLB 0x01
0380  51BE      	MOVF gbl_ep_in_buffer_location+D'7', W, 1
0382  0102      	MOVLB 0x02
0384  6FA9      	MOVWF usb_cdc_ha_00063_1_buffer+D'1', 1


	if (cdc_tx_end == cdc_tx_start) { // anything in the fifo?
0386  515F      	MOVF gbl_cdc_tx_start, W, 1
0388  6360      	CPFSEQ gbl_cdc_tx_end, 1
038A  D001      	BRA	label27
038E            label27

	   return; // nope
	}

	start_crit_sec();
038E  91AC      	BCF usb_cdc_ha_00063_1_store_gie,0, 1
0390  BEF2      	BTFSC gbl_intcon,7
0392  81AC      	BSF usb_cdc_ha_00063_1_store_gie,0, 1
0394            label28
0394  9EF2      	BCF gbl_intcon,7
0396  BEF2      	BTFSC gbl_intcon,7
0398  D7FD      	BRA	label28


	count = 0;
039A  6B7D      	CLRF usb_cdc_ha_00063_1_count, 1

	while ((cdc_tx_end != cdc_tx_start) && (count < buffer_size)) {
039C            label29
039C  515F      	MOVF gbl_cdc_tx_start, W, 1
039E  6360      	CPFSEQ gbl_cdc_tx_end, 1
03A0  635F      	CPFSEQ gbl_cdc_tx_start, 1
03A2  D020      	BRA	label31
03A4  517E      	MOVF usb_cdc_ha_00063_1_buffer_size, W, 1
03A6  617D      	CPFSLT usb_cdc_ha_00063_1_count, 1
03A8  517F      	MOVF usb_cdc_ha_00063_1_buffer_size+D'1', W, 1
03AA  E01C      	BZ	label31
03E2  D7DC      	BRA	label29
03E4            label31


		cdc_tx_next = cdc_tx_start + 1;	// get next position
03AC  295F      	INCF gbl_cdc_tx_start, W, 1
03AE  6F7C      	MOVWF usb_cdc_ha_00063_1_cdc_tx_next, 1

		if (cdc_tx_next == CDC_TX_BUFFER_SIZE) {	// if we're at the end of the buffer
03B0  0E40      	MOVLW 0x40
03B2  637C      	CPFSEQ usb_cdc_ha_00063_1_cdc_tx_next, 1
03B4  D001      	BRA	label30
03B8            label30

			cdc_tx_next = 0;	// wrap to the beginning
03B6  6B7C      	CLRF usb_cdc_ha_00063_1_cdc_tx_next, 1

		}
		buffer[count] = cdc_tx_buffer[cdc_tx_start];	// transmit the character
03B8  0100      	MOVLB 0x00
03BA  EE00F060  	LFSR 0x00, gbl_cdc_tx_buffer
03BE  50E9      	MOVF FSR0L, W
03C0  0102      	MOVLB 0x02
03C2  515F      	MOVF gbl_cdc_tx_start, W, 1
03C4  6FAD      	MOVWF CompTempVar2281, 1
03C6  51AD      	MOVF CompTempVar2281, W, 1
03C8  26E9      	ADDWF FSR0L, F
03CA  50EF      	MOVF INDF0, W
03CC  6FAE      	MOVWF CompTempVar2282, 1
03CE  51A9      	MOVF usb_cdc_ha_00063_1_buffer+D'1', W, 1
03D0  6EEA      	MOVWF FSR0H
03D2  51A8      	MOVF usb_cdc_ha_00063_1_buffer, W, 1
03D4  257D      	ADDWF usb_cdc_ha_00063_1_count, W, 1
03D6  6EE9      	MOVWF FSR0L
03D8  51AE      	MOVF CompTempVar2282, W, 1
03DA  6EEF      	MOVWF INDF0

		count++;
03DC  2B7D      	INCF usb_cdc_ha_00063_1_count, F, 1

		cdc_tx_start = cdc_tx_next;	// move start position of fifo
03DE  517C      	MOVF usb_cdc_ha_00063_1_cdc_tx_next, W, 1
03E0  6F5F      	MOVWF gbl_cdc_tx_start, 1

	}
	if (count > 0) {
03E4  0E00      	MOVLW 0x00
03E6  657D      	CPFSGT usb_cdc_ha_00063_1_count, 1
03E8  D02B      	BRA	label34
0440            label34

		bd->count = count;
03EA  51AB      	MOVF usb_cdc_ha_00063_1_bd+D'1', W, 1
03EC  6EEA      	MOVWF FSR0H
03EE  29AA      	INCF usb_cdc_ha_00063_1_bd, W, 1
03F0  6EE9      	MOVWF FSR0L
03F2  517D      	MOVF usb_cdc_ha_00063_1_count, W, 1
03F4  6EEF      	MOVWF INDF0

		bd->addr = (uns16)buffer;
03F6  06E9      	DECF FSR0L, F
03F8  0E02      	MOVLW 0x02
03FA  26E9      	ADDWF FSR0L, F
03FC  2AE9      	INCF FSR0L, F
03FE  51A8      	MOVF usb_cdc_ha_00063_1_buffer, W, 1
0400  6FAD      	MOVWF CompTempVar2283, 1
0402  51A9      	MOVF usb_cdc_ha_00063_1_buffer+D'1', W, 1
0404  6EEF      	MOVWF INDF0
0406  06E9      	DECF FSR0L, F
0408  51AD      	MOVF CompTempVar2283, W, 1
040A  6EEF      	MOVWF INDF0

		if(test_bit(bd->stat, DTS))
040C  51AA      	MOVF usb_cdc_ha_00063_1_bd, W, 1
040E  6EE9      	MOVWF FSR0L
0410  ACEF      	BTFSS INDF0,6
0412  D006      	BRA	label32
0420            label32

			clear_bit(bd->stat, DTS);
0414  51AB      	MOVF usb_cdc_ha_00063_1_bd+D'1', W, 1
0416  6EEA      	MOVWF FSR0H
0418  51AA      	MOVF usb_cdc_ha_00063_1_bd, W, 1
041A  6EE9      	MOVWF FSR0L
041C  9CEF      	BCF INDF0,6

		else set_bit(bd->stat, DTS);
041E  D005      	BRA	label33
0420  51AB      	MOVF usb_cdc_ha_00063_1_bd+D'1', W, 1
0422  6EEA      	MOVWF FSR0H
0424  51AA      	MOVF usb_cdc_ha_00063_1_bd, W, 1
0426  6EE9      	MOVWF FSR0L
0428  8CEF      	BSF INDF0,6
042A            label33

		clear_bit(bd->stat, KEN);	// clear the keep bit
042A  51AB      	MOVF usb_cdc_ha_00063_1_bd+D'1', W, 1
042C  6EEA      	MOVWF FSR0H
042E  51AA      	MOVF usb_cdc_ha_00063_1_bd, W, 1
0430  6EE9      	MOVWF FSR0L
0432  9AEF      	BCF INDF0,5

		clear_bit(bd->stat, INCDIS);	// clear the increment disable
0434  98EF      	BCF INDF0,4

		set_bit  (bd->stat, DTSEN);
0436  86EF      	BSF INDF0,3

		clear_bit(bd->stat, BSTALL);	// clear stall bit
0438  94EF      	BCF INDF0,2

		clear_bit(bd->stat, BC9);
043A  92EF      	BCF INDF0,1

		clear_bit(bd->stat, BC8);
043C  90EF      	BCF INDF0,0


		set_bit  (bd->stat, UOWN);	// SIE owns the buffer
043E  8EEF      	BSF INDF0,7

	}
	end_crit_sec();
0440  B1AC      	BTFSC usb_cdc_ha_00063_1_store_gie,0, 1
0442  8EF2      	BSF gbl_intcon,7
0444  A1AC      	BTFSS usb_cdc_ha_00063_1_store_gie,0, 1
0446  9EF2      	BCF gbl_intcon,7

}
0364  0012      	RETURN
038C  0012      	RETURN
0448  0012      	RETURN


uns8 usb_cdc_rx_avail() { return (cdc_rx_end - cdc_rx_start); }
0CE8  0102      	MOVLB 0x02
0CEA  5161      	MOVF gbl_cdc_rx_start, W, 1
0CEC  5D62      	SUBWF gbl_cdc_rx_end, W, 1
0CEE  6F6C      	MOVWF CompTempVarRet2291, 1
0CF0  0012      	RETURN

uns8 usb_cdc_tx_empty() { return cdc_tx_start == cdc_tx_end; }
0CDA  0102      	MOVLB 0x02
0CDC  6B6E      	CLRF CompTempVarRet2292, 1
0CDE  5160      	MOVF gbl_cdc_tx_end, W, 1
0CE0  635F      	CPFSEQ gbl_cdc_tx_start, 1
0CE2  0012      	RETURN
0CE4  2B6E      	INCF CompTempVarRet2292, F, 1
0CE6  0012      	RETURN


void usb_cdc_print_str(char *str) {


uns8 count;
buffer_descriptor *bd;

	for(count = 0 ; str[count] != 0; count++)
0CF2  6B71      	CLRF usb_cdc_pr_0006E_1_count, 1
0CF4            label84
0CF4  5170      	MOVF usb_cdc_pr_0006E_arg_str+D'1', W, 1
0CF6  6EEA      	MOVWF FSR0H
0CF8  516F      	MOVF usb_cdc_pr_0006E_arg_str, W, 1
0CFA  2571      	ADDWF usb_cdc_pr_0006E_1_count, W, 1
0CFC  6EE9      	MOVWF FSR0L
0CFE  52EF      	MOVF INDF0, F
0D00  B4D8      	BTFSC STATUS,Z
0D16  2B71      	INCF usb_cdc_pr_0006E_1_count, F, 1
0D18  D7ED      	BRA	label84

    {
        usb_cdc_putc(str[count]);
0D04  5170      	MOVF usb_cdc_pr_0006E_arg_str+D'1', W, 1
0D06  6EEA      	MOVWF FSR0H
0D08  516F      	MOVF usb_cdc_pr_0006E_arg_str, W, 1
0D0A  2571      	ADDWF usb_cdc_pr_0006E_1_count, W, 1
0D0C  6EE9      	MOVWF FSR0L
0D0E  50EF      	MOVF INDF0, W
0D10  6F72      	MOVWF usb_cdc_pu_0006B_arg_c, 1
0D12  EC02F005  	CALL usb_cdc_pu_0006B

    }
}
0D02  0012      	RETURN


void usb_SOF_callback(uns16 frame) {

	// we don't care about the frame number, we only care if there's something to send...
	usb_cdc_handle_tx();	// start transmission
08FE  ECA5F001  	CALL usb_cdc_ha_00063

}
0902  0012      	RETURN


void usb_cdc_setup() {

	line_coding *my_lc;
	my_lc = (line_coding*) &class_data;
09A8  0E01      	MOVLW HIGH(gbl_class_data+D'0')
09AA  0102      	MOVLB 0x02
09AC  6F6A      	MOVWF usb_cdc_se_0006F_1_my_lc+D'1', 1
09AE  0ED7      	MOVLW LOW(gbl_class_data+D'0')
09B0  6F69      	MOVWF usb_cdc_se_0006F_1_my_lc, 1

	my_lc->dte_rate.as_long = 0x60090000;
09B2  516A      	MOVF usb_cdc_se_0006F_1_my_lc+D'1', W, 1
09B4  6EEA      	MOVWF FSR0H
09B6  5169      	MOVF usb_cdc_se_0006F_1_my_lc, W, 1
09B8  6EE9      	MOVWF FSR0L
09BA  0E03      	MOVLW 0x03
09BC  26E9      	ADDWF FSR0L, F
09BE  0E00      	MOVLW 0x00
09C0  6F6B      	MOVWF CompTempVar2300, 1
09C2  6F6C      	MOVWF CompTempVar2300+D'1', 1
09C4  0E09      	MOVLW 0x09
09C6  6F6D      	MOVWF CompTempVar2300+D'2', 1
09C8  0E60      	MOVLW 0x60
09CA  6EEF      	MOVWF INDF0
09CC  06E9      	DECF FSR0L, F
09CE  516D      	MOVF CompTempVar2300+D'2', W, 1
09D0  6EEF      	MOVWF INDF0
09D2  06E9      	DECF FSR0L, F
09D4  516C      	MOVF CompTempVar2300+D'1', W, 1
09D6  6EEF      	MOVWF INDF0
09D8  06E9      	DECF FSR0L, F
09DA  516B      	MOVF CompTempVar2300, W, 1
09DC  6EEF      	MOVWF INDF0

	my_lc->stop_bits = 0;
09DE  5169      	MOVF usb_cdc_se_0006F_1_my_lc, W, 1
09E0  6EE9      	MOVWF FSR0L
09E2  0E04      	MOVLW 0x04
09E4  26E9      	ADDWF FSR0L, F
09E6  0E00      	MOVLW 0x00
09E8  6EEF      	MOVWF INDF0

	my_lc->data_bits = 8;
09EA  5169      	MOVF usb_cdc_se_0006F_1_my_lc, W, 1
09EC  6EE9      	MOVWF FSR0L
09EE  0E06      	MOVLW 0x06
09F0  26E9      	ADDWF FSR0L, F
09F2  0E08      	MOVLW 0x08
09F4  6EEF      	MOVWF INDF0

	my_lc->parity = 0;
09F6  5169      	MOVF usb_cdc_se_0006F_1_my_lc, W, 1
09F8  6EE9      	MOVWF FSR0L
09FA  0E05      	MOVLW 0x05
09FC  26E9      	ADDWF FSR0L, F
09FE  0E00      	MOVLW 0x00
0A00  6EEF      	MOVWF INDF0

}
0A02  0012      	RETURN


/*********************************************************************
 *                    Flowcode USB Component Code
 *
 * File: usb_config_serial.c
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 031008 | BR | Created
 * 190711 | BR | Confirmed current version
 ********************************************************************/

#include "pic_usb.h"

typedef struct _configuration {
	configuration_descriptor cdc_config;
	interface_descriptor cdc_comm_interface;
	CDC_header_functional_descriptor cdc_header;
	CDC_ACM_functional_descriptor cdc_ACM;
	CDC_union_functional_descriptor cdc_union;
	CDC_call_mgt_functional_descriptor cdc_call_mgt;
	endpoint_descriptor cdc_notification_ep;
	interface_descriptor cdc_data_interface;
	endpoint_descriptor cdc_data_out_ep;
	endpoint_descriptor cdc_data_in_ep;
} configuration;


// Structure Defines
device_descriptor my_device_descriptor;
configuration_descriptor my_config;
interface_descriptor my_comm_interface;
CDC_header_functional_descriptor my_header;
CDC_ACM_functional_descriptor my_ACM;
CDC_union_functional_descriptor my_union;
CDC_call_mgt_functional_descriptor my_call_mgt;
endpoint_descriptor my_notification_ep;
interface_descriptor my_data_interface;
endpoint_descriptor my_data_out_ep;
endpoint_descriptor my_data_in_ep;
configuration complete_serial_configuration;



uns8 string_00 [] =
	{
		4,	// length,
1202  0E04      	MOVLW 0x04
1204  6F34      	MOVWF gbl_string_00, 1

		dt_STRING,	// descriptor type
1206  0E03      	MOVLW 0x03
1208  6F35      	MOVWF gbl_string_00+D'1', 1

		9,	// magic for US english
120A  0E09      	MOVLW 0x09
120C  6F36      	MOVWF gbl_string_00+D'2', 1

		4
120E  0E04      	MOVLW 0x04
1210  6F37      	MOVWF gbl_string_00+D'3', 1

	};


void usb_configure_structures(void)

{
	// device descriptor - - - - - - - - - -
	my_device_descriptor.length = sizeof(device_descriptor); 		// bytes long
0A9C  0E12      	MOVLW 0x12
0A9E  6E48      	MOVWF gbl_my_device_descriptor

	my_device_descriptor.descriptor_type = dt_DEVICE; 				// DEVICE 01h
0AA0  0E01      	MOVLW 0x01
0AA2  6E49      	MOVWF gbl_my_device_descriptor+D'1'

	my_device_descriptor.usb_version = 0x0110;						// usb version 1.10
0AA4  0E10      	MOVLW 0x10
0AA6  6E4A      	MOVWF gbl_my_device_descriptor+D'2'
0AA8  0E01      	MOVLW 0x01
0AAA  6E4B      	MOVWF gbl_my_device_descriptor+D'3'

	my_device_descriptor.device_class = 2;							// class (communication device class)
0AAC  0E02      	MOVLW 0x02
0AAE  6E4C      	MOVWF gbl_my_device_descriptor+D'4'

	my_device_descriptor.device_subclass = 0;						// subclass (unused)
0AB0  6A4D      	CLRF gbl_my_device_descriptor+D'5'

	my_device_descriptor.device_protocol = 0;						// protocol	(unused)
0AB2  6A4E      	CLRF gbl_my_device_descriptor+D'6'

	my_device_descriptor.max_packet_size_ep0 = USB_EP0_OUT_SIZE;	// max packet size for end point 0
0AB4  0E08      	MOVLW 0x08
0AB6  6E4F      	MOVWF gbl_my_device_descriptor+D'7'

	my_device_descriptor.vendor_id = MX_VID;						// Matrix's vendor
0AB8  0EBF      	MOVLW 0xBF
0ABA  6E50      	MOVWF gbl_my_device_descriptor+D'8'
0ABC  0E12      	MOVLW 0x12
0ABE  6E51      	MOVWF gbl_my_device_descriptor+D'9'

	my_device_descriptor.product_id = MX_PID;						// Matrix's product
0AC0  0E10      	MOVLW 0x10
0AC2  6E52      	MOVWF gbl_my_device_descriptor+D'10'
0AC4  0EF0      	MOVLW 0xF0
0AC6  6E53      	MOVWF gbl_my_device_descriptor+D'11'

	my_device_descriptor.device_release = MX_VERSION;				// version 2.0 of the product
0AC8  6A54      	CLRF gbl_my_device_descriptor+D'12'
0ACA  0E01      	MOVLW 0x01
0ACC  6E55      	MOVWF gbl_my_device_descriptor+D'13'

	my_device_descriptor.manufacturer_string_id = 1;				// string 1 for manufacturer
0ACE  6E56      	MOVWF gbl_my_device_descriptor+D'14'

	my_device_descriptor.product_string_id = 2;						// string 2 for product
0AD0  0E02      	MOVLW 0x02
0AD2  6E57      	MOVWF gbl_my_device_descriptor+D'15'

	my_device_descriptor.serial_string_id = 0;						// string 3 for serial number
0AD4  6A58      	CLRF gbl_my_device_descriptor+D'16'

	my_device_descriptor.num_configurations = 1;					// number of configurations
0AD6  0E01      	MOVLW 0x01
0AD8  6E59      	MOVWF gbl_my_device_descriptor+D'17'


	// configuration descriptor - - - - - - - - - -
	my_config.length = sizeof(configuration_descriptor);			// length,
0ADA  0E09      	MOVLW 0x09
0ADC  0100      	MOVLB 0x00
0ADE  6FEA      	MOVWF gbl_my_config, 1

	my_config.descriptor_type = dt_CONFIGURATION;					// descriptor_type,
0AE0  0E02      	MOVLW 0x02
0AE2  6FEB      	MOVWF gbl_my_config+D'1', 1

	my_config.total_length = sizeof(complete_serial_configuration);	// total_length;
0AE4  0E43      	MOVLW 0x43
0AE6  6FEC      	MOVWF gbl_my_config+D'2', 1
0AE8  6BED      	CLRF gbl_my_config+D'3', 1

	my_config.num_interfaces = 0x02;								// num_interfaces,
0AEA  0E02      	MOVLW 0x02
0AEC  6FEE      	MOVWF gbl_my_config+D'4', 1

	my_config.configuration_value = 0x01;							// configuration_value,
0AEE  0E01      	MOVLW 0x01
0AF0  6FEF      	MOVWF gbl_my_config+D'5', 1

	my_config.configuration_string_id = 0x00;						// configuration_string_id,
0AF2  6BF0      	CLRF gbl_my_config+D'6', 1

	my_config.attributes = 0b10000000; 								// attributes (bus powered, no remote wake up)
0AF4  0E80      	MOVLW 0x80
0AF6  6FF1      	MOVWF gbl_my_config+D'7', 1

	my_config.max_power = 100;										// max_power; (200ma)
0AF8  0E64      	MOVLW 0x64
0AFA  6FF2      	MOVWF gbl_my_config+D'8', 1


	// Communication interface descriptor - - - - - - - - - - - -
	my_comm_interface.length = sizeof(interface_descriptor);		// length,
0AFC  0E09      	MOVLW 0x09
0AFE  6FF3      	MOVWF gbl_my_comm_interface, 1

	my_comm_interface.descriptor_type = dt_INTERFACE;				// descriptor_type,
0B00  0E04      	MOVLW 0x04
0B02  6FF4      	MOVWF gbl_my_comm_interface+D'1', 1

	my_comm_interface.interface_number = 0x00;						// interface_number, (starts at zero)
0B04  6BF5      	CLRF gbl_my_comm_interface+D'2', 1

	my_comm_interface.alternate_setting = 0x00;						// alternate_setting, (no alternatives)
0B06  6BF6      	CLRF gbl_my_comm_interface+D'3', 1

	my_comm_interface.num_endpoints = 0x01;							// num_endpoints,
0B08  0E01      	MOVLW 0x01
0B0A  6FF7      	MOVWF gbl_my_comm_interface+D'4', 1

	my_comm_interface.interface_class = 0x02;						// interface_class, (Communication Interface Class)
0B0C  0E02      	MOVLW 0x02
0B0E  6FF8      	MOVWF gbl_my_comm_interface+D'5', 1

	my_comm_interface.interface_subclass = 0x02;					// interface_subclass, (Abstract Control Model subclass)
0B10  6FF9      	MOVWF gbl_my_comm_interface+D'6', 1

	my_comm_interface.interface_protocol = 0x01;					// interface_protocol, (AT commands)
0B12  0E01      	MOVLW 0x01
0B14  6FFA      	MOVWF gbl_my_comm_interface+D'7', 1

	my_comm_interface.interface_string_id = 0x00;					// interface_string_id;
0B16  6BFB      	CLRF gbl_my_comm_interface+D'8', 1


	// CDC header functional descriptor - - - - - - - - - - - - - -
	my_header.length = sizeof(CDC_header_functional_descriptor);	// length,
0B18  0E05      	MOVLW 0x05
0B1A  6E5A      	MOVWF gbl_my_header

	my_header.descriptor_type = dt_CS_INTERFACE;					// descriptor_type (CS_INTERFACE = 0x24)
0B1C  0E24      	MOVLW 0x24
0B1E  6E5B      	MOVWF gbl_my_header+D'1'

	my_header.descriptor_subtype = 0x00;							// descriptor_subtype (Header functional descriptor = 0x00)
0B20  6A5C      	CLRF gbl_my_header+D'2'

	my_header.CDC_version = 0x0110;									// CDC_version (BCD release of CDC spec = 0x0110)
0B22  0E10      	MOVLW 0x10
0B24  6E5D      	MOVWF gbl_my_header+D'3'
0B26  0E01      	MOVLW 0x01
0B28  6E5E      	MOVWF gbl_my_header+D'4'


	// Abstract Control Model functional descriptor - - - - - - - -
	my_ACM.length = sizeof(CDC_ACM_functional_descriptor);			// length,
0B2A  0E04      	MOVLW 0x04
0B2C  0102      	MOVLB 0x02
0B2E  6F30      	MOVWF gbl_my_ACM, 1

	my_ACM.descriptor_type = dt_CS_INTERFACE;						// descriptor_type (CS_INTERFACE = 0x24)
0B30  0E24      	MOVLW 0x24
0B32  6F31      	MOVWF gbl_my_ACM+D'1', 1

	my_ACM.descriptor_subtype = 0x02;								// descriptor_subtype (ACM functional descriptor subtype = 0x02)
0B34  0E02      	MOVLW 0x02
0B36  6F32      	MOVWF gbl_my_ACM+D'2', 1

	my_ACM.capabilities = 0x02;										// capabilities (Device supports the request combination of Set_Line_Coding,
0B38  6F33      	MOVWF gbl_my_ACM+D'3', 1

																	// Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State.
																	// See http://www.usb.org/developers/devclass_docs/usbcdc11.pdf p36

	// Union functional descriptor - - - - - - - - - - - - - - -
	my_union.length = sizeof(CDC_union_functional_descriptor);		// length
0B3A  0E05      	MOVLW 0x05
0B3C  0101      	MOVLB 0x01
0B3E  6FF4      	MOVWF gbl_my_union, 1

	my_union.descriptor_type = dt_CS_INTERFACE;						// descriptor_type (CS_INTERFACE = 0x24)
0B40  0E24      	MOVLW 0x24
0B42  6FF5      	MOVWF gbl_my_union+D'1', 1

	my_union.descriptor_subtype = 0x06;								// descriptor_subtype (Union functional descriptor subtype = 0x06)
0B44  0E06      	MOVLW 0x06
0B46  6FF6      	MOVWF gbl_my_union+D'2', 1

	my_union.master_interface = 0x00;								// master_interface (Controlling interface number = 0x00)
0B48  6BF7      	CLRF gbl_my_union+D'3', 1

	my_union.slave_interface = 0x01;								// slave_interface (First slave interface = 0x01)
0B4A  0E01      	MOVLW 0x01
0B4C  6FF8      	MOVWF gbl_my_union+D'4', 1


	// Call management functional descriptor - - - - - - - - - -
	my_call_mgt.length = sizeof(CDC_call_mgt_functional_descriptor);
0B4E  0E05      	MOVLW 0x05
0B50  6FF9      	MOVWF gbl_my_call_mgt, 1

	my_call_mgt.descriptor_type = dt_CS_INTERFACE;					// descriptor_type (CS_INTERFACE = 0x24)
0B52  0E24      	MOVLW 0x24
0B54  6FFA      	MOVWF gbl_my_call_mgt+D'1', 1

	my_call_mgt.descriptor_subtype = 0x01;							// descriptor_subtype (Call management functional descriptor subtype = 0x01)
0B56  0E01      	MOVLW 0x01
0B58  6FFB      	MOVWF gbl_my_call_mgt+D'2', 1

	my_call_mgt.capabilities = 0x00;								// capabilities
0B5A  6BFC      	CLRF gbl_my_call_mgt+D'3', 1

																	// bit 1 =0* Device sends/receives call management information only over
																	//           the Communication Class interface
																	//       =1  over data class interface
																	// bit 0 =0* Device does not handle call management itself
																	//       =1  Device handles call management itself
	my_call_mgt.data_interface = 0x01;								// Data_interface  (interface number of data class interface)
0B5C  0E01      	MOVLW 0x01
0B5E  6FFD      	MOVWF gbl_my_call_mgt+D'4', 1


	// Notification endpoint descriptor - - - - - - - - - - - - -
	my_notification_ep.length = sizeof(endpoint_descriptor);		// length,
0B60  0E07      	MOVLW 0x07
0B62  6FDF      	MOVWF gbl_my_notification_ep, 1

	my_notification_ep.descriptor_type = dt_ENDPOINT;				// descriptor_type,
0B64  0E05      	MOVLW 0x05
0B66  6FE0      	MOVWF gbl_my_notification_ep+D'1', 1

	my_notification_ep.endpoint_address = 0b10000010;				// endpoint_address, (Endpoint 2, IN)
0B68  0E82      	MOVLW 0x82
0B6A  6FE1      	MOVWF gbl_my_notification_ep+D'2', 1

	my_notification_ep.attributes = 0b00000011;						// attributes; (Interrupt)
0B6C  0E03      	MOVLW 0x03
0B6E  6FE2      	MOVWF gbl_my_notification_ep+D'3', 1

	my_notification_ep.max_packet_size = USB_EP2_IN_SIZE;			// max_packet_size;
0B70  0E08      	MOVLW 0x08
0B72  6FE3      	MOVWF gbl_my_notification_ep+D'4', 1
0B74  6BE4      	CLRF gbl_my_notification_ep+D'5', 1

	my_notification_ep.interval = 2;								// interval (10ms)
0B76  0E02      	MOVLW 0x02
0B78  6FE5      	MOVWF gbl_my_notification_ep+D'6', 1


	// Data interface descriptor - - - - - - - - - - - -
	my_data_interface.length = sizeof(interface_descriptor);		// length,
0B7A  0E09      	MOVLW 0x09
0B7C  6F96      	MOVWF gbl_my_data_interface, 1

	my_data_interface.descriptor_type = dt_INTERFACE;				// descriptor_type,
0B7E  0E04      	MOVLW 0x04
0B80  6F97      	MOVWF gbl_my_data_interface+D'1', 1

	my_data_interface.interface_number = 0x01;						// interface_number, (starts at zero)
0B82  0E01      	MOVLW 0x01
0B84  6F98      	MOVWF gbl_my_data_interface+D'2', 1

	my_data_interface.alternate_setting = 0x00;						// alternate_setting, (no alternatives)
0B86  6B99      	CLRF gbl_my_data_interface+D'3', 1

	my_data_interface.num_endpoints = 0x02;							// num_endpoints,
0B88  0E02      	MOVLW 0x02
0B8A  6F9A      	MOVWF gbl_my_data_interface+D'4', 1

	my_data_interface.interface_class = 0x0A;						// interface_class, (Device Interface Class)
0B8C  0E0A      	MOVLW 0x0A
0B8E  6F9B      	MOVWF gbl_my_data_interface+D'5', 1

	my_data_interface.interface_subclass = 0x00;					// interface_subclass, (Data Interface subclass)
0B90  6B9C      	CLRF gbl_my_data_interface+D'6', 1

	my_data_interface.interface_protocol = 0x00;					// interface_protocol
0B92  6B9D      	CLRF gbl_my_data_interface+D'7', 1

	my_data_interface.interface_string_id = 0x00;					// interface_string_id;
0B94  6B9E      	CLRF gbl_my_data_interface+D'8', 1


	// Data OUT endpoint descriptor - - - - - - - - - - - - -
	my_data_out_ep.length = sizeof(endpoint_descriptor);			// length,
0B96  0E07      	MOVLW 0x07
0B98  6FE6      	MOVWF gbl_my_data_out_ep, 1

	my_data_out_ep.descriptor_type = dt_ENDPOINT;					// descriptor_type,
0B9A  0E05      	MOVLW 0x05
0B9C  6FE7      	MOVWF gbl_my_data_out_ep+D'1', 1

	my_data_out_ep.endpoint_address = 0b00000011;					// endpoint_address, (Endpoint 3, OUT)
0B9E  0E03      	MOVLW 0x03
0BA0  6FE8      	MOVWF gbl_my_data_out_ep+D'2', 1

	my_data_out_ep.attributes = 0b00000010;							// attributes; (Bulk)
0BA2  0E02      	MOVLW 0x02
0BA4  6FE9      	MOVWF gbl_my_data_out_ep+D'3', 1

	my_data_out_ep.max_packet_size = USB_EP3_OUT_SIZE;				// max_packet_size;
0BA6  0E08      	MOVLW 0x08
0BA8  6FEA      	MOVWF gbl_my_data_out_ep+D'4', 1
0BAA  6BEB      	CLRF gbl_my_data_out_ep+D'5', 1

	my_data_out_ep.interval = 0;									// no interval
0BAC  6BEC      	CLRF gbl_my_data_out_ep+D'6', 1


	// Data IN endpoint descriptor - - - - - - - - - - - - -
	my_data_in_ep.length = sizeof(endpoint_descriptor);				// length,
0BAE  0E07      	MOVLW 0x07
0BB0  6FED      	MOVWF gbl_my_data_in_ep, 1

	my_data_in_ep.descriptor_type = dt_ENDPOINT;					// descriptor_type,
0BB2  0E05      	MOVLW 0x05
0BB4  6FEE      	MOVWF gbl_my_data_in_ep+D'1', 1

	my_data_in_ep.endpoint_address = 0b10000011;					// endpoint_address, (Endpoint 3, IN)
0BB6  0E83      	MOVLW 0x83
0BB8  6FEF      	MOVWF gbl_my_data_in_ep+D'2', 1

	my_data_in_ep.attributes = 0b00000010;							// attributes; (Bulk)
0BBA  0E02      	MOVLW 0x02
0BBC  6FF0      	MOVWF gbl_my_data_in_ep+D'3', 1

	my_data_in_ep.max_packet_size = USB_EP3_IN_SIZE;				// max_packet_size;
0BBE  0E08      	MOVLW 0x08
0BC0  6FF1      	MOVWF gbl_my_data_in_ep+D'4', 1
0BC2  6BF2      	CLRF gbl_my_data_in_ep+D'5', 1

	my_data_in_ep.interval = 0;										// no interval
0BC4  6BF3      	CLRF gbl_my_data_in_ep+D'6', 1


	// Collect into one enumeration structure - - - - - - - - - - - - -
	complete_serial_configuration.cdc_config = my_config;
0BC6  0100      	MOVLB 0x00
0BC8  51F2      	MOVF gbl_my_config+D'8', W, 1
0BCA  6E0D      	MOVWF gbl_complete_serial_config_00000+D'8'
0BCC  51F1      	MOVF gbl_my_config+D'7', W, 1
0BCE  6E0C      	MOVWF gbl_complete_serial_config_00000+D'7'
0BD0  51F0      	MOVF gbl_my_config+D'6', W, 1
0BD2  6E0B      	MOVWF gbl_complete_serial_config_00000+D'6'
0BD4  51EF      	MOVF gbl_my_config+D'5', W, 1
0BD6  6E0A      	MOVWF gbl_complete_serial_config_00000+D'5'
0BD8  51EE      	MOVF gbl_my_config+D'4', W, 1
0BDA  6E09      	MOVWF gbl_complete_serial_config_00000+D'4'
0BDC  51ED      	MOVF gbl_my_config+D'3', W, 1
0BDE  6E08      	MOVWF gbl_complete_serial_config_00000+D'3'
0BE0  51EC      	MOVF gbl_my_config+D'2', W, 1
0BE2  6E07      	MOVWF gbl_complete_serial_config_00000+D'2'
0BE4  51EB      	MOVF gbl_my_config+D'1', W, 1
0BE6  6E06      	MOVWF gbl_complete_serial_config_00000+D'1'
0BE8  51EA      	MOVF gbl_my_config, W, 1
0BEA  6E05      	MOVWF gbl_complete_serial_config_00000

	complete_serial_configuration.cdc_comm_interface = my_comm_interface;
0BEC  51FB      	MOVF gbl_my_comm_interface+D'8', W, 1
0BEE  6E16      	MOVWF gbl_complete_serial_config_00000+D'17'
0BF0  51FA      	MOVF gbl_my_comm_interface+D'7', W, 1
0BF2  6E15      	MOVWF gbl_complete_serial_config_00000+D'16'
0BF4  51F9      	MOVF gbl_my_comm_interface+D'6', W, 1
0BF6  6E14      	MOVWF gbl_complete_serial_config_00000+D'15'
0BF8  51F8      	MOVF gbl_my_comm_interface+D'5', W, 1
0BFA  6E13      	MOVWF gbl_complete_serial_config_00000+D'14'
0BFC  51F7      	MOVF gbl_my_comm_interface+D'4', W, 1
0BFE  6E12      	MOVWF gbl_complete_serial_config_00000+D'13'
0C00  51F6      	MOVF gbl_my_comm_interface+D'3', W, 1
0C02  6E11      	MOVWF gbl_complete_serial_config_00000+D'12'
0C04  51F5      	MOVF gbl_my_comm_interface+D'2', W, 1
0C06  6E10      	MOVWF gbl_complete_serial_config_00000+D'11'
0C08  51F4      	MOVF gbl_my_comm_interface+D'1', W, 1
0C0A  6E0F      	MOVWF gbl_complete_serial_config_00000+D'10'
0C0C  51F3      	MOVF gbl_my_comm_interface, W, 1
0C0E  6E0E      	MOVWF gbl_complete_serial_config_00000+D'9'

	complete_serial_configuration.cdc_header = my_header;
0C10  505E      	MOVF gbl_my_header+D'4', W
0C12  6E1B      	MOVWF gbl_complete_serial_config_00000+D'22'
0C14  505D      	MOVF gbl_my_header+D'3', W
0C16  6E1A      	MOVWF gbl_complete_serial_config_00000+D'21'
0C18  505C      	MOVF gbl_my_header+D'2', W
0C1A  6E19      	MOVWF gbl_complete_serial_config_00000+D'20'
0C1C  505B      	MOVF gbl_my_header+D'1', W
0C1E  6E18      	MOVWF gbl_complete_serial_config_00000+D'19'
0C20  505A      	MOVF gbl_my_header, W
0C22  6E17      	MOVWF gbl_complete_serial_config_00000+D'18'

	complete_serial_configuration.cdc_ACM = my_ACM;
0C24  0102      	MOVLB 0x02
0C26  5133      	MOVF gbl_my_ACM+D'3', W, 1
0C28  6E1F      	MOVWF gbl_complete_serial_config_00000+D'26'
0C2A  5132      	MOVF gbl_my_ACM+D'2', W, 1
0C2C  6E1E      	MOVWF gbl_complete_serial_config_00000+D'25'
0C2E  5131      	MOVF gbl_my_ACM+D'1', W, 1
0C30  6E1D      	MOVWF gbl_complete_serial_config_00000+D'24'
0C32  5130      	MOVF gbl_my_ACM, W, 1
0C34  6E1C      	MOVWF gbl_complete_serial_config_00000+D'23'

	complete_serial_configuration.cdc_union = my_union;
0C36  0101      	MOVLB 0x01
0C38  51F8      	MOVF gbl_my_union+D'4', W, 1
0C3A  6E24      	MOVWF gbl_complete_serial_config_00000+D'31'
0C3C  51F7      	MOVF gbl_my_union+D'3', W, 1
0C3E  6E23      	MOVWF gbl_complete_serial_config_00000+D'30'
0C40  51F6      	MOVF gbl_my_union+D'2', W, 1
0C42  6E22      	MOVWF gbl_complete_serial_config_00000+D'29'
0C44  51F5      	MOVF gbl_my_union+D'1', W, 1
0C46  6E21      	MOVWF gbl_complete_serial_config_00000+D'28'
0C48  51F4      	MOVF gbl_my_union, W, 1
0C4A  6E20      	MOVWF gbl_complete_serial_config_00000+D'27'

	complete_serial_configuration.cdc_call_mgt = my_call_mgt;
0C4C  51FD      	MOVF gbl_my_call_mgt+D'4', W, 1
0C4E  6E29      	MOVWF gbl_complete_serial_config_00000+D'36'
0C50  51FC      	MOVF gbl_my_call_mgt+D'3', W, 1
0C52  6E28      	MOVWF gbl_complete_serial_config_00000+D'35'
0C54  51FB      	MOVF gbl_my_call_mgt+D'2', W, 1
0C56  6E27      	MOVWF gbl_complete_serial_config_00000+D'34'
0C58  51FA      	MOVF gbl_my_call_mgt+D'1', W, 1
0C5A  6E26      	MOVWF gbl_complete_serial_config_00000+D'33'
0C5C  51F9      	MOVF gbl_my_call_mgt, W, 1
0C5E  6E25      	MOVWF gbl_complete_serial_config_00000+D'32'

	complete_serial_configuration.cdc_notification_ep = my_notification_ep;
0C60  51E5      	MOVF gbl_my_notification_ep+D'6', W, 1
0C62  6E30      	MOVWF gbl_complete_serial_config_00000+D'43'
0C64  51E4      	MOVF gbl_my_notification_ep+D'5', W, 1
0C66  6E2F      	MOVWF gbl_complete_serial_config_00000+D'42'
0C68  51E3      	MOVF gbl_my_notification_ep+D'4', W, 1
0C6A  6E2E      	MOVWF gbl_complete_serial_config_00000+D'41'
0C6C  51E2      	MOVF gbl_my_notification_ep+D'3', W, 1
0C6E  6E2D      	MOVWF gbl_complete_serial_config_00000+D'40'
0C70  51E1      	MOVF gbl_my_notification_ep+D'2', W, 1
0C72  6E2C      	MOVWF gbl_complete_serial_config_00000+D'39'
0C74  51E0      	MOVF gbl_my_notification_ep+D'1', W, 1
0C76  6E2B      	MOVWF gbl_complete_serial_config_00000+D'38'
0C78  51DF      	MOVF gbl_my_notification_ep, W, 1
0C7A  6E2A      	MOVWF gbl_complete_serial_config_00000+D'37'

	complete_serial_configuration.cdc_data_interface = my_data_interface;
0C7C  519E      	MOVF gbl_my_data_interface+D'8', W, 1
0C7E  6E39      	MOVWF gbl_complete_serial_config_00000+D'52'
0C80  519D      	MOVF gbl_my_data_interface+D'7', W, 1
0C82  6E38      	MOVWF gbl_complete_serial_config_00000+D'51'
0C84  519C      	MOVF gbl_my_data_interface+D'6', W, 1
0C86  6E37      	MOVWF gbl_complete_serial_config_00000+D'50'
0C88  519B      	MOVF gbl_my_data_interface+D'5', W, 1
0C8A  6E36      	MOVWF gbl_complete_serial_config_00000+D'49'
0C8C  519A      	MOVF gbl_my_data_interface+D'4', W, 1
0C8E  6E35      	MOVWF gbl_complete_serial_config_00000+D'48'
0C90  5199      	MOVF gbl_my_data_interface+D'3', W, 1
0C92  6E34      	MOVWF gbl_complete_serial_config_00000+D'47'
0C94  5198      	MOVF gbl_my_data_interface+D'2', W, 1
0C96  6E33      	MOVWF gbl_complete_serial_config_00000+D'46'
0C98  5197      	MOVF gbl_my_data_interface+D'1', W, 1
0C9A  6E32      	MOVWF gbl_complete_serial_config_00000+D'45'
0C9C  5196      	MOVF gbl_my_data_interface, W, 1
0C9E  6E31      	MOVWF gbl_complete_serial_config_00000+D'44'

	complete_serial_configuration.cdc_data_out_ep = my_data_out_ep;
0CA0  51EC      	MOVF gbl_my_data_out_ep+D'6', W, 1
0CA2  6E40      	MOVWF gbl_complete_serial_config_00000+D'59'
0CA4  51EB      	MOVF gbl_my_data_out_ep+D'5', W, 1
0CA6  6E3F      	MOVWF gbl_complete_serial_config_00000+D'58'
0CA8  51EA      	MOVF gbl_my_data_out_ep+D'4', W, 1
0CAA  6E3E      	MOVWF gbl_complete_serial_config_00000+D'57'
0CAC  51E9      	MOVF gbl_my_data_out_ep+D'3', W, 1
0CAE  6E3D      	MOVWF gbl_complete_serial_config_00000+D'56'
0CB0  51E8      	MOVF gbl_my_data_out_ep+D'2', W, 1
0CB2  6E3C      	MOVWF gbl_complete_serial_config_00000+D'55'
0CB4  51E7      	MOVF gbl_my_data_out_ep+D'1', W, 1
0CB6  6E3B      	MOVWF gbl_complete_serial_config_00000+D'54'
0CB8  51E6      	MOVF gbl_my_data_out_ep, W, 1
0CBA  6E3A      	MOVWF gbl_complete_serial_config_00000+D'53'

	complete_serial_configuration.cdc_data_in_ep = my_data_in_ep;
0CBC  51F3      	MOVF gbl_my_data_in_ep+D'6', W, 1
0CBE  6E47      	MOVWF gbl_complete_serial_config_00000+D'66'
0CC0  51F2      	MOVF gbl_my_data_in_ep+D'5', W, 1
0CC2  6E46      	MOVWF gbl_complete_serial_config_00000+D'65'
0CC4  51F1      	MOVF gbl_my_data_in_ep+D'4', W, 1
0CC6  6E45      	MOVWF gbl_complete_serial_config_00000+D'64'
0CC8  51F0      	MOVF gbl_my_data_in_ep+D'3', W, 1
0CCA  6E44      	MOVWF gbl_complete_serial_config_00000+D'63'
0CCC  51EF      	MOVF gbl_my_data_in_ep+D'2', W, 1
0CCE  6E43      	MOVWF gbl_complete_serial_config_00000+D'62'
0CD0  51EE      	MOVF gbl_my_data_in_ep+D'1', W, 1
0CD2  6E42      	MOVWF gbl_complete_serial_config_00000+D'61'
0CD4  51ED      	MOVF gbl_my_data_in_ep, W, 1
0CD6  6E41      	MOVWF gbl_complete_serial_config_00000+D'60'

}
0CD8  0012      	RETURN




void usb_get_descriptor_callback(uns8 descriptor_type, uns8 descriptor_num,

                                 uns8 **rtn_descriptor_ptr, uns16 *rtn_descriptor_size) {

	uns8 *descriptor_ptr;
	uns16 descriptor_size;

	descriptor_ptr = (uns8 *) 0;	// this means we didn't find it
0228  6BAF      	CLRF usb_get_de_0005A_1_descrip_0005F, 1
022A  6BB0      	CLRF usb_get_de_0005A_1_descrip_0005F+D'1', 1

	switch (descriptor_type) {
		case dt_DEVICE:
022C  05A9      	DECF usb_get_de_0005A_arg_descr_0005B, W, 1
022E  E00C      	BZ	label20
0248            label20

			descriptor_ptr = (uns8 *)&my_device_descriptor;
0248  0E00      	MOVLW HIGH(gbl_my_device_descriptor+D'0')
024A  6FB3      	MOVWF CompTempVar2265, 1
024C  0E48      	MOVLW LOW(gbl_my_device_descriptor+D'0')
024E  6FAF      	MOVWF usb_get_de_0005A_1_descrip_0005F, 1
0250  51B3      	MOVF CompTempVar2265, W, 1
0252  6FB0      	MOVWF usb_get_de_0005A_1_descrip_0005F+D'1', 1

			descriptor_size = sizeof(my_device_descriptor);
0254  0E12      	MOVLW 0x12
0256  6FB1      	MOVWF usb_get_de_0005A_1_descrip_00060, 1
0258  6BB2      	CLRF usb_get_de_0005A_1_descrip_00060+D'1', 1

			break;
025A  D02F      	BRA	label26

		case dt_CONFIGURATION:
0230  0E02      	MOVLW 0x02
0232  63A9      	CPFSEQ usb_get_de_0005A_arg_descr_0005B, 1
0234  D001      	BRA	label18
0236  D012      	BRA	label21
0238            label18
0246  D039      	BRA	label26
025C            label21
027E  D014      	BRA	label25

			descriptor_ptr = (uns8 *) &complete_serial_configuration;
025C  0E00      	MOVLW HIGH(gbl_complete_serial_config_00000+D'0')
025E  6FB3      	MOVWF CompTempVar2266, 1
0260  0E05      	MOVLW LOW(gbl_complete_serial_config_00000+D'0')
0262  6FAF      	MOVWF usb_get_de_0005A_1_descrip_0005F, 1
0264  51B3      	MOVF CompTempVar2266, W, 1
0266  6FB0      	MOVWF usb_get_de_0005A_1_descrip_0005F+D'1', 1

			descriptor_size = sizeof(complete_serial_configuration);
0268  0E43      	MOVLW 0x43
026A  6FB1      	MOVWF usb_get_de_0005A_1_descrip_00060, 1
026C  6BB2      	CLRF usb_get_de_0005A_1_descrip_00060+D'1', 1

			break;
026E  D025      	BRA	label26

		case dt_STRING:
0238  0E03      	MOVLW 0x03
023A  63A9      	CPFSEQ usb_get_de_0005A_arg_descr_0005B, 1
023C  D001      	BRA	label19
023E  D018      	BRA	label22
0240            label19
0270            label22

			switch (descriptor_num) {
02BA            label26

				case 00:
0270  53AA      	MOVF usb_get_de_0005A_arg_descr_0005C, F, 1
0272  E006      	BZ	label23
0280            label23

					descriptor_size = sizeof(string_00);
0280  0E04      	MOVLW 0x04
0282  6FB1      	MOVWF usb_get_de_0005A_1_descrip_00060, 1
0284  6BB2      	CLRF usb_get_de_0005A_1_descrip_00060+D'1', 1

					descriptor_ptr = string_00;
0286  0E02      	MOVLW HIGH(gbl_string_00+D'0')
0288  6FB3      	MOVWF CompTempVar2267, 1
028A  0E34      	MOVLW LOW(gbl_string_00+D'0')
028C  6FAF      	MOVWF usb_get_de_0005A_1_descrip_0005F, 1
028E  51B3      	MOVF CompTempVar2267, W, 1
0290  6FB0      	MOVWF usb_get_de_0005A_1_descrip_0005F+D'1', 1

					break;
0292  D013      	BRA	label26

				case 01:
0274  05AA      	DECF usb_get_de_0005A_arg_descr_0005C, W, 1
0276  E00E      	BZ	label24
0294            label24

					descriptor_size = sizeof(MX_USBMFR);
0294  0E2E      	MOVLW 0x2E
0296  6FB1      	MOVWF usb_get_de_0005A_1_descrip_00060, 1
0298  6BB2      	CLRF usb_get_de_0005A_1_descrip_00060+D'1', 1

					descriptor_ptr = MX_USBMFR;
029A  0E01      	MOVLW HIGH(gbl_MX_USBMFR+D'0')
029C  6FB3      	MOVWF CompTempVar2268, 1
029E  0E40      	MOVLW LOW(gbl_MX_USBMFR+D'0')
02A0  6FAF      	MOVWF usb_get_de_0005A_1_descrip_0005F, 1
02A2  51B3      	MOVF CompTempVar2268, W, 1
02A4  6FB0      	MOVWF usb_get_de_0005A_1_descrip_0005F+D'1', 1

					break;
02A6  D009      	BRA	label26

				case 02:
0278  0E02      	MOVLW 0x02
027A  63AA      	CPFSEQ usb_get_de_0005A_arg_descr_0005C, 1
027C  D01E      	BRA	label26
02A8            label25

					descriptor_size = sizeof(MX_USBNAME);
02A8  0E28      	MOVLW 0x28
02AA  6FB1      	MOVWF usb_get_de_0005A_1_descrip_00060, 1
02AC  6BB2      	CLRF usb_get_de_0005A_1_descrip_00060+D'1', 1

					descriptor_ptr = MX_USBNAME;
02AE  0E01      	MOVLW HIGH(gbl_MX_USBNAME+D'0')
02B0  6FB3      	MOVWF CompTempVar2269, 1
02B2  0E6E      	MOVLW LOW(gbl_MX_USBNAME+D'0')
02B4  6FAF      	MOVWF usb_get_de_0005A_1_descrip_0005F, 1
02B6  51B3      	MOVF CompTempVar2269, W, 1
02B8  6FB0      	MOVWF usb_get_de_0005A_1_descrip_0005F+D'1', 1

					break;

			}
			break;
		case dt_DEVICE_QUALIFIER:
0240  0E06      	MOVLW 0x06
0242  63A9      	CPFSEQ usb_get_de_0005A_arg_descr_0005B, 1
0244  D03A      	BRA	label26

			// we don't hfandle this, send a stall
			break;
		default:

	}
	*rtn_descriptor_ptr = descriptor_ptr;
02BA  51AC      	MOVF usb_get_de_0005A_arg_rtn_d_0005D+D'1', W, 1
02BC  6EEA      	MOVWF FSR0H
02BE  51AB      	MOVF usb_get_de_0005A_arg_rtn_d_0005D, W, 1
02C0  6EE9      	MOVWF FSR0L
02C2  2AE9      	INCF FSR0L, F
02C4  51AF      	MOVF usb_get_de_0005A_1_descrip_0005F, W, 1
02C6  6FB3      	MOVWF CompTempVar2270, 1
02C8  51B0      	MOVF usb_get_de_0005A_1_descrip_0005F+D'1', W, 1
02CA  6EEF      	MOVWF INDF0
02CC  06E9      	DECF FSR0L, F
02CE  51B3      	MOVF CompTempVar2270, W, 1
02D0  6EEF      	MOVWF INDF0

	*rtn_descriptor_size = descriptor_size;
02D2  51AE      	MOVF usb_get_de_0005A_arg_rtn_d_0005E+D'1', W, 1
02D4  6EEA      	MOVWF FSR0H
02D6  51AD      	MOVF usb_get_de_0005A_arg_rtn_d_0005E, W, 1
02D8  6EE9      	MOVWF FSR0L
02DA  2AE9      	INCF FSR0L, F
02DC  51B1      	MOVF usb_get_de_0005A_1_descrip_00060, W, 1
02DE  6FB3      	MOVWF CompTempVar2271, 1
02E0  51B2      	MOVF usb_get_de_0005A_1_descrip_00060+D'1', W, 1
02E2  6EEF      	MOVWF INDF0
02E4  06E9      	DECF FSR0L, F
02E6  51B3      	MOVF CompTempVar2271, W, 1
02E8  6EEF      	MOVWF INDF0

}
02EA  0012      	RETURN


/*********************************************************************
 *                  Flowcode CAL ADC File
 *
 * File: PIC_CAL_ADC.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 060911 | BR | Created
 * 200911 | BR | Updated to include all ADC type files
 * 110512 | BR | Fixed a bug with ADC type 13 and Vref+
 */


//ADC Function Prototypes
void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
void FC_CAL_Disable_ADC (void);


//ADC Global Variables
MX_UINT8 old_tris, tris_mask;
MX_UINT8 * tris_reg;					//TRIS register pointer


// ADC Type 1 Supported Devices ************************************************************
// 16F818, 16F819, 16F873A, 16F874A, 16F876A, 16F877A,
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_1
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 2 Supported Devices ************************************************************
// 16F88
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_2
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG1);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel = 0x40;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 3 Supported Devices ************************************************************
// 16F616, 16F676, 16F677, 16F684, 16F685, 16F687, 16F688, 16F689, 16F690
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_3
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = ((Conv_Speed & 0x07) << 4);				//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}
#endif


// ADC Type 4 Supported Devices ************************************************************
// 16F737, 16F747, 16F767, 16F777
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_4
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					adcon1 = 0x01;
					break;
			#endif
		}

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6));					//turn ADC on
		adcon0 = adcon0 | ((Channel & 0x07) << 3);
		adcon0 = adcon0 | ((Channel & 0x08) >> 2);
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 5 Supported Devices ************************************************************
// 12F615, 12HV615, 12F675, 12F683
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_5
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					ansel = 0x08;
					break;
			#endif
		}

		ansel = ansel | ((Conv_Speed & 0x07) << 4);				//assign conversion speed

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 6 Supported Devices ************************************************************
// 16C72, 16C72A, 16CR72, 16F72, 16C73, 16C73A, 16C73B, 16F73, 16C74, 16C74A, 16C74B, 16F74,
// 16C76, 16F76, 16C77, 16F77, 16C716, 16F716
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_6
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 + 1;

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif



// ADC Type 7 Supported Devices ************************************************************
// 16F883, 16F884, 16F886, 16F887
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_7
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (13):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x20;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 2);	//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}
#endif


// ADC Type 8 Supported Devices ************************************************************
// 16F785
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_8
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel0 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel1 = 0x08;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel0 = 0x00;
		adcon0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}
#endif


// ADC Type 9 Supported Devices ************************************************************
// 16F913, 16F914, 16F916, 16F917, 16F946
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_9
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}
#endif


// ADC Type 10 Supported Devices ***********************************************************
// 12C671, 12C672, 12CE673, 12CE674
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_10
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					if (Vref == 0)
						adcon1 = 0x06;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 11 Supported Devices ***********************************************************
// 16C717, 16C770, 16C771
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_11
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADFM);

		if (Vref != 0)											//assign VREF functionality
		{
			st_bit(adcon1, VCFG0);
			st_bit(adcon1, VCFG1);
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}
#endif


// ADC Type 12 Supported Devices ***********************************************************
// 18F6310, 18F6390, 18F6410, 18F6490, 18F6520, 18F6527, 18F6585, 18F66J60, 18F66J65,
// 18F6620, 18F6622, 18F6627, 18F6680, 18F67J60, 18F6720, 18F6722, 18F8310, 18F8390,
// 18F8410, 18F8490, 18F8520, 18F8527, 18F8585, 18F86J60, 18F86J65, 18F8620, 18F8622,
// 18F8627, 18F8680, 18F87J60, 18F8720, 18F8722, 18F96J60, 18F96J65, 18F97J60
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_12
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 13 Supported Devices ***********************************************************
// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
// 18F4680, 18F4682, 18F4685
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_13
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);								//BR changed from adcon0 05/12

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
		  #ifdef MX_ADC_BITS_12
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		  #else
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		  #endif
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 14 Supported Devices ***********************************************************
// 18F2331, 18F2431, 18F4331, 18F4431
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_14
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;											//set up ADC conversion
		adcon2 = Conv_Speed & 0x07;
		adcon3 = 0x00;
		adchs = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon0 = 0x00;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon0 = 0x04;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon0 = 0x08;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon0 = 0x0C;
					ansel0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					adcon0 = 0x00;
					adchs = 0x01;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon0 = 0x04;
					adchs = 0x10;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon0 = 0x08;
					adchs = 0x04;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon0 = 0x0C;
					adchs = 0x40;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon0 = 0x00;
					adchs = 0x02;
					ansel1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = adcon0 | 0x01;									//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}
#endif


// ADC Type 15 Supported Devices ***********************************************************
// 18F1220, 18F1320
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_15
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x7E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x7D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x7B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x77;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x6F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x5F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x3F;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x7f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 16 Supported Devices ***********************************************************
// 18F242, 18F2439, 18F248, 18F252, 18F2539, 18F258, 18F442, 18F4439, 18F448, 18F452,
// 18F4539, 18F458
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_16
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x0A;
					else
						adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 17 Supported Devices ***********************************************************
// 18F1230, 18F1330
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_17
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;
		adcon1 = 0x00 | (0x01 << Channel);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x10;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x40;
					tris_reg = &trisa;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 18 Supported Devices ***********************************************************
// 16F722, 16F723, 16F724, 16F726, 16F727, 16F1933, 16F1934, 16F1936, 16F1937, 16F1939
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_18

	#ifndef ADREF1
		#define ADREF1 ADPREF1
	#endif

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 19 Supported Devices ***********************************************************
// 18F13K50, 18F14K50, 18LF13K50, 18LF14K50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_19
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)

	{
		adcon1 = 0;
0D72  6AC1      	CLRF gbl_adcon1


		switch (Channel)
0DA8            label92

		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
0D74  0E03      	MOVLW 0x03
0D76  636B      	CPFSEQ FC_CAL_Ena_00079_arg_Channel, 1
0D78  D001      	BRA	label89
0D7A  D004      	BRA	label90
0D7C            label89
0D82  D008      	BRA	label91
0D84            label90

					tris_mask = 0x10;
0D84  0E10      	MOVLW 0x10
0D86  6F66      	MOVWF gbl_tris_mask, 1

					tris_reg = &trisa;
0D88  0E0F      	MOVLW HIGH(gbl_trisa+D'0')
0D8A  6F49      	MOVWF gbl_tris_reg+D'1', 1
0D8C  0E92      	MOVLW LOW(gbl_trisa+D'0')
0D8E  6F48      	MOVWF gbl_tris_reg, 1

					ansel = 0x08;
0D90  0E08      	MOVLW 0x08
0D92  6E7E      	MOVWF gbl_ansel

			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
0D7C  0E04      	MOVLW 0x04
0D7E  636B      	CPFSEQ FC_CAL_Ena_00079_arg_Channel, 1
0D80  D013      	BRA	label92
0D94            label91

					tris_mask = 0x01;
0D94  0E01      	MOVLW 0x01
0D96  6F66      	MOVWF gbl_tris_mask, 1

					tris_reg = &trisc;
0D98  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
0D9A  6F6F      	MOVWF CompTempVar2317, 1
0D9C  0E94      	MOVLW LOW(gbl_trisc+D'0')
0D9E  6F48      	MOVWF gbl_tris_reg, 1
0DA0  516F      	MOVF CompTempVar2317, W, 1
0DA2  6F49      	MOVWF gbl_tris_reg+D'1', 1

					ansel = 0x10;
0DA4  0E10      	MOVLW 0x10
0DA6  6E7E      	MOVWF gbl_ansel

					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate
0DA8  0E07      	MOVLW 0x07
0DAA  156C      	ANDWF FC_CAL_Ena_00079_arg_Conv_Speed, W, 1
0DAC  6EC0      	MOVWF gbl_adcon2


		if (Vref != 0)											//assign VREF functionality
0DAE  536D      	MOVF FC_CAL_Ena_00079_arg_Vref, F, 1
0DB0  A4D8      	BTFSS STATUS,Z

			st_bit(adcon1, PVCFG0);
0DB2  84C1      	BSF gbl_adcon1,2


		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
0DB4  5149      	MOVF gbl_tris_reg+D'1', W, 1
0DB6  6EEA      	MOVWF FSR0H
0DB8  5148      	MOVF gbl_tris_reg, W, 1
0DBA  6EE9      	MOVWF FSR0L
0DBC  50EF      	MOVF INDF0, W
0DBE  6F65      	MOVWF gbl_old_tris, 1

		*tris_reg = old_tris | tris_mask;
0DC0  5166      	MOVF gbl_tris_mask, W, 1
0DC2  1165      	IORWF gbl_old_tris, W, 1
0DC4  6F6F      	MOVWF CompTempVar2318, 1
0DC6  6EEF      	MOVWF INDF0

		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
0DC8  516B      	MOVF FC_CAL_Ena_00079_arg_Channel, W, 1
0DCA  6F6F      	MOVWF CompTempVar2319, 1
0DCC  376F      	RLCF CompTempVar2319, F, 1
0DCE  376F      	RLCF CompTempVar2319, F, 1
0DD0  0EFC      	MOVLW 0xFC
0DD2  156F      	ANDWF CompTempVar2319, W, 1
0DD4  0901      	IORLW 0x01
0DD6  6EC2      	MOVWF gbl_adcon0

		delay_us(T_Charge);										//wait the acquisition time
0DD8  516E      	MOVF FC_CAL_Ena_00079_arg_T_Charge, W, 1
0DDA  6F6F      	MOVWF delay_us_00000_arg_del, 1
0DDC  EC06F000  	CALL delay_us_00000

	}
0DE0  0012      	RETURN


	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)

	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
0D30  0E02      	MOVLW 0x02
0D32  10C2      	IORWF gbl_adcon0, W
0D34  6EC2      	MOVWF gbl_adcon0

		while (adcon0 & 0x02);
0D36            label86
0D36  B2C2      	BTFSC gbl_adcon0,1
0D38  D7FE      	BRA	label86

		if (Sample_Mode)
0D3A  536B      	MOVF FC_CAL_Sam_0007A_arg_Sample_Mode, F, 1
0D3C  E012      	BZ	label87
0D62            label87

		{
			iRetVal = (adresh << 2);							//10-bit ADC
0D3E  50C4      	MOVF gbl_adresh, W
0D40  6F6C      	MOVWF FC_CAL_Sam_0007A_1_iRetVal, 1
0D42  6B6D      	CLRF FC_CAL_Sam_0007A_1_iRetVal+D'1', 1
0D44  376C      	RLCF FC_CAL_Sam_0007A_1_iRetVal, F, 1
0D46  376D      	RLCF FC_CAL_Sam_0007A_1_iRetVal+D'1', F, 1
0D48  376C      	RLCF FC_CAL_Sam_0007A_1_iRetVal, F, 1
0D4A  376D      	RLCF FC_CAL_Sam_0007A_1_iRetVal+D'1', F, 1
0D4C  0EFC      	MOVLW 0xFC
0D4E  176C      	ANDWF FC_CAL_Sam_0007A_1_iRetVal, F, 1

			iRetVal = iRetVal | (adresl >> 6);
0D50  30C3      	RRCF gbl_adresl, W
0D52  6F6E      	MOVWF CompTempVar2323, 1
0D54  336E      	RRCF CompTempVar2323, F, 1
0D56  3B6E      	SWAPF CompTempVar2323, F, 1
0D58  0E03      	MOVLW 0x03
0D5A  156E      	ANDWF CompTempVar2323, W, 1
0D5C  136C      	IORWF FC_CAL_Sam_0007A_1_iRetVal, F, 1
0D5E  536D      	MOVF FC_CAL_Sam_0007A_1_iRetVal+D'1', F, 1

		}
		else
0D60  D003      	BRA	label88
0D68            label88

			iRetVal = adresh;									//8-bit ADC
0D62  50C4      	MOVF gbl_adresh, W
0D64  6F6C      	MOVWF FC_CAL_Sam_0007A_1_iRetVal, 1
0D66  6B6D      	CLRF FC_CAL_Sam_0007A_1_iRetVal+D'1', 1


		return (iRetVal);
0D68  516C      	MOVF FC_CAL_Sam_0007A_1_iRetVal, W, 1
0D6A  6F6E      	MOVWF CompTempVarRet2320, 1
0D6C  516D      	MOVF FC_CAL_Sam_0007A_1_iRetVal+D'1', W, 1
0D6E  6F6F      	MOVWF CompTempVarRet2320+D'1', 1

	}
0D70  0012      	RETURN


	void FC_CAL_Disable_ADC ()

	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
0DE2  0102      	MOVLB 0x02
0DE4  5149      	MOVF gbl_tris_reg+D'1', W, 1
0DE6  6EEA      	MOVWF FSR0H
0DE8  5148      	MOVF gbl_tris_reg, W, 1
0DEA  6EE9      	MOVWF FSR0L
0DEC  5165      	MOVF gbl_old_tris, W, 1
0DEE  6EEF      	MOVWF INDF0

		ansel = 0;
0DF0  6A7E      	CLRF gbl_ansel

		adcon0 = 0x00;
0DF2  6AC2      	CLRF gbl_adcon0

		#ifdef ANSELH
			anselh = 0;
0DF4  6A7F      	CLRF gbl_anselh

		#endif
	}
0DF6  0012      	RETURN

#endif


// ADC Type 20 Supported Devices ***********************************************************
// 18F23K20, 18F24K20, 18F25K20, 18F26K20, 18F43K20, 18F44K20, 18F45K20, 18F16K20
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_20
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}
#endif


// ADC Type 21 Supported Devices ***********************************************************
// 18F2xJ11, 18F4xJ11
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_21
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0xFE;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0xFD;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0xFB;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0xF7;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0xEF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ancon0 = 0xDF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ancon0 = 0xBF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ancon0 = 0x7F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ancon1 = 0x1E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ancon1 = 0x1D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ancon1 = 0x1B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ancon1 = 0x17;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ancon1 = 0x0F;
					break;
			#endif
		}

		adcon1 = Conv_Speed & 0x07;								//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0xFF;
		ancon1 = 0x1F;
		adcon0 = 0x00;
	}
#endif


// ADC Type 22 Supported Devices ***********************************************************
// 10F220, 10F222
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_22
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon0 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					asm("movf 1,w");
					asm("tris 6");
					adcon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					asm("movf 2,w");
					asm("tris 6");
					adcon0 = 0x84;
					break;
			#endif
		}

		adcon0 = adcon0 | 0x01;									//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
			iRetVal = (adres << 2);								//10-bit ADC
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		adcon0 = 0x00;											//Reset ADC Registers
	}
#endif


// ADC Type 23 Supported Devices ***********************************************************
// 16F1826, 16F1827
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_23

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x80;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 24 Supported Devices ***********************************************************
// 18F65J50, 18F66J50, 18F66J55, 18F67J50, 18F85J50, 18F86J50, 18F86J55, 18F87J50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_24
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0x00;
		ancon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 25 Supported Devices ***********************************************************
// 18F66J93, 18F67J93, 18F86J93, 18F87J93, 18F66J90, 18F67J90, 18F86J90, 18F87J90
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_25
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 26 Supported Devices ***********************************************************
// 16F1822, 16F1823, 16F1824, 16F1825, 16F1828, 16F1829
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_26

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 27 Supported Devices ***********************************************************
// 16F1946, 16F1947
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_27

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (11):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (11):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (11):
					tris_mask = 0x01;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 28 Supported Devices ***********************************************************
// 18F65K22, 18F66K22, 18F67K22, 18F85K22, 18F86K22, 18F87K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_28
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ancon0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ancon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ancon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ancon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ancon2 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ancon2 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ancon2 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ancon2 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x08;
					tris_reg = &trish;
					ancon2 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x04;
					tris_reg = &trish;
					ancon2 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x02;
					tris_reg = &trish;
					ancon2 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x01;
					tris_reg = &trish;
					ancon2 = 0x80;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ancon0 = 0x00;
		#ifdef ANCON1
			ancon1 = 0x00;
		#endif
		#ifdef ANCON2
			ancon2 = 0x00;
		#endif
	}
#endif


// ADC Type 29 Supported Devices ***********************************************************
// 18F23K22, 18F24K22, 18F25K22, 18F26K22, 18F43K22, 18F44K22, 18F45K22, 18F46K22,
// 18LF23K22, 18LF24K22, 18LF25K22, 18LF26K22, 18LF43K22, 18LF44K22, 18LF45K22, 18LF46K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_29

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x20;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x01;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x02;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x04;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x08;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_24
				case (24):
					tris_mask = 0x10;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_25
				case (25):
					tris_mask = 0x20;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_26
				case (26):
					tris_mask = 0x40;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_27
				case (27):
					tris_mask = 0x80;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, PVCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = ansel_reg | tris_mask;

		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 30 Supported Devices ************************************************************
// 16F870, 16F871, 16F872, 16F873, 16F874, 16F876, 16F877
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_30
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 31 Supported Devices ************************************************************
// 12F510, 16F506
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_31
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon0 = (0xC1 | (Conv_Speed << 4) | (Channel << 2));	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);

		iRetVal = adres;										//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		adcon0 = 0x00;
	}
#endif


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EFF0F007  	GOTO	_startup

0008  EF0CF009  	GOTO	interrupt
000C            delay_us_00000
000C            ; { delay_us ; function begin
000C            label1
000C  2F6F      	DECFSZ delay_us_00000_arg_del, F, 1
000E  D7FE      	BRA	label1
0010  0012      	RETURN
0012            ; } delay_us function end

0012            delay_ms_00000
0012            ; { delay_ms ; function begin
0012  536E      	MOVF delay_ms_00000_arg_del, F, 1
0014  0000      	NOP
0016  E101      	BNZ	label2
0018  0012      	RETURN
001A            label2
001A  0EF9      	MOVLW 0xF9
001C            label3
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0FFF      	ADDLW 0xFF
002E  A4D8      	BTFSS STATUS,Z
0030  D7F5      	BRA	label3
0032  0000      	NOP
0034  0000      	NOP
0036  0000      	NOP
0038  0000      	NOP
003A  0000      	NOP
003C  0000      	NOP
003E  0000      	NOP
0040  0000      	NOP
0042  0000      	NOP
0044  2F6E      	DECFSZ delay_ms_00000_arg_del, F, 1
0046  D7E9      	BRA	label2
0048  0012      	RETURN
004A            ; } delay_ms function end


044A            memcpy8_00000
044A            ; { memcpy8 ; function begin
044A  517D      	MOVF memcpy8_00000_arg_dst, W, 1
044C  6FAA      	MOVWF memcpy8_00000_1_dst2, 1
044E  517E      	MOVF memcpy8_00000_arg_dst+D'1', W, 1
0450  6FAB      	MOVWF memcpy8_00000_1_dst2+D'1', 1
0452  51A8      	MOVF memcpy8_00000_arg_src, W, 1
0454  6FAC      	MOVWF memcpy8_00000_1_src2, 1
0456  51A9      	MOVF memcpy8_00000_arg_src+D'1', W, 1
0458  6FAD      	MOVWF memcpy8_00000_1_src2+D'1', 1
045A            label35
045A  0E00      	MOVLW 0x00
045C  657F      	CPFSGT memcpy8_00000_arg_len, 1
045E  D012      	BRA	label36
0460  51AD      	MOVF memcpy8_00000_1_src2+D'1', W, 1
0462  6EEA      	MOVWF FSR0H
0464  51AC      	MOVF memcpy8_00000_1_src2, W, 1
0466  6EE9      	MOVWF FSR0L
0468  4BAC      	INFSNZ memcpy8_00000_1_src2, F, 1
046A  2BAD      	INCF memcpy8_00000_1_src2+D'1', F, 1
046C  50EF      	MOVF INDF0, W
046E  6FAE      	MOVWF CompTempVar413, 1
0470  51AB      	MOVF memcpy8_00000_1_dst2+D'1', W, 1
0472  6EEA      	MOVWF FSR0H
0474  51AA      	MOVF memcpy8_00000_1_dst2, W, 1
0476  6EE9      	MOVWF FSR0L
0478  4BAA      	INFSNZ memcpy8_00000_1_dst2, F, 1
047A  2BAB      	INCF memcpy8_00000_1_dst2+D'1', F, 1
047C  51AE      	MOVF CompTempVar413, W, 1
047E  6EEF      	MOVWF INDF0
0480  077F      	DECF memcpy8_00000_arg_len, F, 1
0482  D7EB      	BRA	label35
0484            label36
0484  517D      	MOVF memcpy8_00000_arg_dst, W, 1
0486  6FAE      	MOVWF CompTempVarRet412, 1
0488  517E      	MOVF memcpy8_00000_arg_dst+D'1', W, 1
048A  6FAF      	MOVWF CompTempVarRet412+D'1', 1
048C  0012      	RETURN
048E            ; } memcpy8 function end


0FE0            _startup
0FE0  0ED5      	MOVLW 0xD5
0FE2  0100      	MOVLB 0x00
0FE4  6FFC      	MOVWF gbl_14_LSR, 1
0FE6  0EC4      	MOVLW 0xC4
0FE8  6FFD      	MOVWF gbl_14_LSR+D'1', 1
0FEA  0EBB      	MOVLW 0xBB
0FEC  6FFE      	MOVWF gbl_14_LSR+D'2', 1
0FEE  0EDC      	MOVLW 0xDC
0FF0  6FFF      	MOVWF gbl_14_LSR+D'3', 1
0FF2  0102      	MOVLB 0x02
0FF4  6B20      	CLRF gbl_15_gbl_aSig, 1
0FF6  6B21      	CLRF gbl_15_gbl_aSig+D'1', 1
0FF8  6B22      	CLRF gbl_15_gbl_aSig+D'2', 1
0FFA  6B23      	CLRF gbl_15_gbl_aSig+D'3', 1
0FFC  6B24      	CLRF gbl_15_gbl_bSig, 1
0FFE  6B25      	CLRF gbl_15_gbl_bSig+D'1', 1
1000  6B26      	CLRF gbl_15_gbl_bSig+D'2', 1
1002  6B27      	CLRF gbl_15_gbl_bSig+D'3', 1
1004  6B28      	CLRF gbl_15_gbl_zSig, 1
1006  6B29      	CLRF gbl_15_gbl_zSig+D'1', 1
1008  6B2A      	CLRF gbl_15_gbl_zSig+D'2', 1
100A  6B2B      	CLRF gbl_15_gbl_zSig+D'3', 1
100C  6B4C      	CLRF gbl_15_gbl_aExp, 1
100E  6B4D      	CLRF gbl_15_gbl_bExp, 1
1010  0101      	MOVLB 0x01
1012  6BFE      	CLRF gbl_15_gbl_zExp, 1
1014  6BFF      	CLRF gbl_15_gbl_zExp+D'1', 1
1016  0102      	MOVLB 0x02
1018  6B4E      	CLRF gbl_15_gbl_aSign, 1
101A  6B4F      	CLRF gbl_15_gbl_bSign, 1
101C  6B50      	CLRF gbl_15_gbl_zSign, 1
101E  6B51      	CLRF gbl_15_gbl_zSigZero, 1
1020  6B2C      	CLRF gbl_15_gbl_ret, 1
1022  6B2D      	CLRF gbl_15_gbl_ret+D'1', 1
1024  6B2E      	CLRF gbl_15_gbl_ret+D'2', 1
1026  6B2F      	CLRF gbl_15_gbl_ret+D'3', 1
1028  6B4A      	CLRF gbl_float_rounding_mode, 1
102A  6B4B      	CLRF gbl_float_exception_flags, 1
102C  6A5F      	CLRF gbl_float_detect_tininess

1214  EFC2F007  	GOTO	main

300000  3238      	DW 0x3238
300002  1E1F      	DW 0x1E1F
300004  08FF      	DW 0x08FF
300006  FF88      	DW 0xFF88
300008  C003      	DW 0xC003
30000A  E003      	DW 0xE003
30000C  4003      	DW 0x4003
