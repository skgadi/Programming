;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

// Delay by bytes
#define FCI_DELAYBYTE_S(count)     delay_s((count))
#define FCI_DELAYBYTE_MS(count)    delay_ms((count))
#define FCI_DELAYBYTE_US(count)    delay_us((count))
// With watchdog timer
#define FCI_DELAYBYTEWDT_S(count)  Wdt_Delay_S((count))
#define FCI_DELAYBYTEWDT_MS(count) Wdt_Delay_Ms((count))
#define FCI_DELAYBYTEWDT_US(count) delay_us((count))

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)

{
    char i;
    for (i=0; i<delay; i++)
0DFC  6B5C      	CLRF Wdt_Delay__00036_1_i, 1
0DFE            label123
0DFE  515B      	MOVF Wdt_Delay__00036_arg_delay, W, 1
0E00  615C      	CPFSLT Wdt_Delay__00036_1_i, 1
0E0E  2B5C      	INCF Wdt_Delay__00036_1_i, F, 1
0E10  D7F6      	BRA	label123

    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
0E04  0004      	CLRWDT

        delay_ms(1);
0E06  0E01      	MOVLW 0x01
0E08  6F5D      	MOVWF delay_ms_00000_arg_del, 1
0E0A  EC09F000  	CALL delay_ms_00000

    }
}
0E02  0012      	RETURN



void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
0F52  6B63      	CLRF FCI_GETLEN_0003D_1_tmp, 1
0F54            label140
0F54  5162      	MOVF FCI_GETLEN_0003D_arg_iStr1_len, W, 1
0F56  6163      	CPFSLT FCI_GETLEN_0003D_1_tmp, 1
0F58  D009      	BRA	label141
0F5A  5161      	MOVF FCI_GETLEN_0003D_arg_sStr1+D'1', W, 1
0F5C  6EEA      	MOVWF FSR0H
0F5E  5160      	MOVF FCI_GETLEN_0003D_arg_sStr1, W, 1
0F60  2563      	ADDWF FCI_GETLEN_0003D_1_tmp, W, 1
0F62  6EE9      	MOVWF FSR0L
0F64  52EF      	MOVF INDF0, F
0F66  E002      	BZ	label141
0F68  2B63      	INCF FCI_GETLEN_0003D_1_tmp, F, 1
0F6A  D7F4      	BRA	label140
0F6C            label141

	return (tmp);
0F6C  5163      	MOVF FCI_GETLEN_0003D_1_tmp, W, 1
0F6E  6F64      	MOVWF CompTempVarRet1856, 1

}
0F70  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;

	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;

	if (iDst_len == 0) return sDst;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (sDst);
}



void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len, strt;

  len = 0;
  if (sSrc2 == sDst)
  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
    if (strt < iDst_len)
    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
      if (len > (iDst_len - strt))
      {
        len = (iDst_len - strt); // Length of string to copy to
      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
      strt = len;
      while (strt > 0)
      {
        strt--;
        iSrc2_len--;
        sDst[iSrc2_len] = sSrc2[strt];
      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
      len += strt;
    }
    else
    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    // Copy second
    if (len < iDst_len)
    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
      iSrc1_len = iDst_len - len;
      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
      len += strt;
    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}


/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}




//************************************************************************************
//**  
//**  Source name:   D:\GitHub\Programming\Flowcode\DAQCard\Ver001.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F14K50
//**  
//**  Generated by:  Flowcode v6.1.3.2
//**  Date:          Wednesday, February 15, 2017 16:30:24
//**  Users:         -1
//**  Registered to: 88263627
//**  Licence key:   K38DMR
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 12000000
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0x38
#endif
#ifdef HI_TECH_C
__CONFIG(0x38);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0x1F
#endif
#ifdef HI_TECH_C
__CONFIG(0x1F);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0x1E
#endif
#ifdef HI_TECH_C
__CONFIG(0x1E);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0x8
#endif
#ifdef HI_TECH_C
__CONFIG(0x8);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x88
#endif
#ifdef HI_TECH_C
__CONFIG(0x88);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0x3
#endif
#ifdef HI_TECH_C
__CONFIG(0x3);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xC0
#endif
#ifdef HI_TECH_C
__CONFIG(0xC0);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0x3
#endif
#ifdef HI_TECH_C
__CONFIG(0x3);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xE0
#endif
#ifdef HI_TECH_C
__CONFIG(0xE0);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"

MX_UINT8 FCLV_LOOP1;


/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_OUTSTRING 2
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_OUTSTR;
MX_GLOBAL MX_UINT8 FCV_OPERATION;
MX_GLOBAL MX_UINT16 FCV_READINPUT;
MX_GLOBAL MX_CHAR FCV_OUTSTRING[FCVsz_OUTSTRING];


/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :dash_scale_vert1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII6
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII7
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII5
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII4
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII3
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII2
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII0
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1


/*========================================================================*\
   Use :PWM_Digital
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_0ba71_PWM_Digital__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_pwm
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define MX_PWM_REF1 
#define MX_PWM_PRESCALE1 (1)
#define MX_PWM_PIN_1 (5)
#define MX_PWM_PORT_1 portc
#define MX_PWM_PERIOD 255
#define MX_PWM_TRIS_1 trisc
#define MX_PWM_CHANNEL_1 (1)


/*=----------------------------------------------------------------------=*\
   Use :cal_pwm
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_PWM
#define MX_PWM_TMR_1 2

void FC_CAL_PWM_ChangePeriod_1(MX_UINT16 FCL_PERIOD, MX_UINT16 FCL_PRESCALER);
void FC_CAL_PWM_Disable_1();
void FC_CAL_PWM_SetDuty8Bit_1(MX_UINT8 FCL_DUTY);
void FC_CAL_PWM_Enable_1();
void FC_CAL_PWM_SetDuty10Bit_1(MX_UINT16 FCL_DUTY);

/*========================================================================*\
   Use :PWM1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_0df41_PWM1__ENABLED = (0x0);
1232  6B41      	CLRF gbl_FCV_0df41_PWM1__ENABLED, 1


void FCD_0df41_PWM1__ChangePeriod(MX_UINT16 FCL_PERIOD, MX_SINT16 FCL_PRESCALER);
void FCD_0df41_PWM1__Disable();
void FCD_0df41_PWM1__SetDutyCycle(MX_UINT8 FCL_DUTY);
void FCD_0df41_PWM1__Enable();
void FCD_0df41_PWM1__SetDutyCycle10Bit(MX_UINT16 FCL_DUTY);

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define ADC_2_MX_ADC_ACTIME 40
#define MX_ADC_REF 
#define ADC_2_MX_ADC_VREFVOL 500
#define MX_ADC_CHANNEL_8 
#define MX_ADC_TYPE_19 
#define ADC_2_MX_ADC_VREFOP 0
#define ADC_2_MX_ADC_CONVSP 3
#define MX_ADC_BITS_10 
#define ADC_2_MX_ADC_CHANNEL 8

#define FCV_0aae2_cal_adc__FALSE (0)
#define FCV_0aae2_cal_adc__TRUE (1)

void FC_CAL_ADC_Disable();
void FC_CAL_ADC_Enable(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_CAL_ADC_Sample(MX_UINT8 FCL_SAMPLE_MODE);

/*========================================================================*\
   Use :adc_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT16 FCD_08f42_adc_base__RawSampleInt();
MX_UINT8 FCD_08f42_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_08f42_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08f42_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_08f42_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_08f42_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_08f42_adc_base__GetVoltage();
void FCD_08f42_adc_base__RawEnable();
MX_UINT8 FCD_08f42_adc_base__RawSampleByte();
MX_UINT16 FCD_08f42_adc_base__GetInt();
void FCD_08f42_adc_base__RawDisable();
MX_UINT8 FCD_08f42_adc_base__GetByte();

/*========================================================================*\
   Use :v5__adc1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_03522_v5__adc1__RawSampleInt FCD_08f42_adc_base__RawSampleInt
#define FCD_03522_v5__adc1__RawAverageByte FCD_08f42_adc_base__RawAverageByte
#define FCD_03522_v5__adc1__GetString FCD_08f42_adc_base__GetString
#define FCD_03522_v5__adc1__GetAverageByte FCD_08f42_adc_base__GetAverageByte
#define FCD_03522_v5__adc1__RawAverageInt FCD_08f42_adc_base__RawAverageInt
#define FCD_03522_v5__adc1__GetAverageInt FCD_08f42_adc_base__GetAverageInt
#define FCD_03522_v5__adc1__GetVoltage FCD_08f42_adc_base__GetVoltage
#define FCD_03522_v5__adc1__RawEnable FCD_08f42_adc_base__RawEnable
#define FCD_03522_v5__adc1__RawSampleByte FCD_08f42_adc_base__RawSampleByte
#define FCD_03522_v5__adc1__GetInt FCD_08f42_adc_base__GetInt
#define FCD_03522_v5__adc1__RawDisable FCD_08f42_adc_base__RawDisable
#define FCD_03522_v5__adc1__GetByte FCD_08f42_adc_base__GetByte

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define ADC_1_MX_ADC_ACTIME 40
#define MX_ADC_REF 
#define ADC_1_MX_ADC_VREFVOL 500
#define MX_ADC_CHANNEL_7 
#define MX_ADC_TYPE_19 
#define ADC_1_MX_ADC_VREFOP 0
#define ADC_1_MX_ADC_CONVSP 3
#define MX_ADC_BITS_10 
#define ADC_1_MX_ADC_CHANNEL 7

#define FCV_0aae1_cal_adc__FALSE (0)
#define FCV_0aae1_cal_adc__TRUE (1)

void FC_CAL_ADC_Disable();
void FC_CAL_ADC_Enable(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_CAL_ADC_Sample(MX_UINT8 FCL_SAMPLE_MODE);

/*========================================================================*\
   Use :adc_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT16 FCD_08f41_adc_base__RawSampleInt();
MX_UINT8 FCD_08f41_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_08f41_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08f41_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_08f41_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_08f41_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_08f41_adc_base__GetVoltage();
void FCD_08f41_adc_base__RawEnable();
MX_UINT8 FCD_08f41_adc_base__RawSampleByte();
MX_UINT16 FCD_08f41_adc_base__GetInt();
void FCD_08f41_adc_base__RawDisable();
MX_UINT8 FCD_08f41_adc_base__GetByte();

/*========================================================================*\
   Use :v5__adc0
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_03521_v5__adc0__RawSampleInt FCD_08f41_adc_base__RawSampleInt
#define FCD_03521_v5__adc0__RawAverageByte FCD_08f41_adc_base__RawAverageByte
#define FCD_03521_v5__adc0__GetString FCD_08f41_adc_base__GetString
#define FCD_03521_v5__adc0__GetAverageByte FCD_08f41_adc_base__GetAverageByte
#define FCD_03521_v5__adc0__RawAverageInt FCD_08f41_adc_base__RawAverageInt
#define FCD_03521_v5__adc0__GetAverageInt FCD_08f41_adc_base__GetAverageInt
#define FCD_03521_v5__adc0__GetVoltage FCD_08f41_adc_base__GetVoltage
#define FCD_03521_v5__adc0__RawEnable FCD_08f41_adc_base__RawEnable
#define FCD_03521_v5__adc0__RawSampleByte FCD_08f41_adc_base__RawSampleByte
#define FCD_03521_v5__adc0__GetInt FCD_08f41_adc_base__GetInt
#define FCD_03521_v5__adc0__RawDisable FCD_08f41_adc_base__RawDisable
#define FCD_03521_v5__adc0__GetByte FCD_08f41_adc_base__GetByte

/*========================================================================*\
   Use :dash_IO_flasher1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :COMPort
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :v5__usbserial0
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define dev_name 40,3,'F',0,'l',0,'o',0,'w',0,'c',0,'o',0,'d',0,'e',0,' ',0,'U',0,'S',0,'B',0,' ',0,'S',0,'e',0,'r',0,'i',0,'a',0,'l',0
#define dev_name_count 40
#define dev_name_DS 'F','l','o','w','c','o','d','e',' ','U','S','B',' ','S','e','r','i','a','l'
#define dev_name_count_DS 19
#define MX_USB_TYPE3
#define timeout 10
#define RX_BUF_SZ (64)
#define MX_VID 4799
#define enumeration_tout 0
#define TX_BUF_SZ (64)
#define major_version 1
#define MX_PID 61456
#define dev_manufacturer 46,3,'M',0,'a',0,'t',0,'r',0,'i',0,'x',0,' ',0,'M',0,'u',0,'l',0,'t',0,'i',0,'m',0,'e',0,'d',0,'i',0,'a',0,' ',0,'L',0,'t',0,'d',0,'.',0
#define dev_manufacturer_count 46
#define dev_manufacturer_DS 'M','a','t','r','i','x',' ','M','u','l','t','i','m','e','d','i','a',' ','L','t','d','.'
#define dev_manufacturer_count_DS 22
#define minor_version 0


/*=----------------------------------------------------------------------=*\
   Use :v5__usbserial0
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_VERSION ((major_version << 8) | minor_version)

#ifdef MX_CAL_PIC							//8-bit PIC specific

	MX_UINT8 MX_USBNAME[dev_name_count] = {dev_name};		                    //Device name
1234  0E28      	MOVLW 0x28
1236  0101      	MOVLB 0x01
1238  6F6E      	MOVWF gbl_MX_USBNAME, 1
123A  0E03      	MOVLW 0x03
123C  6F6F      	MOVWF gbl_MX_USBNAME+D'1', 1
123E  0E46      	MOVLW 0x46
1240  6F70      	MOVWF gbl_MX_USBNAME+D'2', 1
1242  6B71      	CLRF gbl_MX_USBNAME+D'3', 1
1244  0E6C      	MOVLW 0x6C
1246  6F72      	MOVWF gbl_MX_USBNAME+D'4', 1
1248  6B73      	CLRF gbl_MX_USBNAME+D'5', 1
124A  0E6F      	MOVLW 0x6F
124C  6F74      	MOVWF gbl_MX_USBNAME+D'6', 1
124E  6B75      	CLRF gbl_MX_USBNAME+D'7', 1
1250  0E77      	MOVLW 0x77
1252  6F76      	MOVWF gbl_MX_USBNAME+D'8', 1
1254  6B77      	CLRF gbl_MX_USBNAME+D'9', 1
1256  0E63      	MOVLW 0x63
1258  6F78      	MOVWF gbl_MX_USBNAME+D'10', 1
125A  6B79      	CLRF gbl_MX_USBNAME+D'11', 1
125C  0E6F      	MOVLW 0x6F
125E  6F7A      	MOVWF gbl_MX_USBNAME+D'12', 1
1260  6B7B      	CLRF gbl_MX_USBNAME+D'13', 1
1262  0E64      	MOVLW 0x64
1264  6F7C      	MOVWF gbl_MX_USBNAME+D'14', 1
1266  6B7D      	CLRF gbl_MX_USBNAME+D'15', 1
1268  0E65      	MOVLW 0x65
126A  6F7E      	MOVWF gbl_MX_USBNAME+D'16', 1
126C  6B7F      	CLRF gbl_MX_USBNAME+D'17', 1
126E  0E20      	MOVLW 0x20
1270  6F80      	MOVWF gbl_MX_USBNAME+D'18', 1
1272  6B81      	CLRF gbl_MX_USBNAME+D'19', 1
1274  0E55      	MOVLW 0x55
1276  6F82      	MOVWF gbl_MX_USBNAME+D'20', 1
1278  6B83      	CLRF gbl_MX_USBNAME+D'21', 1
127A  0E53      	MOVLW 0x53
127C  6F84      	MOVWF gbl_MX_USBNAME+D'22', 1
127E  6B85      	CLRF gbl_MX_USBNAME+D'23', 1
1280  0E42      	MOVLW 0x42
1282  6F86      	MOVWF gbl_MX_USBNAME+D'24', 1
1284  6B87      	CLRF gbl_MX_USBNAME+D'25', 1
1286  0E20      	MOVLW 0x20
1288  6F88      	MOVWF gbl_MX_USBNAME+D'26', 1
128A  6B89      	CLRF gbl_MX_USBNAME+D'27', 1
128C  0E53      	MOVLW 0x53
128E  6F8A      	MOVWF gbl_MX_USBNAME+D'28', 1
1290  6B8B      	CLRF gbl_MX_USBNAME+D'29', 1
1292  0E65      	MOVLW 0x65
1294  6F8C      	MOVWF gbl_MX_USBNAME+D'30', 1
1296  6B8D      	CLRF gbl_MX_USBNAME+D'31', 1
1298  0E72      	MOVLW 0x72
129A  6F8E      	MOVWF gbl_MX_USBNAME+D'32', 1
129C  6B8F      	CLRF gbl_MX_USBNAME+D'33', 1
129E  0E69      	MOVLW 0x69
12A0  6F90      	MOVWF gbl_MX_USBNAME+D'34', 1
12A2  6B91      	CLRF gbl_MX_USBNAME+D'35', 1
12A4  0E61      	MOVLW 0x61
12A6  6F92      	MOVWF gbl_MX_USBNAME+D'36', 1
12A8  6B93      	CLRF gbl_MX_USBNAME+D'37', 1
12AA  0E6C      	MOVLW 0x6C
12AC  6F94      	MOVWF gbl_MX_USBNAME+D'38', 1
12AE  6B95      	CLRF gbl_MX_USBNAME+D'39', 1

	MX_UINT8 MX_USBMFR[dev_manufacturer_count] = {dev_manufacturer};			//Manufacturer
12B0  0E2E      	MOVLW 0x2E
12B2  6F40      	MOVWF gbl_MX_USBMFR, 1
12B4  0E03      	MOVLW 0x03
12B6  6F41      	MOVWF gbl_MX_USBMFR+D'1', 1
12B8  0E4D      	MOVLW 0x4D
12BA  6F42      	MOVWF gbl_MX_USBMFR+D'2', 1
12BC  6B43      	CLRF gbl_MX_USBMFR+D'3', 1
12BE  0E61      	MOVLW 0x61
12C0  6F44      	MOVWF gbl_MX_USBMFR+D'4', 1
12C2  6B45      	CLRF gbl_MX_USBMFR+D'5', 1
12C4  0E74      	MOVLW 0x74
12C6  6F46      	MOVWF gbl_MX_USBMFR+D'6', 1
12C8  6B47      	CLRF gbl_MX_USBMFR+D'7', 1
12CA  0E72      	MOVLW 0x72
12CC  6F48      	MOVWF gbl_MX_USBMFR+D'8', 1
12CE  6B49      	CLRF gbl_MX_USBMFR+D'9', 1
12D0  0E69      	MOVLW 0x69
12D2  6F4A      	MOVWF gbl_MX_USBMFR+D'10', 1
12D4  6B4B      	CLRF gbl_MX_USBMFR+D'11', 1
12D6  0E78      	MOVLW 0x78
12D8  6F4C      	MOVWF gbl_MX_USBMFR+D'12', 1
12DA  6B4D      	CLRF gbl_MX_USBMFR+D'13', 1
12DC  0E20      	MOVLW 0x20
12DE  6F4E      	MOVWF gbl_MX_USBMFR+D'14', 1
12E0  6B4F      	CLRF gbl_MX_USBMFR+D'15', 1
12E2  0E4D      	MOVLW 0x4D
12E4  6F50      	MOVWF gbl_MX_USBMFR+D'16', 1
12E6  6B51      	CLRF gbl_MX_USBMFR+D'17', 1
12E8  0E75      	MOVLW 0x75
12EA  6F52      	MOVWF gbl_MX_USBMFR+D'18', 1
12EC  6B53      	CLRF gbl_MX_USBMFR+D'19', 1
12EE  0E6C      	MOVLW 0x6C
12F0  6F54      	MOVWF gbl_MX_USBMFR+D'20', 1
12F2  6B55      	CLRF gbl_MX_USBMFR+D'21', 1
12F4  0E74      	MOVLW 0x74
12F6  6F56      	MOVWF gbl_MX_USBMFR+D'22', 1
12F8  6B57      	CLRF gbl_MX_USBMFR+D'23', 1
12FA  0E69      	MOVLW 0x69
12FC  6F58      	MOVWF gbl_MX_USBMFR+D'24', 1
12FE  6B59      	CLRF gbl_MX_USBMFR+D'25', 1
1300  0E6D      	MOVLW 0x6D
1302  6F5A      	MOVWF gbl_MX_USBMFR+D'26', 1
1304  6B5B      	CLRF gbl_MX_USBMFR+D'27', 1
1306  0E65      	MOVLW 0x65
1308  6F5C      	MOVWF gbl_MX_USBMFR+D'28', 1
130A  6B5D      	CLRF gbl_MX_USBMFR+D'29', 1
130C  0E64      	MOVLW 0x64
130E  6F5E      	MOVWF gbl_MX_USBMFR+D'30', 1
1310  6B5F      	CLRF gbl_MX_USBMFR+D'31', 1
1312  0E69      	MOVLW 0x69
1314  6F60      	MOVWF gbl_MX_USBMFR+D'32', 1
1316  6B61      	CLRF gbl_MX_USBMFR+D'33', 1
1318  0E61      	MOVLW 0x61
131A  6F62      	MOVWF gbl_MX_USBMFR+D'34', 1
131C  6B63      	CLRF gbl_MX_USBMFR+D'35', 1
131E  0E20      	MOVLW 0x20
1320  6F64      	MOVWF gbl_MX_USBMFR+D'36', 1
1322  6B65      	CLRF gbl_MX_USBMFR+D'37', 1
1324  0E4C      	MOVLW 0x4C
1326  6F66      	MOVWF gbl_MX_USBMFR+D'38', 1
1328  6B67      	CLRF gbl_MX_USBMFR+D'39', 1
132A  0E74      	MOVLW 0x74
132C  6F68      	MOVWF gbl_MX_USBMFR+D'40', 1
132E  6B69      	CLRF gbl_MX_USBMFR+D'41', 1
1330  0E64      	MOVLW 0x64
1332  6F6A      	MOVWF gbl_MX_USBMFR+D'42', 1
1334  6B6B      	CLRF gbl_MX_USBMFR+D'43', 1
1336  0E2E      	MOVLW 0x2E
1338  6F6C      	MOVWF gbl_MX_USBMFR+D'44', 1
133A  6B6D      	CLRF gbl_MX_USBMFR+D'45', 1


	// Global Defines
	#define CDC_TX_BUFFER_SIZE 	TX_BUF_SZ
	#define CDC_RX_BUFFER_SIZE 	RX_BUF_SZ
	#define CDC_DATA_ENDPOINT	3
	#define USB_HIGHEST_EP 		3
	#define USB_BUS_POWERED

	#ifdef MX_USB_TYPE1									//2455 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS	0x400
		#define USB_EP0_OUT_ADDR 	0x0500
		#define USB_EP0_IN_ADDR 	0x0508
		#define USB_EP2_IN_ADDR		0x0510
		#define USB_EP3_OUT_ADDR	0x0518
		#define USB_EP3_IN_ADDR		0x0520
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif

	#ifdef MX_USB_TYPE2									//2450 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS	0x400
		#define USB_EP0_OUT_ADDR 	0x0480
		#define USB_EP0_IN_ADDR 	0x0488
		#define USB_EP2_IN_ADDR		0x0490
		#define USB_EP3_OUT_ADDR	0x0498
		#define USB_EP3_IN_ADDR		0x04A0
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif

	#ifdef MX_USB_TYPE3									//14K50 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS	0x200
		#define USB_EP0_OUT_ADDR 	0x0280
		#define USB_EP0_IN_ADDR 	0x0288
		#define USB_EP2_IN_ADDR		0x0290
		#define USB_EP3_OUT_ADDR	0x0298
		#define USB_EP3_IN_ADDR		0x02A0
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif

	#ifdef MX_USB_TYPE4									//24J53 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS	0xD00
		#define USB_EP0_OUT_ADDR 	0x0E00
		#define USB_EP0_IN_ADDR 	0x0E08
		#define USB_EP2_IN_ADDR		0x0E10
		#define USB_EP3_OUT_ADDR	0x0E18
		#define USB_EP3_IN_ADDR		0x0E20
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif
	
	#ifdef MX_USB_TYPE5                                                             //16f1455 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS     0x2000
		#define USB_EP0_OUT_ADDR        0x2040
		#define USB_EP0_IN_ADDR         0x2048
		#define USB_EP2_IN_ADDR		    0x2050
		#define USB_EP3_OUT_ADDR	    0x2058
		#define USB_EP3_IN_ADDR		    0x2060
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif

	#ifdef MX_USB_TYPE6                                                             //18F45K50 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS     0x400
		#define USB_EP0_OUT_ADDR        0x0500
		#define USB_EP0_IN_ADDR         0x0508
		#define USB_EP2_IN_ADDR		    0x0510
		#define USB_EP3_OUT_ADDR	    0x0518
		#define USB_EP3_IN_ADDR		    0x0520
		#define PIRREG  		pir3
		#define PIEREG  		pie3
	#endif

	#ifndef USB_DESCRIPTOR_BASE_ADDRESS
		#error "Target device does not have USB functionality"
	#endif

	#ifdef HI_TECH_C
		#error "USB library only supported by the BoostC compiler"
	#endif

	#define USB_EP0_OUT_SIZE 	8
	#define USB_EP0_IN_SIZE 	8
	#define USB_EP2_IN_SIZE		8
	#define USB_EP3_OUT_SIZE	8
	#define USB_EP3_IN_SIZE		8

	#define USB_CALLBACK_ON_SOF
	#define USB_CALLBACK_ON_DEVICE_CONFIGURED
	#define USB_CALLBACK_ON_CTRL_CLASS
	#define USB_EP_DATA_CALLBACK

	//Serial Number
	MX_UINT8 MX_SERIAL[10] = {10,3,'0',0,'0',0,'0',0,'1',0};
133C  0E0A      	MOVLW 0x0A
133E  0100      	MOVLB 0x00
1340  6FE0      	MOVWF gbl_MX_SERIAL, 1
1342  0E03      	MOVLW 0x03
1344  6FE1      	MOVWF gbl_MX_SERIAL+D'1', 1
1346  0E30      	MOVLW 0x30
1348  6FE2      	MOVWF gbl_MX_SERIAL+D'2', 1
134A  6BE3      	CLRF gbl_MX_SERIAL+D'3', 1
134C  0E30      	MOVLW 0x30
134E  6FE4      	MOVWF gbl_MX_SERIAL+D'4', 1
1350  6BE5      	CLRF gbl_MX_SERIAL+D'5', 1
1352  0E30      	MOVLW 0x30
1354  6FE6      	MOVWF gbl_MX_SERIAL+D'6', 1
1356  6BE7      	CLRF gbl_MX_SERIAL+D'7', 1
1358  0E31      	MOVLW 0x31
135A  6FE8      	MOVWF gbl_MX_SERIAL+D'8', 1
135C  6BE9      	CLRF gbl_MX_SERIAL+D'9', 1


	// USB library includes
	#include "../../../../CAL/PIC/USB/pic_utils.h"
	#include "../../../../CAL/PIC/USB/pic_usb_buffer_mgt.c"
	#include "../../../../CAL/PIC/USB/pic_usb.c"
	#include "../../../../CAL/PIC/USB/usb_cdc_class.c"
	#include "../../../../CAL/PIC/USB/usb_config_serial.c"

	// Variable to hold status of the USB connection
	MX_UINT8 CDC_USB_status = 0;
1414  6B51      	CLRF gbl_CDC_USB_status, 1


	// Variable to hold incoming data
	MX_UINT8 CDC_USB_Rx_String[CDC_RX_BUFFER_SIZE];

	void usb_device_configured_callback(void)

	{
		CDC_USB_status = 1;
0390  0E01      	MOVLW 0x01
0392  0102      	MOVLB 0x02
0394  6F51      	MOVWF gbl_CDC_USB_status, 1

	}
0396  0012      	RETURN


#endif

#ifdef MX_CAL_PIC16					//16-bit PIC specific

	#ifndef MX_USB_TYPE1
		#error "Your target device does not support USB components"
	#endif

	// Global Defines
	#define USB_BUS_SENSE       1
	#define self_power          1
	#define tris_usb_bus_sense	1
	#define tris_self_power		1

	#define USB_CONFIG	"usb_serial_config.h"

	// USB library includes
	#include "../../../CAL/PIC16BIT/USB/usb_serial_config.h"
	#include "../../../CAL/PIC16BIT/USB/usb.h"
	#include "../../../CAL/PIC16BIT/USB/usb_function_cdc.h"
	#include "../../../CAL/PIC16BIT/USB/GenericTypeDefs.h"
	#include "../../../CAL/PIC16BIT/USB/Compiler.h"
	#include "../../../CAL/PIC16BIT/USB/usb_device.h"
	#include "../../../CAL/PIC16BIT/USB/usb_device.c"
	#include "../../../CAL/PIC16BIT/USB/usb_ch9.h"
    #if defined(__dsPIC33E__) 
      #include "../../../CAL/PIC16BIT/USB/usb_hal_dspic33e.c"
    #elif defined(__PIC24E__)
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24e.c"
    #else
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24.c"
    #endif
	#include "../../../CAL/PIC16BIT/USB/usb_function_cdc.c"
	#include "../../../CAL/PIC16BIT/USB/usb_common.h"
	#include "../../../CAL/PIC16BIT/USB/usb_hal.h"
    #if defined(__dsPIC33E__) 
      #include "../../../CAL/PIC16BIT/USB/usb_hal_dspic33e.h"
    #elif defined(__PIC24E__)
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24e.h"
    #else
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24.h"
    #endif
	
	// Device name and manufacturer
	ROM struct{BYTE bLength;BYTE bDscType;WORD string[dev_name_count_DS];}sd001={sizeof(sd001),USB_DESCRIPTOR_STRING,{dev_name_DS}};
	ROM struct{BYTE bLength;BYTE bDscType;WORD string[dev_manufacturer_count_DS];}sd002={sizeof(sd002),USB_DESCRIPTOR_STRING,{dev_manufacturer_DS}};

	#include "../../../CAL/PIC16BIT/USB/usb_serial_descriptors.c"
    #include "../../../CAL/PIC16BIT/USB/usb_cdc_handler.c"

#endif


#ifdef MX_CAL_AVR					//AVR specific

#include "config.h"
#include "lib_mcu/usb/usb_drv.h"
#include "modules\usb\device_chap9\usb_standard_request.h"
#include "usb_specific_request.h"
#include "uart_usb_lib.h"

extern U8    rx_counter;
extern U8    tx_counter;

S_line_coding line_coding;
S_line_status line_status;      // for detection of serial state input lines
S_serial_state serial_state;    // for serial state output lines

#endif

MX_UINT8 FCD_056e1_v5__usbserial0__SendString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA);
void FCD_056e1_v5__usbserial0__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_TIMEOUT_MS, MX_UINT8 FCL_LENGTH);
MX_UINT8 FCD_056e1_v5__usbserial0__SendByte(MX_UINT8 FCL_DATA);
MX_UINT16 FCD_056e1_v5__usbserial0__ReadByte(MX_UINT8 FCL_TIMEOUT_MS);
MX_UINT8 FCD_056e1_v5__usbserial0__Initialise();

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :dash_scale_vert1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII6
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :PWM_Digital
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Parameters for macro ReadASCIILUT:
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_PWM_Digital__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Local variable definitions
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_pwm
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :PWM1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the overall period and prescaler of the output PWM signal.
       :
       :Parameters for macro ChangePeriod:
       :  Period : The maximum number that will represent 100% on, PIC/AVR: 0-255 16-bit PIC: 0-65535
       :  Prescaler : The scaler used to divide the system clock speed down to the PWM rate.
\*=----------------------------------------------------------------------=*/
void FCD_0df41_PWM1__ChangePeriod(MX_UINT16 FCL_PERIOD, MX_SINT16 FCL_PRESCALER)
{

	FC_CAL_PWM_ChangePeriod_1(FCL_PERIOD, FCL_PRESCALER);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables a PWM channel and allows the default output / input state to be resumed
\*=----------------------------------------------------------------------=*/
void FCD_0df41_PWM1__Disable()
{

	FCV_0df41_PWM1__ENABLED = 0;

	FC_CAL_PWM_Disable_1();

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the PWM duty cycle in terms of on/off based on the current period setting.
       :E.g. if period = 255 then duty of 128 is equal to 50% on and 50% off.
       :16-bit PIC users should use the 10bit duty function to access the full range.
       :
       :Parameters for macro SetDutyCycle:
       :  Duty : 8-bit PWM duty 0-255
\*=----------------------------------------------------------------------=*/
void FCD_0df41_PWM1__SetDutyCycle(MX_UINT8 FCL_DUTY)
{

	if (FCV_0df41_PWM1__ENABLED)
	{

		FC_CAL_PWM_SetDuty8Bit_1(FCL_DUTY);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Enables a PWM channel as an output overriding the default output pin state.
\*=----------------------------------------------------------------------=*/
void FCD_0df41_PWM1__Enable()

{

	FCV_0df41_PWM1__ENABLED = 1;
0F72  0E01      	MOVLW 0x01
0F74  0102      	MOVLB 0x02
0F76  6F41      	MOVWF gbl_FCV_0df41_PWM1__ENABLED, 1


	FC_CAL_PWM_ChangePeriod_1(255, 1);
0F78  6957      	SETF FC_CAL_PWM_0004E_arg_period, 1
0F7A  6B58      	CLRF FC_CAL_PWM_0004E_arg_period+D'1', 1
0F7C  0E01      	MOVLW 0x01
0F7E  6F59      	MOVWF FC_CAL_PWM_0004E_arg_prescaler, 1
0F80  6B5A      	CLRF FC_CAL_PWM_0004E_arg_prescaler+D'1', 1
0F82  EC0EF007  	CALL FC_CAL_PWM_0004E


	FC_CAL_PWM_Enable_1();
0F86  EC09F007  	CALL FC_CAL_PWM_00051


}
0F8A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :PIC/AVR - Sets the full scale PWM duty cycle based on the current period setting.
       :If period = 255 then Duty of 512 is equal to 50%.
       :
       :16-bit PICs have a 16-bit period range available.
       :If period = 65535 then Duty of 32768 is equal to 50%.
       :
       :Parameters for macro SetDutyCycle10Bit:
       :  Duty : PWM duty PIC/AVR: 0-1023 16-bit PIC: 0-65535
\*=----------------------------------------------------------------------=*/
void FCD_0df41_PWM1__SetDutyCycle10Bit(MX_UINT16 FCL_DUTY)
{

	if (FCV_0df41_PWM1__ENABLED)
	{

		FC_CAL_PWM_SetDuty10Bit_1(FCL_DUTY);

	// } else {

	}

}


/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :adc_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f42_adc_base__RawSampleInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as as tring
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_08f42_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_FLOAT FCL_SAMPLE;


	FCL_SAMPLE = FCD_08f42_adc_base__GetVoltage();

	FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL,20);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCR_RETVAL = FCD_08f42_adc_base__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_08f42_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT32 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f42_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCR_RETVAL = FCD_08f42_adc_base__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08f42_adc_base__GetVoltage()
{
	//Local variable definitions
	MX_UINT16 FCL_SAMPLE;
	MX_FLOAT FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCL_SAMPLE = FC_CAL_ADC_Sample(1);

	FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.004883);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_08f42_adc_base__RawEnable()
{

	FC_CAL_ADC_Enable(8, 3, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__RawSampleByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f42_adc_base__GetInt()

{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);
0F8C  0E08      	MOVLW 0x08
0F8E  0102      	MOVLB 0x02
0F90  6F59      	MOVWF FC_CAL_ADC_0005A_arg_Channel, 1
0F92  0E03      	MOVLW 0x03
0F94  6F5A      	MOVWF FC_CAL_ADC_0005A_arg_Conv_Speed, 1
0F96  6B5B      	CLRF FC_CAL_ADC_0005A_arg_Vref, 1
0F98  0E28      	MOVLW 0x28
0F9A  6F5C      	MOVWF FC_CAL_ADC_0005A_arg_T_Charge, 1
0F9C  EC56F007  	CALL FC_CAL_ADC_0005A


	FCR_RETVAL = FC_CAL_ADC_Sample(1);
0FA0  0E01      	MOVLW 0x01
0FA2  6F59      	MOVWF FC_CAL_ADC_0005B_arg_Sample_Mode, 1
0FA4  EC34F007  	CALL FC_CAL_ADC_0005B
0FA8  515C      	MOVF CompTempVarRet2656, W, 1
0FAA  6F57      	MOVWF FCD_08f42__0006A_1_FCR_RETVAL, 1
0FAC  515D      	MOVF CompTempVarRet2656+D'1', W, 1
0FAE  6F58      	MOVWF FCD_08f42__0006A_1_FCR_RETVAL+D'1', 1


	FC_CAL_ADC_Disable();
0FB0  EC9EF007  	CALL FC_CAL_ADC_00059


	return (FCR_RETVAL);
0FB4  5157      	MOVF FCD_08f42__0006A_1_FCR_RETVAL, W, 1
0FB6  6F59      	MOVWF CompTempVarRet2684, 1
0FB8  5158      	MOVF FCD_08f42__0006A_1_FCR_RETVAL+D'1', W, 1
0FBA  6F5A      	MOVWF CompTempVarRet2684+D'1', 1


}
0FBC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_08f42_adc_base__RawDisable()
{

	FC_CAL_ADC_Disable();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__GetByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :v5__adc1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :adc_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__RawSampleInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as as tring
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_FLOAT FCL_SAMPLE;


	FCL_SAMPLE = FCD_08f41_adc_base__GetVoltage();

	FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL,20);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCR_RETVAL = FCD_08f41_adc_base__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_08f41_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT32 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCR_RETVAL = FCD_08f41_adc_base__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08f41_adc_base__GetVoltage()
{
	//Local variable definitions
	MX_UINT16 FCL_SAMPLE;
	MX_FLOAT FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCL_SAMPLE = FC_CAL_ADC_Sample(1);

	FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.004883);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__RawEnable()
{

	FC_CAL_ADC_Enable(7, 3, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__RawSampleByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__GetInt()

{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);
0FBE  0E07      	MOVLW 0x07
0FC0  0102      	MOVLB 0x02
0FC2  6F59      	MOVWF FC_CAL_ADC_0005A_arg_Channel, 1
0FC4  0E03      	MOVLW 0x03
0FC6  6F5A      	MOVWF FC_CAL_ADC_0005A_arg_Conv_Speed, 1
0FC8  6B5B      	CLRF FC_CAL_ADC_0005A_arg_Vref, 1
0FCA  0E28      	MOVLW 0x28
0FCC  6F5C      	MOVWF FC_CAL_ADC_0005A_arg_T_Charge, 1
0FCE  EC56F007  	CALL FC_CAL_ADC_0005A


	FCR_RETVAL = FC_CAL_ADC_Sample(1);
0FD2  0E01      	MOVLW 0x01
0FD4  6F59      	MOVWF FC_CAL_ADC_0005B_arg_Sample_Mode, 1
0FD6  EC34F007  	CALL FC_CAL_ADC_0005B
0FDA  515C      	MOVF CompTempVarRet2656, W, 1
0FDC  6F57      	MOVWF FCD_08f41__0007B_1_FCR_RETVAL, 1
0FDE  515D      	MOVF CompTempVarRet2656+D'1', W, 1
0FE0  6F58      	MOVWF FCD_08f41__0007B_1_FCR_RETVAL+D'1', 1


	FC_CAL_ADC_Disable();
0FE2  EC9EF007  	CALL FC_CAL_ADC_00059


	return (FCR_RETVAL);
0FE6  5157      	MOVF FCD_08f41__0007B_1_FCR_RETVAL, W, 1
0FE8  6F59      	MOVWF CompTempVarRet2708, 1
0FEA  5158      	MOVF FCD_08f41__0007B_1_FCR_RETVAL+D'1', W, 1
0FEC  6F5A      	MOVWF CompTempVarRet2708+D'1', 1


}
0FEE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__RawDisable()
{

	FC_CAL_ADC_Disable();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__GetByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :v5__adc0
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :COMPort
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :v5__usbserial0
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sends the specified data string to the host
       :
       :Parameters for macro SendString:
       :  Data[20] : Data string to send to the host
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_v5__usbserial0__SendString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)

{
	//Local variable definitions
	MX_UINT16 FCL_TIMEOUT = (0x0);
10AC  6B5B      	CLRF FCD_056e1__000A4_1_FCL_TIMEOUT, 1
10AE  6B5C      	CLRF FCD_056e1__000A4_1_FCL_TIMEOUT+D'1', 1

	MX_UINT8 FCL_LENGTH;
	MX_UINT8 FCR_RETVAL;


	FCL_LENGTH = FCI_GETLENGTH(FCL_DATA, FCLsz_DATA);
10B0  5157      	MOVF FCD_056e1__000A4_arg_FCL_DATA, W, 1
10B2  6F60      	MOVWF FCI_GETLEN_0003D_arg_sStr1, 1
10B4  5158      	MOVF FCD_056e1__000A4_arg_FCL_DATA+D'1', W, 1
10B6  6F61      	MOVWF FCI_GETLEN_0003D_arg_sStr1+D'1', 1
10B8  5159      	MOVF FCD_056e1__000A4_arg_FCLsz_DATA, W, 1
10BA  6F62      	MOVWF FCI_GETLEN_0003D_arg_iStr1_len, 1
10BC  ECA9F007  	CALL FCI_GETLEN_0003D
10C0  5164      	MOVF CompTempVarRet1856, W, 1
10C2  6F5D      	MOVWF FCD_056e1__000A4_1_FCL_LENGTH, 1


	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		MX_UINT8 n;

		while (usb_cdc_tx_empty() == 0 && FCL_TIMEOUT < 32000)	//Wait for outgoing buffer to empty
10C4            label152
10C4  EC9EF006  	CALL usb_cdc_tx_0009F
10C8  5360      	MOVF CompTempVarRet2799, F, 1
10CA  E10C      	BNZ	label154
10CC  0E7D      	MOVLW 0x7D
10CE  5D5C      	SUBWF FCD_056e1__000A4_1_FCL_TIMEOUT+D'1', W, 1
10D0  E102      	BNZ	label153
10D2  0E00      	MOVLW 0x00
10D4  5D5B      	SUBWF FCD_056e1__000A4_1_FCL_TIMEOUT, W, 1
10D6            label153
10D6  E206      	BC	label154
10E2  D7F0      	BRA	label152
10E4            label154

			FCL_TIMEOUT = FCL_TIMEOUT + 1;
10D8  535B      	MOVF FCD_056e1__000A4_1_FCL_TIMEOUT, F, 1
10DA  535C      	MOVF FCD_056e1__000A4_1_FCL_TIMEOUT+D'1', F, 1
10DC  2B5B      	INCF FCD_056e1__000A4_1_FCL_TIMEOUT, F, 1
10DE  B4D8      	BTFSC STATUS,Z
10E0  2B5C      	INCF FCD_056e1__000A4_1_FCL_TIMEOUT+D'1', F, 1


		if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
10E4  0E00      	MOVLW 0x00
10E6  635B      	CPFSEQ FCD_056e1__000A4_1_FCL_TIMEOUT, 1
10E8  D006      	BRA	label155
10EA  0E7D      	MOVLW 0x7D
10EC  635C      	CPFSEQ FCD_056e1__000A4_1_FCL_TIMEOUT+D'1', 1
10EE  D003      	BRA	label155
10F6            label155

			return(1);
10F0  0E01      	MOVLW 0x01
10F2  6F60      	MOVWF CompTempVarRet2812, 1


		// Flowcode strings are not necessarily null terminated
		// so we cannot use  usb_cdc_print_str(FCL_DATA);
		for(n = 0 ; (FCL_DATA[n] != 0)&&(n < FCL_LENGTH); n++)
10F6  6B5F      	CLRF FCD_056e1__000A4_1_n, 1
10F8            label156
10F8  5158      	MOVF FCD_056e1__000A4_arg_FCL_DATA+D'1', W, 1
10FA  6EEA      	MOVWF FSR0H
10FC  5157      	MOVF FCD_056e1__000A4_arg_FCL_DATA, W, 1
10FE  255F      	ADDWF FCD_056e1__000A4_1_n, W, 1
1100  6EE9      	MOVWF FSR0L
1102  52EF      	MOVF INDF0, F
1104  E00E      	BZ	label157
1106  515D      	MOVF FCD_056e1__000A4_1_FCL_LENGTH, W, 1
1108  615F      	CPFSLT FCD_056e1__000A4_1_n, 1
110A  D00B      	BRA	label157
111E  2B5F      	INCF FCD_056e1__000A4_1_n, F, 1
1120  D7EB      	BRA	label156
1122            label157

		{
			usb_cdc_putc(FCL_DATA[n]);
110C  5158      	MOVF FCD_056e1__000A4_arg_FCL_DATA+D'1', W, 1
110E  6EEA      	MOVWF FSR0H
1110  5157      	MOVF FCD_056e1__000A4_arg_FCL_DATA, W, 1
1112  255F      	ADDWF FCD_056e1__000A4_1_n, W, 1
1114  6EE9      	MOVWF FSR0L
1116  50EF      	MOVF INDF0, W
1118  6F61      	MOVWF usb_cdc_pu_0009D_arg_c, 1
111A  ECD8F006  	CALL usb_cdc_pu_0009D

		}

	  #endif

	  #ifdef MX_CAL_PIC16	//16-bit PIC specific

		if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1))
		{
			return(2);	    //USB Not Configured
		}
		else
		{
			CDCTxService();		//Required or every other send fails

			while (mUSBUSARTIsTxTrfReady() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
				FCL_TIMEOUT = FCL_TIMEOUT + 1;

			if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			{
				return(1);		//USB Not Ready
			}
			else
			{
				putUSBUSART(FCL_DATA, FCL_LENGTH);
			}
		}
		CDCTxService();

	  #endif

	#ifdef MX_CAL_AVR          //AVR specific

	        MX_UINT8 n;

	        if(!Is_device_enumerated()) {
	            return(2);
	        } else {
	            for(n = 0; (FCL_DATA[n] != 0) && (n < FCL_LENGTH); n++) {
	                FCL_TIMEOUT = 0;
	                while((!uart_usb_tx_ready()) && (FCL_TIMEOUT < 32000))
	                    FCL_TIMEOUT++;

	                if(FCL_TIMEOUT == 32000) {
	                    return(1);
	                } else {
	                    uart_usb_putchar(FCL_DATA[n]);
	                    Usb_ack_in_ready();
	                }
	            }
	        }

	#endif


	FCR_RETVAL = 0;
1122  6B5E      	CLRF FCD_056e1__000A4_1_FCR_RETVAL, 1


	return (FCR_RETVAL);
1124  515E      	MOVF FCD_056e1__000A4_1_FCR_RETVAL, W, 1
1126  6F60      	MOVWF CompTempVarRet2812, 1


}
10F4  0012      	RETURN
1128  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Retreives a string from the incoming data buffer. If data is available then the macro will return straight away. If there is no data available then the macro waits up the the period specified by the timeout before returning the value 255.
       :
       :Parameters for macro ReadString:
       :  Timeout_ms : Length of time to wait before timing out
       :  Length : Maximum number of bytes to try and read
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_056e1_v5__usbserial0__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_TIMEOUT_MS, MX_UINT8 FCL_LENGTH)
{
	//Local variable definitions
	MX_UINT8 FCL_WAIT_FOREVER = (0x0);


	  #ifdef MX_CAL_PIC			//8-bit PIC specific

		MX_UINT8 Rx_Length;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER)
		{
			Rx_Length = usb_cdc_rx_avail();		// get length of incoming data string
			if (Rx_Length)
			{
				if (Rx_Length > FCL_LENGTH)
					Rx_Length = FCL_LENGTH;

				usb_ep_get_rx_buffer(Rx_Length, FCR_RETVAL);	// copy data string to local buffer

				if (Rx_Length < FCL_LENGTH)
					FCR_RETVAL[Rx_Length] = 0;		//Add null MX_UINT8acter to end of string
				return;
			}
			else
			{
				Wdt_Delay_Ms(1);
				FCL_TIMEOUT_MS = FCL_TIMEOUT_MS - 1;
			}
		}

	  #endif

	  #ifdef MX_CAL_PIC16									//16-bit PIC specific

		MX_UINT8 inner = 0;
		MX_UINT16 numBytesRead = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while(numBytesRead == 0 && FCL_TIMEOUT_MS > 0)
		{
			numBytesRead = getsUSBUSART(FCR_RETVAL, FCL_LENGTH);
			if ((FCL_WAIT_FOREVER == 0) && (numBytesRead == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
		}

	  #endif

	  #ifdef MX_CAL_AVR			//AVR specific

		MX_UINT8 Rx_Length = 0;
		MX_UINT8 inner = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER) {
	        if(uart_usb_test_hit()) {
	            FCL_WAIT_FOREVER = 0;
	            while(uart_usb_test_hit() && (Rx_Length <= FCL_LENGTH)) {
	                FCR_RETVAL[Rx_Length++] = uart_usb_getchar();
	            }
	        } else {
				inner++;
				delay_us(10);
				if (inner == 100) {
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
	        }
	    }
		if (Rx_Length < FCL_LENGTH)
		    FCR_RETVAL[Rx_Length] = 0;		//Add null MX_UINT8acter to end of string

	  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Sends the specified data byte to the host
       :
       :Parameters for macro SendByte:
       :  data : Data byte to send to the host
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_v5__usbserial0__SendByte(MX_UINT8 FCL_DATA)
{
	//Local variable definitions
	MX_UINT16 FCL_TIMEOUT = (0x0);
	MX_UINT8 FCR_RETVAL;


	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		while (usb_cdc_tx_empty() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
			FCL_TIMEOUT = FCL_TIMEOUT + 1;

		if (FCL_TIMEOUT == 32000)			//Pipeline full or disconnected
			return(1);

		usb_cdc_putc(FCL_DATA);

	  #endif

	  #ifdef MX_CAL_PIC16		//16-bit PIC specific

	  	if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1))
	  	{
	  		return(2);		//USB Not Configured
	  	}
	  	else
	  	{
			CDCTxService();													//Required or every other send fails
			while (mUSBUSARTIsTxTrfReady() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
				FCL_TIMEOUT = FCL_TIMEOUT + 1;

			if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			{
				return(1);		//USB Not Ready
			}
			else
			{
				putUSBUSART(&FCL_DATA,1);
			}
		}
		CDCTxService();

	  #endif

	#ifdef MX_CAL_AVR          //AVR specific
	        if(!Is_device_enumerated()) {
	            return(2);
	        } else {
	            Usb_select_endpoint(TX_EP);
	            while((uart_usb_tx_ready() == 0) && (FCL_TIMEOUT < 32000))
	                FCL_TIMEOUT++;

	            if(FCL_TIMEOUT == 32000) {
	                return(1);
	            } else {
	                uart_usb_putchar(FCL_DATA);
	                Usb_ack_in_ready();
	            }
	        }
	#endif


	FCR_RETVAL = 0;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Retreives the byte from the incoming data buffer. If data is available then the macro will return straight away. If there is no data available then the macro waits up the the period specified by the timeout before returning the value 255.
       :
       :Parameters for macro ReadByte:
       :  Timeout_ms : Number of milliseconds to wait before timing out
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_056e1_v5__usbserial0__ReadByte(MX_UINT8 FCL_TIMEOUT_MS)

{
	//Local variable definitions
	MX_UINT8 FCL_WAIT_FOREVER = (0x0);
101C  6B58      	CLRF FCD_056e1__000AA_1_FCL_WAI_000AC, 1

	MX_UINT16 FCR_RETVAL;


	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	#else

		FCR_RETVAL = 255;
101E  6959      	SETF FCD_056e1__000AA_1_FCR_RETVAL, 1
1020  6B5A      	CLRF FCD_056e1__000AA_1_FCR_RETVAL+D'1', 1


	#endif

	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		static MX_UINT8 position = 0;
1022  B154      	BTFSC CompGblVar65,0, 1
1024  D002      	BRA	label144
1026  6B55      	CLRF FCD_056e1__000AA_1_position, 1
1028  8154      	BSF CompGblVar65,0, 1
102A            label144
122A  9154      	BCF CompGblVar65,0, 1
122E  9154      	BCF CompGblVar65,0, 1

		static MX_UINT8 length = 0;
102A  B354      	BTFSC CompGblVar66,1, 1
102C  D002      	BRA	label145
102E  6B56      	CLRF FCD_056e1__000AA_1_length, 1
1030  8354      	BSF CompGblVar66,1, 1
1032            label145
122C  9354      	BCF CompGblVar66,1, 1
1230  9354      	BCF CompGblVar66,1, 1


		if(FCL_TIMEOUT_MS == 255)
1032  2957      	INCF FCD_056e1__000AA_arg_FCL_T_000AB, W, 1
1034  E102      	BNZ	label146
103A            label146

			FCL_WAIT_FOREVER = 1;
1036  0E01      	MOVLW 0x01
1038  6F58      	MOVWF FCD_056e1__000AA_1_FCL_WAI_000AC, 1


		if (position == length)									// end of local string?
103A  5156      	MOVF FCD_056e1__000AA_1_length, W, 1
103C  6355      	CPFSEQ FCD_056e1__000AA_1_position, 1
103E  D025      	BRA	label151
108A            label151

		{
			position = 0;
1040  6B55      	CLRF FCD_056e1__000AA_1_position, 1


			length = usb_cdc_rx_avail();						// get length of incoming data string
1042  ECD3F006  	CALL usb_cdc_rx_0009E
1046  515B      	MOVF CompTempVarRet2797, W, 1
1048  6F56      	MOVWF FCD_056e1__000AA_1_length, 1


			while (length == 0 && (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER))	// wait for timeout_ms
104A            label147
104A  5356      	MOVF FCD_056e1__000AA_1_length, F, 1
104C  E10F      	BNZ	label149
104E  5357      	MOVF FCD_056e1__000AA_arg_FCL_T_000AB, F, 1
1050  E102      	BNZ	label148
1052  5358      	MOVF FCD_056e1__000AA_1_FCL_WAI_000AC, F, 1
1054  E00B      	BZ	label149
1056            label148
106A  D7EF      	BRA	label147
106C            label149

			{
				Wdt_Delay_Ms(1);
1056  0E01      	MOVLW 0x01
1058  6F5B      	MOVWF Wdt_Delay__00036_arg_delay, 1
105A  ECFEF006  	CALL Wdt_Delay__00036

				length = usb_cdc_rx_avail();					// get length of incoming data string
105E  ECD3F006  	CALL usb_cdc_rx_0009E
1062  515B      	MOVF CompTempVarRet2797, W, 1
1064  6F56      	MOVWF FCD_056e1__000AA_1_length, 1

				FCL_TIMEOUT_MS = FCL_TIMEOUT_MS - 1;			// decrement timeout_ms
1066  0557      	DECF FCD_056e1__000AA_arg_FCL_T_000AB, W, 1
1068  6F57      	MOVWF FCD_056e1__000AA_arg_FCL_T_000AB, 1

			}

			if(length == 0)
106C  5356      	MOVF FCD_056e1__000AA_1_length, F, 1
106E  E105      	BNZ	label150
107A            label150

				return (FCR_RETVAL);							// return no data flag 255 / 0xFF
1070  5159      	MOVF FCD_056e1__000AA_1_FCR_RETVAL, W, 1
1072  6F5B      	MOVWF CompTempVarRet2823, 1
1074  515A      	MOVF FCD_056e1__000AA_1_FCR_RETVAL+D'1', W, 1
1076  6F5C      	MOVWF CompTempVarRet2823+D'1', 1


			usb_ep_get_rx_buffer(length, CDC_USB_Rx_String);	// copy data string to local buffer
107A  5156      	MOVF FCD_056e1__000AA_1_length, W, 1
107C  6F5D      	MOVWF usb_ep_get_000A2_arg_length, 1
107E  0E01      	MOVLW HIGH(gbl_CDC_USB_Rx_String+D'0')
1080  6F5F      	MOVWF usb_ep_get_000A2_arg_buffer+D'1', 1
1082  0E00      	MOVLW LOW(gbl_CDC_USB_Rx_String+D'0')
1084  6F5E      	MOVWF usb_ep_get_000A2_arg_buffer, 1
1086  EC59F005  	CALL usb_ep_get_000A2

		}

		FCR_RETVAL = CDC_USB_Rx_String[position];
108A  0101      	MOVLB 0x01
108C  EE01F000  	LFSR 0x00, gbl_CDC_USB_Rx_String
1090  50E9      	MOVF FSR0L, W
1092  0102      	MOVLB 0x02
1094  5155      	MOVF FCD_056e1__000AA_1_position, W, 1
1096  26E9      	ADDWF FSR0L, F
1098  50EF      	MOVF INDF0, W
109A  6F59      	MOVWF FCD_056e1__000AA_1_FCR_RETVAL, 1
109C  6B5A      	CLRF FCD_056e1__000AA_1_FCR_RETVAL+D'1', 1


		position = position + 1;
109E  2955      	INCF FCD_056e1__000AA_1_position, W, 1
10A0  6F55      	MOVWF FCD_056e1__000AA_1_position, 1


		return (FCR_RETVAL);
10A2  5159      	MOVF FCD_056e1__000AA_1_FCR_RETVAL, W, 1
10A4  6F5B      	MOVWF CompTempVarRet2823, 1
10A6  515A      	MOVF FCD_056e1__000AA_1_FCR_RETVAL+D'1', W, 1
10A8  6F5C      	MOVWF CompTempVarRet2823+D'1', 1


	  #endif

	  #ifdef MX_CAL_PIC16									//16-bit PIC specific

		MX_UINT8 retval[1];
		MX_UINT8 inner = 0;
		MX_UINT16 numBytesRead = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while(numBytesRead == 0 && FCL_TIMEOUT_MS > 0)
		{
			numBytesRead = getsUSBUSART(retval,1);
			if ((FCL_WAIT_FOREVER == 0) && (numBytesRead == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
	        else
	            FCR_RETVAL = retval[0];
		}
		return (FCR_RETVAL);

	  #endif

	  #ifdef MX_CAL_AVR		//AVRspecific

	    MX_UINT8 rx_rdy = 0;
	    MX_UINT8 inner = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while((rx_rdy == 0) && (FCL_TIMEOUT_MS > 0))
		{
			rx_rdy = uart_usb_test_hit();
	        if(rx_rdy)
	            FCR_RETVAL = uart_usb_getchar();

			if ((FCL_WAIT_FOREVER == 0) && (rx_rdy == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
		}
		return (FCR_RETVAL);
	  #endif

	return (FCR_RETVAL);


}
1078  0012      	RETURN
10AA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Starts up the USB communications and attempts to enumerate.
       :Returns 0 for a successful startup or 255 for a enumeration timeout.
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_v5__usbserial0__Initialise()

{
	//Local variable definitions
	MX_UINT16 FCL_DELAY_COUNTER = (0x0);
0FF0  0102      	MOVLB 0x02
0FF2  6B57      	CLRF FCD_056e1__000AD_1_FCL_DEL_000AE, 1
0FF4  6B58      	CLRF FCD_056e1__000AD_1_FCL_DEL_000AE+D'1', 1

	MX_UINT8 FCR_RETVAL;


	#ifdef MX_CAL_PIC                                //8-bit PIC specific
	  #if defined(P18F24J50) || defined(P18F25J55) || defined(P18F26J50) || defined(P18F44J50) || defined(P18F45J50) || defined(P18F46J55) || defined(P18F87J50) ||  defined(P18F86J55) || defined(P18F86J50) || defined(P18F85J50) || defined(P18F67J50) || defined(P18F66J55) || defined(P18F66J50) || defined(P18F65J50)
	  //On the PIC18F87J50 Family of USB microcontrollers, the PLL will not power up and be enabled
	  //by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
	  //This allows the device to power up at a lower initial operating frequency, which can be
	  //advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
	  //operation.  On these devices, user firmware needs to manually set the OSCTUNE&lt;PLLEN&gt; bit to
	  //power up the PLL.
	  {
	      MX_UINT16 pll_startup_counter = 600;
	      OSCTUNEbits.PLLEN = 1;  //Enable the PLL and wait 2+ms until the PLL locks before enabling USB module
	      while(pll_startup_counter--);
	  }
	  //Device switches over automatically to PLL output after PLL is locked and ready.
	  #endif
	#endif

	#ifdef MX_CAL_PIC16                        //16-bit PIC specific
	  #if defined(P24FJ64GB004) || defined(P24FJ64GB002) || defined(P24FJ32GB004) || defined(P24FJ32GB002)
	  //On the PIC24FJ64GB004 Family of USB microcontrollers, the PLL will not power up and be enabled
	  //by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
	  //This allows the device to power up at a lower initial operating frequency, which can be
	  //advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
	  //operation.  On these devices, user firmware needs to manually set the CLKDIV&lt;PLLEN&gt; bit to
	  //power up the PLL.
	  {
	      MX_UINT16 pll_startup_counter = 600;
	      CLKDIVbits.PLLEN = 1;
	      while(pll_startup_counter--);
	  }
	  #endif
	#endif

	#ifdef MX_CAL_AVR                          //ATmega or AT90
	//  #if defined(AT90USB162)
	//  {
	      Usb_enable_regulator();
	//  }
	//  #endif
	#endif

	  #ifdef MX_CAL_PIC					//8-bit PIC specific
		usb_configure_structures();
0FF6  EC7FF005  	CALL usb_config_000A3

		kill_interrupts();						//turn off interrupts just in case
0FFA            label142
0FFA  9EF2      	BCF gbl_intcon,7
0FFC  BEF2      	BTFSC gbl_intcon,7
0FFE  D7FD      	BRA	label142

		usb_cdc_setup();
1000  ECA5F006  	CALL usb_cdc_se_000A1

		usb_setup();
1004  EC47F005  	CALL usb_setup_00000

		turn_peripheral_ints_on();
1008  8CF2      	BSF gbl_intcon,6

		turn_global_ints_on();
100A  8EF2      	BSF gbl_intcon,7

		usb_enable_module();
100C  EC79F005  	CALL usb_enable_00083

	  #elif defined MX_CAL_PIC16							//16-bit PIC specific
		USBDeviceInit();
		if(USB_BUS_SENSE && (USBGetDeviceState() == DETACHED_STATE))
			USBDeviceAttach();
	  #elif defined MX_CAL_AVR
	      usb_task_init();
	  #endif

	#if (0)

	//Code has been optimised out by the pre-processor
	#else

		#ifdef MX_CAL_PIC			//8-bit PIC specific
		  while(CDC_USB_status == 0);
1010            label143
1010  5351      	MOVF gbl_CDC_USB_status, F, 1
1012  E0FE      	BZ	label143

		#elif defined MX_CAL_PIC16					//16-bit PIC specific
		  while(USBDeviceState != CONFIGURED_STATE);
		#elif defined MX_CAL_AVR
		  while(Is_device_enumerated() == 0) {
		    usb_task();
		  }
		  uart_usb_init();
		#endif

		FCR_RETVAL = 0;
1014  6B59      	CLRF FCD_056e1__000AD_1_FCR_RETVAL, 1


	#endif

	return (FCR_RETVAL);
1016  5159      	MOVF FCD_056e1__000AD_1_FCR_RETVAL, W, 1
1018  6F5A      	MOVWF CompTempVarRet2826, 1


}
101A  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/


/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()

{
ansel = 0x00;
112A  6A7E      	CLRF gbl_ansel

anselh = 0x00;
112C  6A7F      	CLRF gbl_anselh





	// Call Component Macro
	// Call Component Macro: PWM1::Enable()
	FCD_0df41_PWM1__Enable();
112E  ECB9F007  	CALL FCD_0df41__00057


	// Call Component Macro
	// Call Component Macro: v5__usbserial0::Initialise()
	FCD_056e1_v5__usbserial0__Initialise();
1132  ECF8F007  	CALL FCD_056e1__000AD


	// Loop
	// Loop: While 1
	while (1)
1136            label158
11D4  D7B0      	BRA	label158

	{

		// Call Component Macro
		// Call Component Macro: Operation=v5__usbserial0::ReadByte(10)
		FCV_OPERATION = FCD_056e1_v5__usbserial0__ReadByte(10);
1136  0E0A      	MOVLW 0x0A
1138  6F57      	MOVWF FCD_056e1__000AA_arg_FCL_T_000AB, 1
113A  EC0EF008  	CALL FCD_056e1__000AA
113E  515B      	MOVF CompTempVarRet2823, W, 1
1140  6F40      	MOVWF gbl_FCV_OPERATION, 1


		// Switch
		// Switch: Operation?
		switch (FCV_OPERATION)
		{
			case 0x31:
1142  0E31      	MOVLW 0x31
1144  6340      	CPFSEQ gbl_FCV_OPERATION, 1
1146  D001      	BRA	label159
1148  D004      	BRA	label160
114A            label159
1150  D021      	BRA	label161
1152            label160

			{
				// Call Component Macro
				// Call Component Macro: ReadInput=v5__adc0::GetInt()
				FCV_READINPUT = FCD_03521_v5__adc0__GetInt();
1152  ECDFF007  	CALL FCD_08f41__0007B
1156  5159      	MOVF CompTempVarRet2708, W, 1
1158  6F28      	MOVWF gbl_FCV_READINPUT, 1
115A  515A      	MOVF CompTempVarRet2708+D'1', W, 1
115C  6F29      	MOVWF gbl_FCV_READINPUT+D'1', 1


				// Calculation
				// Calculation:
				//  //ReadInput = 1024
				//  ReadInput = ((ReadInput << 1) | 0x1001)
				//  OutString[0] = ReadInput
				//  OutString[1] = (ReadInput >> 8)
				FCV_READINPUT = ((FCV_READINPUT << 1) | 0x1001);
115E  5328      	MOVF gbl_FCV_READINPUT, F, 1
1160  5129      	MOVF gbl_FCV_READINPUT+D'1', W, 1
1162  6F58      	MOVWF CompTempVar2830, 1
1164  90D8      	BCF STATUS,C
1166  3728      	RLCF gbl_FCV_READINPUT, F, 1
1168  3758      	RLCF CompTempVar2830, F, 1
116A  0E01      	MOVLW 0x01
116C  1328      	IORWF gbl_FCV_READINPUT, F, 1
116E  5158      	MOVF CompTempVar2830, W, 1
1170  0910      	IORLW 0x10
1172  6F57      	MOVWF CompTempVar2828, 1
1174  5157      	MOVF CompTempVar2828, W, 1
1176  6F29      	MOVWF gbl_FCV_READINPUT+D'1', 1

				FCV_OUTSTRING[0] = FCV_READINPUT;
1178  5128      	MOVF gbl_FCV_READINPUT, W, 1
117A  6F2A      	MOVWF gbl_FCV_OUTSTRING, 1

				FCV_OUTSTRING[1] = (FCV_READINPUT >> 8);
117C  5129      	MOVF gbl_FCV_READINPUT+D'1', W, 1
117E  6F2B      	MOVWF gbl_FCV_OUTSTRING+D'1', 1


				// Call Component Macro
				// Call Component Macro: v5__usbserial0::SendString(OutString)
				FCD_056e1_v5__usbserial0__SendString(FCV_OUTSTRING, FCVsz_OUTSTRING);
1180  0E02      	MOVLW HIGH(gbl_FCV_OUTSTRING+D'0')
1182  6F58      	MOVWF FCD_056e1__000A4_arg_FCL_DATA+D'1', 1
1184  0E2A      	MOVLW LOW(gbl_FCV_OUTSTRING+D'0')
1186  6F57      	MOVWF FCD_056e1__000A4_arg_FCL_DATA, 1
1188  0E02      	MOVLW 0x02
118A  6F59      	MOVWF FCD_056e1__000A4_arg_FCLsz_DATA, 1
118C  6B5A      	CLRF FCD_056e1__000A4_arg_FCLsz_DATA+D'1', 1
118E  EC56F008  	CALL FCD_056e1__000A4


				break;
1192  D7D1      	BRA	label158

			}
			case 0x32:
114A  0E32      	MOVLW 0x32
114C  6340      	CPFSEQ gbl_FCV_OPERATION, 1
114E  D7F3      	BRA	label158
1194            label161

			{
				// Call Component Macro
				// Call Component Macro: ReadInput=v5__adc1::GetInt()
				FCV_READINPUT = FCD_03522_v5__adc1__GetInt();
1194  ECC6F007  	CALL FCD_08f42__0006A
1198  5159      	MOVF CompTempVarRet2684, W, 1
119A  6F28      	MOVWF gbl_FCV_READINPUT, 1
119C  515A      	MOVF CompTempVarRet2684+D'1', W, 1
119E  6F29      	MOVWF gbl_FCV_READINPUT+D'1', 1


				// Calculation
				// Calculation:
				//  //ReadInput = 1024
				//  ReadInput = ((ReadInput << 1) | 0x1001)
				//  OutString[0] = ReadInput
				//  OutString[1] = (ReadInput >> 8)
				FCV_READINPUT = ((FCV_READINPUT << 1) | 0x1001);
11A0  5328      	MOVF gbl_FCV_READINPUT, F, 1
11A2  5129      	MOVF gbl_FCV_READINPUT+D'1', W, 1
11A4  6F58      	MOVWF CompTempVar2838, 1
11A6  90D8      	BCF STATUS,C
11A8  3728      	RLCF gbl_FCV_READINPUT, F, 1
11AA  3758      	RLCF CompTempVar2838, F, 1
11AC  0E01      	MOVLW 0x01
11AE  1328      	IORWF gbl_FCV_READINPUT, F, 1
11B0  5158      	MOVF CompTempVar2838, W, 1
11B2  0910      	IORLW 0x10
11B4  6F57      	MOVWF CompTempVar2836, 1
11B6  5157      	MOVF CompTempVar2836, W, 1
11B8  6F29      	MOVWF gbl_FCV_READINPUT+D'1', 1

				FCV_OUTSTRING[0] = FCV_READINPUT;
11BA  5128      	MOVF gbl_FCV_READINPUT, W, 1
11BC  6F2A      	MOVWF gbl_FCV_OUTSTRING, 1

				FCV_OUTSTRING[1] = (FCV_READINPUT >> 8);
11BE  5129      	MOVF gbl_FCV_READINPUT+D'1', W, 1
11C0  6F2B      	MOVWF gbl_FCV_OUTSTRING+D'1', 1


				// Call Component Macro
				// Call Component Macro: v5__usbserial0::SendString(OutString)
				FCD_056e1_v5__usbserial0__SendString(FCV_OUTSTRING, FCVsz_OUTSTRING);
11C2  0E02      	MOVLW HIGH(gbl_FCV_OUTSTRING+D'0')
11C4  6F58      	MOVWF FCD_056e1__000A4_arg_FCL_DATA+D'1', 1
11C6  0E2A      	MOVLW LOW(gbl_FCV_OUTSTRING+D'0')
11C8  6F57      	MOVWF FCD_056e1__000A4_arg_FCL_DATA, 1
11CA  0E02      	MOVLW 0x02
11CC  6F59      	MOVWF FCD_056e1__000A4_arg_FCLsz_DATA, 1
11CE  6B5A      	CLRF FCD_056e1__000A4_arg_FCLsz_DATA+D'1', 1
11D0  EC56F008  	CALL FCD_056e1__000A4


				break;

			}
			// default:

		}


	}

	mainendloop: goto mainendloop;
}




/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

	

	#ifdef MX_CAL_PIC 
	  usb_handle_isr(); 
141A  CFEAF001  	MOVFF FSR0H,  Int1Context
141E  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
1422  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
1426  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
142A  0E99      	MOVLW 0x99
142C  EF24F005  	GOTO	usb_handle_0007E
1430            label163

	#endif 
}
1430  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
1434  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
1438  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
143C  C001FFEA  	MOVFF Int1Context,  FSR0H
1440  0011      	RETFIE 1






/*********************************************************************
 *                    Flowcode USB Component Code
 *
 * File: pic_usb_buffer_mgt.c
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 031008 | BR | Created
 * 190711 | BR | Confirmed current version
 * 250613 | JK | Added support for 16f1455
 * 230614 | LM | Support for 18F45K50
 ********************************************************************/

#include "pic_usb_buffer_mgt.h"

#if (USB_DESCRIPTOR_BASE_ADDRESS == 0x200)
	#define USBEP0O		0x200
	#define USBEP0I		0x204
	#define USBEP1O		0x208
	#define USBEP1I		0x20C
	#define USBEP2O		0x210
	#define USBEP2I		0x214
	#define USBEP3O		0x218
	#define USBEP3I		0x21C
#endif

#if (USB_DESCRIPTOR_BASE_ADDRESS == 0x400)
	#define USBEP0O		0x400
	#define USBEP0I		0x404
	#define USBEP1O		0x408
	#define USBEP1I		0x40C
	#define USBEP2O		0x410
	#define USBEP2I		0x414
	#define USBEP3O		0x418
	#define USBEP3I		0x41C
#endif

#if (USB_DESCRIPTOR_BASE_ADDRESS == 0xd00)
	#define USBEP0O		0xd00
	#define USBEP0I		0xd04
	#define USBEP1O		0xd08
	#define USBEP1I		0xd0C
	#define USBEP2O		0xd10
	#define USBEP2I		0xd14
	#define USBEP3O		0xd18
	#define USBEP3I		0xd1C
#endif

#if (USB_DESCRIPTOR_BASE_ADDRESS == 0x2000)
	#define USBEP0O		0x2000
	#define USBEP0I		0x2004
	#define USBEP1O		0x2008
	#define USBEP1I		0x200C
	#define USBEP2O		0x2010
	#define USBEP2I		0x2014
	#define USBEP3O		0x2018
	#define USBEP3I		0x201C
#endif

#if (USB_DESCRIPTOR_BASE_ADDRESS == 0x2000)
// JK: Work around BoostC issue with FSR access only for arrays
uns8	bd0aout_stat[1]@0x2000;
uns8	bd0aout_count[1]@0x2001;
uns16	bd0aout_addr[1]@0x2002;
uns8	bd0ain_stat[1]@0x2004;
uns8	bd0ain_count[1]@0x2005;
uns16	bd0ain_addr[1]@0x2006;

uns8	bd1aout_stat[1]@0x2008;
uns8	bd1aout_count[1]@0x2009;
uns16	bd1aout_addr[1]@0x200a;
uns8	bd1ain_stat[1]@0x200c;
uns8	bd1ain_count[1]@0x200d;
uns16	bd1ain_addr[1]@0x200e;

uns8	bd2aout_stat[1]@0x2010;
uns8	bd2aout_count[1]@0x2011;
uns16	bd2aout_addr[1]@0x2012;
uns8	bd2ain_stat[1]@0x2014;
uns8	bd2ain_count[1]@0x2015;
uns16	bd2ain_addr[1]@0x2016;

uns8	bd3aout_stat[1]@0x2018;
uns8	bd3aout_count[1]@0x2019;
uns16	bd3aout_addr[1]@0x201a;
uns8	bd3ain_stat[1]@0x201c;
uns8	bd3ain_count[1]@0x201d;
uns16	bd3ain_addr[1]@0x201e;

#else
buffer_descriptor bd0out@USBEP0O;
buffer_descriptor bd0in @USBEP0I;
buffer_descriptor bd1out@USBEP1O;
buffer_descriptor bd1in @USBEP1I;
buffer_descriptor bd2out@USBEP2O;
buffer_descriptor bd2in @USBEP2I;
buffer_descriptor bd3out@USBEP3O;
buffer_descriptor bd3in @USBEP3I;
#endif


uns8 buffer_0_out[USB_EP0_OUT_SIZE]@ USB_EP0_OUT_ADDR;
uns8 buffer_0_in [USB_EP0_IN_SIZE] @ USB_EP0_IN_ADDR;

#ifdef USB_EP1_IN_SIZE
	uns8 buffer_1_in [USB_EP1_IN_SIZE] @USB_EP1_IN_ADDR;
#endif
#ifdef USB_EP1_OUT_SIZE
	uns8 buffer_1_out [USB_EP1_OUT_SIZE] @ USB_EP1_OUT_ADDR;
#endif
#ifdef USB_EP2_IN_SIZE
	uns8 buffer_2_in [USB_EP2_IN_SIZE] @ USB_EP2_IN_ADDR;
#endif
#ifdef USB_EP2_OUT_SIZE
	uns8 buffer_2_out [USB_EP2_OUT_SIZE] @ USB_EP2_OUT_ADDR;
#endif
#ifdef USB_EP3_IN_SIZE
	uns8 buffer_3_in [USB_EP3_IN_SIZE] @ USB_EP3_IN_ADDR;
#endif
#ifdef USB_EP3_OUT_SIZE
	uns8 buffer_3_out [USB_EP3_OUT_SIZE] @ USB_EP3_OUT_ADDR;
#endif

#if 0 // !defined(MX_USB_TYPE5) && !defined (MX_USB_TYPE6)
buffer_descriptor * ep_in_bd_location[USB_HIGHEST_EP + 1];
buffer_descriptor * ep_out_bd_location[USB_HIGHEST_EP + 1];
#endif

uns8 * ep_in_buffer_location[USB_HIGHEST_EP + 1] = {
	// we always have EP0

	&buffer_0_in,	// ep 0 in buffer location
135E  0E02      	MOVLW HIGH(gbl_buffer_0_in+D'0')
1360  0102      	MOVLB 0x02
1362  6F45      	MOVWF CompGblVar60, 1
1364  0E88      	MOVLW LOW(gbl_buffer_0_in+D'0')
1366  0101      	MOVLB 0x01
1368  6FA7      	MOVWF gbl_ep_in_buffer_location, 1
136A  0102      	MOVLB 0x02
136C  5145      	MOVF CompGblVar60, W, 1
136E  0101      	MOVLB 0x01
1370  6FA8      	MOVWF gbl_ep_in_buffer_location+D'1', 1


	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_IN_SIZE
			&buffer_1_in,	// ep 1 in buffer location
		#else
			0,
1372  6BA9      	CLRF gbl_ep_in_buffer_location+D'2', 1
1374  6BAA      	CLRF gbl_ep_in_buffer_location+D'3', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_IN_SIZE
			&buffer_2_in,	// ep 2 in buffer location
1376  0E02      	MOVLW HIGH(gbl_buffer_2_in+D'0')
1378  0102      	MOVLB 0x02
137A  6F46      	MOVWF CompGblVar61, 1
137C  0E90      	MOVLW LOW(gbl_buffer_2_in+D'0')
137E  0101      	MOVLB 0x01
1380  6FAB      	MOVWF gbl_ep_in_buffer_location+D'4', 1
1382  0102      	MOVLB 0x02
1384  5146      	MOVF CompGblVar61, W, 1
1386  0101      	MOVLB 0x01
1388  6FAC      	MOVWF gbl_ep_in_buffer_location+D'5', 1

		#else
			0,
		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_IN_SIZE
			&buffer_3_in,	// ep 3 in buffer location
138A  0E02      	MOVLW HIGH(gbl_buffer_3_in+D'0')
138C  0102      	MOVLB 0x02
138E  6F47      	MOVWF CompGblVar62, 1
1390  0EA0      	MOVLW LOW(gbl_buffer_3_in+D'0')
1392  0101      	MOVLB 0x01
1394  6FAD      	MOVWF gbl_ep_in_buffer_location+D'6', 1
1396  0102      	MOVLB 0x02
1398  5147      	MOVF CompGblVar62, W, 1
139A  0101      	MOVLB 0x01
139C  6FAE      	MOVWF gbl_ep_in_buffer_location+D'7', 1

		#else
			0,
		#endif
	#endif
};

uns8 * ep_out_buffer_location[USB_HIGHEST_EP + 1] = {
	// we always have EP0

	&buffer_0_out,	// ep 0 in buffer location
139E  0E02      	MOVLW HIGH(gbl_buffer_0_out+D'0')
13A0  0102      	MOVLB 0x02
13A2  6F48      	MOVWF CompGblVar63, 1
13A4  0E80      	MOVLW LOW(gbl_buffer_0_out+D'0')
13A6  0101      	MOVLB 0x01
13A8  6FAF      	MOVWF gbl_ep_out_buffer_location, 1
13AA  0102      	MOVLB 0x02
13AC  5148      	MOVF CompGblVar63, W, 1
13AE  0101      	MOVLB 0x01
13B0  6FB0      	MOVWF gbl_ep_out_buffer_location+D'1', 1


	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_OUT_SIZE
			&buffer_1_out,	// ep 1 in buffer location
		#else
			0,
13B2  6BB1      	CLRF gbl_ep_out_buffer_location+D'2', 1
13B4  6BB2      	CLRF gbl_ep_out_buffer_location+D'3', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_OUT_SIZE
			&buffer_2_out,	// ep 2 in buffer location
		#else
			0,
13B6  6BB3      	CLRF gbl_ep_out_buffer_location+D'4', 1
13B8  6BB4      	CLRF gbl_ep_out_buffer_location+D'5', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_OUT_SIZE
			&buffer_3_out,	// ep 3 in buffer location
13BA  0E02      	MOVLW HIGH(gbl_buffer_3_out+D'0')
13BC  0102      	MOVLB 0x02
13BE  6F49      	MOVWF CompGblVar64, 1
13C0  0E98      	MOVLW LOW(gbl_buffer_3_out+D'0')
13C2  0101      	MOVLB 0x01
13C4  6FB5      	MOVWF gbl_ep_out_buffer_location+D'6', 1
13C6  0102      	MOVLB 0x02
13C8  5149      	MOVF CompGblVar64, W, 1
13CA  0101      	MOVLB 0x01
13CC  6FB6      	MOVWF gbl_ep_out_buffer_location+D'7', 1

		#else
			0,
		#endif
	#endif
};


uns16 ep_in_buffer_size[USB_HIGHEST_EP + 1] = {
	USB_EP0_IN_SIZE,
13CE  0E08      	MOVLW 0x08
13D0  6FB7      	MOVWF gbl_ep_in_buffer_size, 1
13D2  6BB8      	CLRF gbl_ep_in_buffer_size+D'1', 1


	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_IN_SIZE
			USB_EP1_IN_SIZE,
		#else
			0,
13D4  6BB9      	CLRF gbl_ep_in_buffer_size+D'2', 1
13D6  6BBA      	CLRF gbl_ep_in_buffer_size+D'3', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_IN_SIZE
			USB_EP2_IN_SIZE,
13D8  0E08      	MOVLW 0x08
13DA  6FBB      	MOVWF gbl_ep_in_buffer_size+D'4', 1
13DC  6BBC      	CLRF gbl_ep_in_buffer_size+D'5', 1

		#else
			0,
		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_IN_SIZE
			USB_EP3_IN_SIZE,
13DE  0E08      	MOVLW 0x08
13E0  6FBD      	MOVWF gbl_ep_in_buffer_size+D'6', 1
13E2  6BBE      	CLRF gbl_ep_in_buffer_size+D'7', 1

		#else
			0,
		#endif
	#endif
};



uns16 ep_out_buffer_size[USB_HIGHEST_EP + 1] = {
	USB_EP0_OUT_SIZE,
13E4  0E08      	MOVLW 0x08
13E6  6FBF      	MOVWF gbl_ep_out_buffer_size, 1
13E8  6BC0      	CLRF gbl_ep_out_buffer_size+D'1', 1


	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_OUT_SIZE
			USB_EP1_OUT_SIZE,
		#else
			0,
13EA  6BC1      	CLRF gbl_ep_out_buffer_size+D'2', 1
13EC  6BC2      	CLRF gbl_ep_out_buffer_size+D'3', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_OUT_SIZE
			USB_EP2_OUT_SIZE,
		#else
			0,
13EE  6BC3      	CLRF gbl_ep_out_buffer_size+D'4', 1
13F0  6BC4      	CLRF gbl_ep_out_buffer_size+D'5', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_OUT_SIZE
			USB_EP3_OUT_SIZE,
13F2  0E08      	MOVLW 0x08
13F4  6FC5      	MOVWF gbl_ep_out_buffer_size+D'6', 1
13F6  6BC6      	CLRF gbl_ep_out_buffer_size+D'7', 1

		#else
			0,
		#endif
	#endif
};

/*********************************************************************
 *                    Flowcode USB Component Code
 *
 * File: pic_usb.c
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 031008 | BR | Created
 * 170409 | BR | Ammended Standard Request function to fix timeout bug in Linux systems
 * 010509 | BR | Slight change to allow 18FXXK50 devices to work correctly.
 * 190711 | BR | Confirmed current version
 * 230614 | LM | Support for 18F45K50
 ********************************************************************/

#include <memory.h>
#include "pic_usb.h"
#include "pic_usb_buffer_mgt.h"


// globally accessible variables

usb_state_type usb_state = st_POWERED;
13F8  0102      	MOVLB 0x02
13FA  6B42      	CLRF gbl_usb_state, 1


setup_data_packet usb_sdp;

uns8 usb_address;
control_mode_type control_mode;
uns16 delivery_bytes_to_send,
	  delivery_bytes_max_send,
		delivery_bytes_sent;
uns8 *delivery_ptr;
uns8 delivery_buffer_size;
uns8 *delivery_buffer;

usb_status_type usb_status;

void usb_configure_endpoints()

{

#ifdef USB_EP1
	set_bit  (uep1, EPHSHK);		// EP handshaking on
	#ifdef USB_EP1_OUT_SIZE
		set_bit(uep1, EPOUTEN);		// EP OUT enabled
	#else
		clear_bit(uep1, EPOUTEN);	// EP OUT disabled
	#endif
	#ifdef USB_EP1_IN_SIZE
		set_bit(uep1, EPINEN);		// EP IN enabled
	#else
		clear_bit(uep1, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep1, EPCONDIS);		// control transfers off

	// for IN
	#ifdef USB_EP1_IN_SIZE
		set_bit(bd1in_stat, DTS);		// turn on data togle sync TOGGLE
		clear_bit(bd1in_stat, KEN);		// clear the keep bit
		clear_bit(bd1in_stat, INCDIS);	// clear the increment disable
		clear_bit(bd1in_stat, DTSEN);
		clear_bit(bd1in_stat, BSTALL);	// clear stall bit
		clear_bit(bd1in_stat, BC9);
		clear_bit(bd1in_stat, BC8);

		clear_bit(bd1in_stat, UOWN);	// uC owns the buffer
	#endif
	// for OUT
	#ifdef USB_EP1_OUT_SIZE
		bd1out_count = USB_EP1_OUT_SIZE;
		bd1out_addr  = USB_EP1_OUT_ADDR;

		clear_bit(bd1out_stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd1out_stat, KEN);	// clear the keep bit
		clear_bit(bd1out_stat, INCDIS);	// clear the increment disable
		clear_bit(bd1out_stat, DTSEN);
		clear_bit(bd1out_stat, BSTALL);	// clear stall bit
		clear_bit(bd1out_stat, BC9);
		clear_bit(bd1out_stat, BC8);
		set_bit  (bd1out_stat, UOWN);	// SIE owns the buffer

	#endif
#endif

#ifdef USB_EP2
	set_bit  (uep2, EPHSHK);		// EP handshaking on
0398  010F      	MOVLB 0x0F
039A  8955      	BSF gbl_uep2,4, 1

	#ifdef USB_EP2_OUT_SIZE
		set_bit(uep2, EPOUTEN);		// EP OUT enabled
	#else
		clear_bit(uep2, EPOUTEN);	// EP OUT disabled
039C  9555      	BCF gbl_uep2,2, 1

	#endif
	#ifdef USB_EP2_IN_SIZE
		set_bit(uep2, EPINEN);		// EP IN enabled
039E  8355      	BSF gbl_uep2,1, 1

	#else
		clear_bit(uep2, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep2, EPCONDIS);		// control transfers off
03A0  8755      	BSF gbl_uep2,3, 1


	// for IN
	#ifdef USB_EP2_IN_SIZE

		set_bit(bd2in_stat, DTS);		// turn on data togle sync TOGGLE
03A2  0102      	MOVLB 0x02
03A4  8D14      	BSF gbl_bd2in,6, 1

		clear_bit(bd2in_stat, KEN);		// clear the keep bit
03A6  9B14      	BCF gbl_bd2in,5, 1

		clear_bit(bd2in_stat, INCDIS);	// clear the increment disable
03A8  9914      	BCF gbl_bd2in,4, 1

		clear_bit(bd2in_stat, DTSEN);
03AA  9714      	BCF gbl_bd2in,3, 1

		clear_bit(bd2in_stat, BSTALL);	// clear stall bit
03AC  9514      	BCF gbl_bd2in,2, 1

		clear_bit(bd2in_stat, BC9);
03AE  9314      	BCF gbl_bd2in,1, 1

		clear_bit(bd2in_stat, BC8);
03B0  9114      	BCF gbl_bd2in,0, 1


		clear_bit(bd2in_stat, UOWN);	// uC owns the buffer
03B2  9F14      	BCF gbl_bd2in,7, 1

	#endif
	// for OUT
	#ifdef USB_EP2_OUT_SIZE
		bd2out_count = USB_EP2_OUT_SIZE;
		bd2out_addr  = USB_EP2_OUT_ADDR;

		clear_bit(bd2out_stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd2out_stat, KEN);	// clear the keep bit
		clear_bit(bd2out_stat, INCDIS);	// clear the increment disable
		clear_bit(bd2out_stat, DTSEN);
		clear_bit(bd2out_stat, BSTALL);	// clear stall bit
		clear_bit(bd2out_stat, BC9);
		clear_bit(bd2out_stat, BC8);
		set_bit  (bd2out_stat, UOWN);	// SIE owns the buffer
	#endif
#endif

#ifdef USB_EP3
	set_bit  (uep3, EPHSHK);		// EP handshaking on
03B4  010F      	MOVLB 0x0F
03B6  8956      	BSF gbl_uep3,4, 1

	#ifdef USB_EP3_OUT_SIZE
		set_bit(uep3, EPOUTEN);		// EP OUT enabled
03B8  8556      	BSF gbl_uep3,2, 1

	#else
		clear_bit(uep3, EPOUTEN);	// EP OUT disabled
	#endif
	#ifdef USB_EP3_IN_SIZE
		set_bit(uep3, EPINEN);		// EP IN enabled
03BA  8356      	BSF gbl_uep3,1, 1

	#else
		clear_bit(uep3, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep3, EPCONDIS);		// control transfers off
03BC  8756      	BSF gbl_uep3,3, 1

	// for IN
	#ifdef USB_EP3_IN_SIZE
		set_bit(bd3in_stat, DTS);		// ready for toggle
03BE  0102      	MOVLB 0x02
03C0  8D1C      	BSF gbl_bd3in,6, 1

		clear_bit(bd3in_stat, KEN);		// clear the keep bit
03C2  9B1C      	BCF gbl_bd3in,5, 1

		clear_bit(bd3in_stat, INCDIS);	// clear the increment disable
03C4  991C      	BCF gbl_bd3in,4, 1

		clear_bit(bd3in_stat, DTSEN);
03C6  971C      	BCF gbl_bd3in,3, 1

		clear_bit(bd3in_stat, BSTALL);	// clear stall bit
03C8  951C      	BCF gbl_bd3in,2, 1

		clear_bit(bd3in_stat, BC9);
03CA  931C      	BCF gbl_bd3in,1, 1

		clear_bit(bd3in_stat, BC8);
03CC  911C      	BCF gbl_bd3in,0, 1


		clear_bit(bd3in_stat, UOWN);	// uC owns the buffer
03CE  9F1C      	BCF gbl_bd3in,7, 1

	#endif
	// for OUT
	#ifdef USB_EP3_OUT_SIZE
		bd3out_count = USB_EP3_OUT_SIZE;
03D0  0E08      	MOVLW 0x08
03D2  6F19      	MOVWF gbl_bd3out+D'1', 1

		bd3out_addr  = USB_EP3_OUT_ADDR;
03D4  0E98      	MOVLW 0x98
03D6  6F1A      	MOVWF gbl_bd3out+D'2', 1
03D8  0E02      	MOVLW 0x02
03DA  6F1B      	MOVWF gbl_bd3out+D'3', 1


		clear_bit(bd3out_stat, DTS);	// turn on data togle sync TOGGLE
03DC  9D18      	BCF gbl_bd3out,6, 1

		clear_bit(bd3out_stat, KEN);	// clear the keep bit
03DE  9B18      	BCF gbl_bd3out,5, 1

		clear_bit(bd3out_stat, INCDIS);	// clear the increment disable
03E0  9918      	BCF gbl_bd3out,4, 1

		clear_bit(bd3out_stat, DTSEN);
03E2  9718      	BCF gbl_bd3out,3, 1

		clear_bit(bd3out_stat, BSTALL);	// clear stall bit
03E4  9518      	BCF gbl_bd3out,2, 1

		clear_bit(bd3out_stat, BC9);
03E6  9318      	BCF gbl_bd3out,1, 1

		clear_bit(bd3out_stat, BC8);
03E8  9118      	BCF gbl_bd3out,0, 1

		set_bit  (bd3out_stat, UOWN);	// SIE owns the buffer
03EA  8F18      	BSF gbl_bd3out,7, 1

	#endif

#endif

}
03EC  0012      	RETURN


void usb_stall_ep0()

{
	set_bit(bd0in_stat, BSTALL);	// stall
00DC  0102      	MOVLB 0x02
00DE  8504      	BSF gbl_bd0in,2, 1

	set_bit(bd0in_stat, UOWN);		// SIE owns the buffer
00E0  8F04      	BSF gbl_bd0in,7, 1

	set_bit(bd0out_stat, BSTALL);	// stall
00E2  8500      	BSF gbl_bd0out,2, 1

	set_bit(bd0out_stat, UOWN);		// SIE owns the buffer
00E4  8F00      	BSF gbl_bd0out,7, 1

}
00E6  0012      	RETURN


void usb_send_data(uns8 ep, uns8 *data, uns8 send_count, bit first)

{
#if 1 // defined(MX_USB_TYPE5) || defined (MX_USB_TYPE6)
	uns8 count;
	uns8 *bdstat;
	uns8 *bdcount;
	uns16 *bdaddr;
	uns8 *buffer;

	// this is going to be an IN transaction

	// need to grab buffer descriptor
	buffer = ep_in_buffer_location[ep];
0168  0101      	MOVLB 0x01
016A  EE01F0A7  	LFSR 0x00, gbl_ep_in_buffer_location
016E  50E9      	MOVF FSR0L, W
0170  0102      	MOVLB 0x02
0172  5172      	MOVF usb_send_d_00084_arg_ep, W, 1
0174  6FA8      	MOVWF CompTempVar2744, 1
0176  90D8      	BCF STATUS,C
0178  35A8      	RLCF CompTempVar2744, W, 1
017A  26E9      	ADDWF FSR0L, F
017C  50EE      	MOVF POSTINC0, W
017E  6F7E      	MOVWF usb_send_d_00084_1_buffer, 1
0180  50EF      	MOVF INDF0, W
0182  6F7F      	MOVWF usb_send_d_00084_1_buffer+D'1', 1


	switch(ep) {
0226            label22

		case 0:
0184  5372      	MOVF usb_send_d_00084_arg_ep, F, 1
0186  E00A      	BZ	label18
019C            label18

			bdstat = &bd0in_stat;
019C  0E02      	MOVLW HIGH(gbl_bd0in+D'0')
019E  6F79      	MOVWF usb_send_d_00084_1_bdstat+D'1', 1
01A0  0E04      	MOVLW LOW(gbl_bd0in+D'0')
01A2  6F78      	MOVWF usb_send_d_00084_1_bdstat, 1

			bdcount = &bd0in_count;
01A4  0E02      	MOVLW HIGH(gbl_bd0in+D'1')
01A6  6F7B      	MOVWF usb_send_d_00084_1_bdcount+D'1', 1
01A8  0E05      	MOVLW LOW(gbl_bd0in+D'1')
01AA  6F7A      	MOVWF usb_send_d_00084_1_bdcount, 1

			bdaddr = &bd0in_addr;
01AC  0E02      	MOVLW HIGH(gbl_bd0in+D'2')
01AE  6F7D      	MOVWF usb_send_d_00084_1_bdaddr+D'1', 1
01B0  0E06      	MOVLW LOW(gbl_bd0in+D'2')
01B2  6F7C      	MOVWF usb_send_d_00084_1_bdaddr, 1

			break;
01B4  D038      	BRA	label22

		case 1:
0188  0572      	DECF usb_send_d_00084_arg_ep, W, 1
018A  E015      	BZ	label19
01B6            label19

			bdstat = &bd1in_stat;
01B6  0E02      	MOVLW HIGH(gbl_bd1in+D'0')
01B8  6FA8      	MOVWF CompTempVar2748, 1
01BA  0E0C      	MOVLW LOW(gbl_bd1in+D'0')
01BC  6F78      	MOVWF usb_send_d_00084_1_bdstat, 1
01BE  51A8      	MOVF CompTempVar2748, W, 1
01C0  6F79      	MOVWF usb_send_d_00084_1_bdstat+D'1', 1

			bdcount = &bd1in_count;
01C2  0E02      	MOVLW HIGH(gbl_bd1in+D'1')
01C4  6FA8      	MOVWF CompTempVar2749, 1
01C6  0E0D      	MOVLW LOW(gbl_bd1in+D'1')
01C8  6F7A      	MOVWF usb_send_d_00084_1_bdcount, 1
01CA  51A8      	MOVF CompTempVar2749, W, 1
01CC  6F7B      	MOVWF usb_send_d_00084_1_bdcount+D'1', 1

			bdaddr = &bd1in_addr;
01CE  0E02      	MOVLW HIGH(gbl_bd1in+D'2')
01D0  6FA8      	MOVWF CompTempVar2750, 1
01D2  0E0E      	MOVLW LOW(gbl_bd1in+D'2')
01D4  6F7C      	MOVWF usb_send_d_00084_1_bdaddr, 1
01D6  51A8      	MOVF CompTempVar2750, W, 1
01D8  6F7D      	MOVWF usb_send_d_00084_1_bdaddr+D'1', 1

			break;
01DA  D025      	BRA	label22

		case 2:
018C  0E02      	MOVLW 0x02
018E  6372      	CPFSEQ usb_send_d_00084_arg_ep, 1
0190  D001      	BRA	label17
0192  D024      	BRA	label20
0194            label17
019A  D033      	BRA	label21
01DC            label20

			bdstat = &bd2in_stat;
01DC  0E02      	MOVLW HIGH(gbl_bd2in+D'0')
01DE  6FA8      	MOVWF CompTempVar2751, 1
01E0  0E14      	MOVLW LOW(gbl_bd2in+D'0')
01E2  6F78      	MOVWF usb_send_d_00084_1_bdstat, 1
01E4  51A8      	MOVF CompTempVar2751, W, 1
01E6  6F79      	MOVWF usb_send_d_00084_1_bdstat+D'1', 1

			bdcount = &bd2in_count;
01E8  0E02      	MOVLW HIGH(gbl_bd2in+D'1')
01EA  6FA8      	MOVWF CompTempVar2752, 1
01EC  0E15      	MOVLW LOW(gbl_bd2in+D'1')
01EE  6F7A      	MOVWF usb_send_d_00084_1_bdcount, 1
01F0  51A8      	MOVF CompTempVar2752, W, 1
01F2  6F7B      	MOVWF usb_send_d_00084_1_bdcount+D'1', 1

			bdaddr = &bd2in_addr;
01F4  0E02      	MOVLW HIGH(gbl_bd2in+D'2')
01F6  6FA8      	MOVWF CompTempVar2753, 1
01F8  0E16      	MOVLW LOW(gbl_bd2in+D'2')
01FA  6F7C      	MOVWF usb_send_d_00084_1_bdaddr, 1
01FC  51A8      	MOVF CompTempVar2753, W, 1
01FE  6F7D      	MOVWF usb_send_d_00084_1_bdaddr+D'1', 1

			break;
0200  D012      	BRA	label22

		case 3:
0194  0E03      	MOVLW 0x03
0196  6372      	CPFSEQ usb_send_d_00084_arg_ep, 1
0198  D046      	BRA	label22
0202            label21

			bdstat = &bd3in_stat;
0202  0E02      	MOVLW HIGH(gbl_bd3in+D'0')
0204  6FA8      	MOVWF CompTempVar2754, 1
0206  0E1C      	MOVLW LOW(gbl_bd3in+D'0')
0208  6F78      	MOVWF usb_send_d_00084_1_bdstat, 1
020A  51A8      	MOVF CompTempVar2754, W, 1
020C  6F79      	MOVWF usb_send_d_00084_1_bdstat+D'1', 1

			bdcount = &bd3in_count;
020E  0E02      	MOVLW HIGH(gbl_bd3in+D'1')
0210  6FA8      	MOVWF CompTempVar2755, 1
0212  0E1D      	MOVLW LOW(gbl_bd3in+D'1')
0214  6F7A      	MOVWF usb_send_d_00084_1_bdcount, 1
0216  51A8      	MOVF CompTempVar2755, W, 1
0218  6F7B      	MOVWF usb_send_d_00084_1_bdcount+D'1', 1

			bdaddr = &bd3in_addr;
021A  0E02      	MOVLW HIGH(gbl_bd3in+D'2')
021C  6FA8      	MOVWF CompTempVar2756, 1
021E  0E1E      	MOVLW LOW(gbl_bd3in+D'2')
0220  6F7C      	MOVWF usb_send_d_00084_1_bdaddr, 1
0222  51A8      	MOVF CompTempVar2756, W, 1
0224  6F7D      	MOVWF usb_send_d_00084_1_bdaddr+D'1', 1

	}

	if (test_bit(*bdstat, UOWN))
0226  5179      	MOVF usb_send_d_00084_1_bdstat+D'1', W, 1
0228  6EEA      	MOVWF FSR0H
022A  5178      	MOVF usb_send_d_00084_1_bdstat, W, 1
022C  6EE9      	MOVWF FSR0L
022E  BEEF      	BTFSC INDF0,7

	{
		return;
	}

	count = 0;
0232  6B77      	CLRF usb_send_d_00084_1_count, 1

	while ((count < send_count))
0234            label23
0234  5175      	MOVF usb_send_d_00084_arg_send_count, W, 1
0236  6177      	CPFSLT usb_send_d_00084_1_count, 1
0238  D013      	BRA	label24
025E  D7EA      	BRA	label23
0260            label24

	{
	    buffer[count] = data[count];
023A  5174      	MOVF usb_send_d_00084_arg_data+D'1', W, 1
023C  6EEA      	MOVWF FSR0H
023E  5173      	MOVF usb_send_d_00084_arg_data, W, 1
0240  6EE9      	MOVWF FSR0L
0242  5177      	MOVF usb_send_d_00084_1_count, W, 1
0244  6FA8      	MOVWF CompTempVar2759, 1
0246  51A8      	MOVF CompTempVar2759, W, 1
0248  26E9      	ADDWF FSR0L, F
024A  50EF      	MOVF INDF0, W
024C  6FA9      	MOVWF CompTempVar2760, 1
024E  517F      	MOVF usb_send_d_00084_1_buffer+D'1', W, 1
0250  6EEA      	MOVWF FSR0H
0252  517E      	MOVF usb_send_d_00084_1_buffer, W, 1
0254  2577      	ADDWF usb_send_d_00084_1_count, W, 1
0256  6EE9      	MOVWF FSR0L
0258  51A9      	MOVF CompTempVar2760, W, 1
025A  6EEF      	MOVWF INDF0

	    count++;
025C  2B77      	INCF usb_send_d_00084_1_count, F, 1

	}

	*bdcount = count;
0260  517B      	MOVF usb_send_d_00084_1_bdcount+D'1', W, 1
0262  6EEA      	MOVWF FSR0H
0264  517A      	MOVF usb_send_d_00084_1_bdcount, W, 1
0266  6EE9      	MOVWF FSR0L
0268  5177      	MOVF usb_send_d_00084_1_count, W, 1
026A  6EEF      	MOVWF INDF0

	*bdaddr = (uns16)buffer;
026C  517D      	MOVF usb_send_d_00084_1_bdaddr+D'1', W, 1
026E  6EEA      	MOVWF FSR0H
0270  517C      	MOVF usb_send_d_00084_1_bdaddr, W, 1
0272  6EE9      	MOVWF FSR0L
0274  2AE9      	INCF FSR0L, F
0276  517E      	MOVF usb_send_d_00084_1_buffer, W, 1
0278  6FA8      	MOVWF CompTempVar2761, 1
027A  517F      	MOVF usb_send_d_00084_1_buffer+D'1', W, 1
027C  6EEF      	MOVWF INDF0
027E  06E9      	DECF FSR0L, F
0280  51A8      	MOVF CompTempVar2761, W, 1
0282  6EEF      	MOVWF INDF0

	if (first)
0284  A176      	BTFSS usb_send_d_00084_arg_first,0, 1
0286  D005      	BRA	label25
0292            label25

	{
		clear_bit(*bdstat, DTS);
0288  5179      	MOVF usb_send_d_00084_1_bdstat+D'1', W, 1
028A  6EEA      	MOVWF FSR0H
028C  5178      	MOVF usb_send_d_00084_1_bdstat, W, 1
028E  6EE9      	MOVWF FSR0L
0290  9CEF      	BCF INDF0,6

	}
	if (test_bit(*bdstat, DTS))
0292  5179      	MOVF usb_send_d_00084_1_bdstat+D'1', W, 1
0294  6EEA      	MOVWF FSR0H
0296  5178      	MOVF usb_send_d_00084_1_bdstat, W, 1
0298  6EE9      	MOVWF FSR0L
029A  ACEF      	BTFSS INDF0,6
029C  D006      	BRA	label26
02AA            label26

		clear_bit(*bdstat, DTS);
029E  5179      	MOVF usb_send_d_00084_1_bdstat+D'1', W, 1
02A0  6EEA      	MOVWF FSR0H
02A2  5178      	MOVF usb_send_d_00084_1_bdstat, W, 1
02A4  6EE9      	MOVWF FSR0L
02A6  9CEF      	BCF INDF0,6

	else set_bit(*bdstat, DTS);
02A8  D005      	BRA	label27
02AA  5179      	MOVF usb_send_d_00084_1_bdstat+D'1', W, 1
02AC  6EEA      	MOVWF FSR0H
02AE  5178      	MOVF usb_send_d_00084_1_bdstat, W, 1
02B0  6EE9      	MOVWF FSR0L
02B2  8CEF      	BSF INDF0,6
02B4            label27

	clear_bit(*bdstat, KEN);		// clear the keep bit
02B4  5179      	MOVF usb_send_d_00084_1_bdstat+D'1', W, 1
02B6  6EEA      	MOVWF FSR0H
02B8  5178      	MOVF usb_send_d_00084_1_bdstat, W, 1
02BA  6EE9      	MOVWF FSR0L
02BC  9AEF      	BCF INDF0,5

	clear_bit(*bdstat, INCDIS);	// clear the increment disable
02BE  98EF      	BCF INDF0,4

	set_bit  (*bdstat, DTSEN);
02C0  86EF      	BSF INDF0,3

	clear_bit(*bdstat, BSTALL);	// clear stall bit
02C2  94EF      	BCF INDF0,2

	clear_bit(*bdstat, BC9);
02C4  92EF      	BCF INDF0,1

	clear_bit(*bdstat, BC8);
02C6  90EF      	BCF INDF0,0


	set_bit  (*bdstat, UOWN);		// SIE owns the buffer
02C8  8EEF      	BSF INDF0,7

#else
	uns8 count;
	buffer_descriptor *bd;
	uns8 *buffer;

	// this is going to be an IN transaction

	// need to grab buffer descriptor
	buffer = ep_in_buffer_location[ep];

	bd = ep_in_bd_location[ep];

	if (test_bit(bd->stat, UOWN))
	{
		return;
	}

	count = 0;
	while ((count < send_count))
	{
	    buffer[count] = data[count];
	    count++;
	}

	bd->count = count;
	bd->addr = (uns16)buffer;
	if (first)
	{
		clear_bit(bd->stat, DTS);
	}
	if (test_bit(bd->stat, DTS))
		clear_bit(bd->stat, DTS);
	else set_bit(bd->stat, DTS);
	clear_bit(bd->stat, KEN);		// clear the keep bit
	clear_bit(bd->stat, INCDIS);	// clear the increment disable
	set_bit  (bd->stat, DTSEN);
	clear_bit(bd->stat, BSTALL);	// clear stall bit
	clear_bit(bd->stat, BC9);
	clear_bit(bd->stat, BC8);

	set_bit  (bd->stat, UOWN);		// SIE owns the buffer
#endif
}
0230  0012      	RETURN
02CA  0012      	RETURN



void usb_send_data_chunk()

{

uns8 count;

	count = 0;
004A  0102      	MOVLB 0x02
004C  6B76      	CLRF usb_send_d_00086_1_count, 1

	while ((count < delivery_buffer_size) &&
004E            label4
004E  514A      	MOVF gbl_delivery_buffer_size, W, 1
0050  6176      	CPFSLT usb_send_d_00086_1_count, 1
0052  D01F      	BRA	label7
0090  D7DE      	BRA	label4
0092            label7

			(delivery_bytes_sent < delivery_bytes_to_send) &&
0054  512D      	MOVF gbl_delivery_bytes_to_send+D'1', W, 1
0056  5D31      	SUBWF gbl_delivery_bytes_sent+D'1', W, 1
0058  E102      	BNZ	label5
005A  512C      	MOVF gbl_delivery_bytes_to_send, W, 1
005C  5D30      	SUBWF gbl_delivery_bytes_sent, W, 1
005E            label5
005E  E219      	BC	label7

			(delivery_bytes_sent < delivery_bytes_max_send)) {
0060  512F      	MOVF gbl_delivery_bytes_max_send+D'1', W, 1
0062  5D31      	SUBWF gbl_delivery_bytes_sent+D'1', W, 1
0064  E102      	BNZ	label6
0066  512E      	MOVF gbl_delivery_bytes_max_send, W, 1
0068  5D30      	SUBWF gbl_delivery_bytes_sent, W, 1
006A            label6
006A  E213      	BC	label7

	    delivery_buffer[count] = *delivery_ptr;
006C  5133      	MOVF gbl_delivery_ptr+D'1', W, 1
006E  6EEA      	MOVWF FSR0H
0070  5132      	MOVF gbl_delivery_ptr, W, 1
0072  6EE9      	MOVWF FSR0L
0074  50EF      	MOVF INDF0, W
0076  6F77      	MOVWF CompTempVar2766, 1
0078  5135      	MOVF gbl_delivery_buffer+D'1', W, 1
007A  6EEA      	MOVWF FSR0H
007C  5134      	MOVF gbl_delivery_buffer, W, 1
007E  2576      	ADDWF usb_send_d_00086_1_count, W, 1
0080  6EE9      	MOVWF FSR0L
0082  5177      	MOVF CompTempVar2766, W, 1
0084  6EEF      	MOVWF INDF0

	    delivery_ptr++;
0086  4B32      	INFSNZ gbl_delivery_ptr, F, 1
0088  2B33      	INCF gbl_delivery_ptr+D'1', F, 1

	    delivery_bytes_sent++;
008A  4B30      	INFSNZ gbl_delivery_bytes_sent, F, 1
008C  2B31      	INCF gbl_delivery_bytes_sent+D'1', F, 1

	    count++;
008E  2B76      	INCF usb_send_d_00086_1_count, F, 1

	}

	if ((count < delivery_buffer_size) &&
0092  514A      	MOVF gbl_delivery_buffer_size, W, 1
0094  6176      	CPFSLT usb_send_d_00086_1_count, 1
0096  D00F      	BRA	label10
00B6            label10

			((delivery_bytes_sent == delivery_bytes_max_send) ||
0098  512E      	MOVF gbl_delivery_bytes_max_send, W, 1
009A  6330      	CPFSEQ gbl_delivery_bytes_sent, 1
009C  D004      	BRA	label8
009E  512F      	MOVF gbl_delivery_bytes_max_send+D'1', W, 1
00A0  6331      	CPFSEQ gbl_delivery_bytes_sent+D'1', 1
00A2  D001      	BRA	label8
00A4  D006      	BRA	label9
00A6            label8

			(delivery_bytes_sent == delivery_bytes_to_send))) {
00A6  512C      	MOVF gbl_delivery_bytes_to_send, W, 1
00A8  6330      	CPFSEQ gbl_delivery_bytes_sent, 1
00AA  D005      	BRA	label10
00AC  512D      	MOVF gbl_delivery_bytes_to_send+D'1', W, 1
00AE  6331      	CPFSEQ gbl_delivery_bytes_sent+D'1', 1
00B0  D002      	BRA	label10
00B2            label9

		control_mode = cm_CTRL_READ_AWAITING_STATUS;	// we're done with data stage
00B2  0E05      	MOVLW 0x05
00B4  6F44      	MOVWF gbl_control_mode, 1

	}

	bd0in_count = count;
00B6  5176      	MOVF usb_send_d_00086_1_count, W, 1
00B8  6F05      	MOVWF gbl_bd0in+D'1', 1

	bd0in_addr = (uns16)&buffer_0_in;
00BA  0E02      	MOVLW HIGH(gbl_buffer_0_in+D'0')
00BC  6F07      	MOVWF gbl_bd0in+D'3', 1
00BE  0E88      	MOVLW LOW(gbl_buffer_0_in+D'0')
00C0  6F06      	MOVWF gbl_bd0in+D'2', 1

	if (test_bit(bd0in_stat, DTS))
00C2  AD04      	BTFSS gbl_bd0in,6, 1
00C4  D002      	BRA	label11
00CA            label11

		clear_bit(bd0in_stat, DTS);
00C6  9D04      	BCF gbl_bd0in,6, 1

	else set_bit(bd0in_stat, DTS);
00C8  D001      	BRA	label12
00CA  8D04      	BSF gbl_bd0in,6, 1
00CC            label12

	clear_bit(bd0in_stat, KEN);		// clear the keep bit
00CC  9B04      	BCF gbl_bd0in,5, 1

	clear_bit(bd0in_stat, INCDIS);	// clear the increment disable
00CE  9904      	BCF gbl_bd0in,4, 1

	set_bit  (bd0in_stat, DTSEN);
00D0  8704      	BSF gbl_bd0in,3, 1

	clear_bit(bd0in_stat, BSTALL);	// clear stall bit
00D2  9504      	BCF gbl_bd0in,2, 1

	clear_bit(bd0in_stat, BC9);
00D4  9304      	BCF gbl_bd0in,1, 1

	clear_bit(bd0in_stat, BC8);
00D6  9104      	BCF gbl_bd0in,0, 1


	set_bit  (bd0in_stat, UOWN);	// SIE owns the buffer
00D8  8F04      	BSF gbl_bd0in,7, 1

}
00DA  0012      	RETURN



void usb_send_empty_data_pkt()

{
	delivery_buffer_size = USB_EP0_IN_SIZE;
0128  0102      	MOVLB 0x02
012A  6F74      	MOVWF usb_send_e_00085_1___retpointvar, 1
012C  0E08      	MOVLW 0x08
012E  6F4A      	MOVWF gbl_delivery_buffer_size, 1

	delivery_buffer = &buffer_0_in;
0130  0E02      	MOVLW HIGH(gbl_buffer_0_in+D'0')
0132  6F35      	MOVWF gbl_delivery_buffer+D'1', 1
0134  0E88      	MOVLW LOW(gbl_buffer_0_in+D'0')
0136  6F34      	MOVWF gbl_delivery_buffer, 1

	delivery_bytes_sent = 0;
0138  6B30      	CLRF gbl_delivery_bytes_sent, 1
013A  6B31      	CLRF gbl_delivery_bytes_sent+D'1', 1

	delivery_bytes_to_send = 0;
013C  6B2C      	CLRF gbl_delivery_bytes_to_send, 1
013E  6B2D      	CLRF gbl_delivery_bytes_to_send+D'1', 1

	delivery_bytes_max_send = 0;
0140  6B2E      	CLRF gbl_delivery_bytes_max_send, 1
0142  6B2F      	CLRF gbl_delivery_bytes_max_send+D'1', 1

	delivery_ptr = (uns8 *) 0;
0144  6B32      	CLRF gbl_delivery_ptr, 1
0146  6B33      	CLRF gbl_delivery_ptr+D'1', 1

	clear_bit(bd0in_stat, DTS);		// ready to get toggled
0148  9D04      	BCF gbl_bd0in,6, 1

	usb_send_data_chunk();
014A  EC25F000  	CALL usb_send_d_00086

}
014E  D000      	BRA	label15
0150            label15
0150  0E01      	MOVLW	HIGH( label16 )
0152  6EFA      	MOVWF PCLATH
0154  5174      	MOVF usb_send_e_00085_1___retpointvar, W, 1
0156  26F9      	ADDWF PCL, F
0158            label16
0158  EF44F003  	GOTO	label70
015C  EF2CF003  	GOTO	label69
0160  EFEBF002  	GOTO	label55
0164  EFF3F002  	GOTO	label57


uns8 buffer_byte;

void usb_send_one_byte(uns8 data)

{
	delivery_buffer_size = USB_EP0_IN_SIZE;
00E8  6F75      	MOVWF usb_send_o_00098_1___retpointvar, 1
00EA  0E08      	MOVLW 0x08
00EC  6F4A      	MOVWF gbl_delivery_buffer_size, 1

	delivery_bytes_sent = 0;
00EE  6B30      	CLRF gbl_delivery_bytes_sent, 1
00F0  6B31      	CLRF gbl_delivery_bytes_sent+D'1', 1

	delivery_bytes_to_send = 1;
00F2  0E01      	MOVLW 0x01
00F4  6F2C      	MOVWF gbl_delivery_bytes_to_send, 1
00F6  6B2D      	CLRF gbl_delivery_bytes_to_send+D'1', 1

	delivery_bytes_max_send = 0;
00F8  6B2E      	CLRF gbl_delivery_bytes_max_send, 1
00FA  6B2F      	CLRF gbl_delivery_bytes_max_send+D'1', 1

	buffer_byte = data;
00FC  5174      	MOVF usb_send_o_00098_arg_data, W, 1
00FE  6F4C      	MOVWF gbl_buffer_byte, 1

	delivery_ptr = (uns8 *) &buffer_byte;
0100  0E02      	MOVLW HIGH(gbl_buffer_byte+D'0')
0102  6F33      	MOVWF gbl_delivery_ptr+D'1', 1
0104  0E4C      	MOVLW LOW(gbl_buffer_byte+D'0')
0106  6F32      	MOVWF gbl_delivery_ptr, 1

	delivery_buffer = &buffer_0_in;
0108  0E02      	MOVLW HIGH(gbl_buffer_0_in+D'0')
010A  6F35      	MOVWF gbl_delivery_buffer+D'1', 1
010C  0E88      	MOVLW LOW(gbl_buffer_0_in+D'0')
010E  6F34      	MOVWF gbl_delivery_buffer, 1


	clear_bit(bd0in_stat, DTS);		// ready to get toggled
0110  9D04      	BCF gbl_bd0in,6, 1

	usb_send_data_chunk();
0112  EC25F000  	CALL usb_send_d_00086

}
0116  D000      	BRA	label13
0118            label13
0118  0E01      	MOVLW	HIGH( label14 )
011A  6EFA      	MOVWF PCLATH
011C  5175      	MOVF usb_send_o_00098_1___retpointvar, W, 1
011E  26F9      	ADDWF PCL, F
0120            label14
0120  EF01F003  	GOTO	label59
0124  EF06F003  	GOTO	label61


void usb_prime_ep0_out()

{
	bd0out_count = USB_EP0_OUT_SIZE;
052C  0E08      	MOVLW 0x08
052E  0102      	MOVLB 0x02
0530  6F01      	MOVWF gbl_bd0out+D'1', 1

	bd0out_addr = USB_EP0_OUT_ADDR;
0532  0E80      	MOVLW 0x80
0534  6F02      	MOVWF gbl_bd0out+D'2', 1
0536  0E02      	MOVLW 0x02
0538  6F03      	MOVWF gbl_bd0out+D'3', 1

	set_bit(bd0out_stat, DTS);		// turn on data togle sync TOGGLE
053A  8D00      	BSF gbl_bd0out,6, 1

	clear_bit(bd0out_stat, KEN);	// clear the keep bit
053C  9B00      	BCF gbl_bd0out,5, 1

	clear_bit(bd0out_stat, INCDIS);	// clear the increment disable
053E  9900      	BCF gbl_bd0out,4, 1

	set_bit  (bd0out_stat, DTSEN);
0540  8700      	BSF gbl_bd0out,3, 1

	clear_bit(bd0out_stat, BSTALL);	// clear stall bit
0542  9500      	BCF gbl_bd0out,2, 1

	clear_bit(bd0out_stat, BC9);
0544  9300      	BCF gbl_bd0out,1, 1

	clear_bit(bd0out_stat, BC8);
0546  9100      	BCF gbl_bd0out,0, 1


	set_bit  (bd0out_stat, UOWN);	// SIE owns the buffer
0548  8F00      	BSF gbl_bd0out,7, 1

}
054A  0012      	RETURN


void usb_handle_standard_request(setup_data_packet sdp)

{
	switch (sdp.bRequest)
0612            label63

	{
		case req_Get_Descriptor:
054C  0E06      	MOVLW 0x06
054E  636B      	CPFSEQ usb_handle_0009A_arg_sdp+D'1', 1
0550  D001      	BRA	label47
0552  D00F      	BRA	label51
0554            label47
0572            label51

			uns8 descriptor_type = sdp.wValue >> 8; 	// high byte is descriptor
0572  516D      	MOVF usb_handle_0009A_arg_sdp+D'3', W, 1
0574  6F72      	MOVWF usb_handle_0009A_1_descrip_0009B, 1

			uns8 descriptor_num  = sdp.wValue & 0xff; 	// low byte is particular descriptor
0576  516C      	MOVF usb_handle_0009A_arg_sdp+D'2', W, 1
0578  6F73      	MOVWF usb_handle_0009A_1_descrip_0009C, 1


			usb_get_descriptor_callback(descriptor_type, descriptor_num, &delivery_ptr, &delivery_bytes_to_send);
057A  5172      	MOVF usb_handle_0009A_1_descrip_0009B, W, 1
057C  6F74      	MOVWF usb_get_de_0008C_arg_descr_0008D, 1
057E  5173      	MOVF usb_handle_0009A_1_descrip_0009C, W, 1
0580  6F75      	MOVWF usb_get_de_0008C_arg_descr_0008E, 1
0582  0E02      	MOVLW HIGH(gbl_delivery_ptr+D'0')
0584  6F77      	MOVWF usb_get_de_0008C_arg_rtn_d_0008F+D'1', 1
0586  0E32      	MOVLW LOW(gbl_delivery_ptr+D'0')
0588  6F76      	MOVWF usb_get_de_0008C_arg_rtn_d_0008F, 1
058A  0E02      	MOVLW HIGH(gbl_delivery_bytes_to_send+D'0')
058C  6F79      	MOVWF usb_get_de_0008C_arg_rtn_d_00090+D'1', 1
058E  0E2C      	MOVLW LOW(gbl_delivery_bytes_to_send+D'0')
0590  6F78      	MOVWF usb_get_de_0008C_arg_rtn_d_00090, 1
0592  EC66F001  	CALL usb_get_de_0008C

			if (delivery_ptr != 0)
0596  5332      	MOVF gbl_delivery_ptr, F, 1
0598  E102      	BNZ	label52
059A  5333      	MOVF gbl_delivery_ptr+D'1', F, 1
059C  E012      	BZ	label53
059E            label52
05C2            label53

			{	// we've got something
				control_mode = cm_CTRL_READ_DATA_STAGE;
059E  0E03      	MOVLW 0x03
05A0  6F44      	MOVWF gbl_control_mode, 1

				delivery_bytes_max_send = sdp.wLength;	// maximum host wants
05A2  5170      	MOVF usb_handle_0009A_arg_sdp+D'6', W, 1
05A4  6F2E      	MOVWF gbl_delivery_bytes_max_send, 1
05A6  5171      	MOVF usb_handle_0009A_arg_sdp+D'7', W, 1
05A8  6F2F      	MOVWF gbl_delivery_bytes_max_send+D'1', 1

				delivery_bytes_sent = 0;				// clear our sent countr
05AA  6B30      	CLRF gbl_delivery_bytes_sent, 1
05AC  6B31      	CLRF gbl_delivery_bytes_sent+D'1', 1

				delivery_buffer_size = USB_EP0_IN_SIZE;
05AE  0E08      	MOVLW 0x08
05B0  6F4A      	MOVWF gbl_delivery_buffer_size, 1

				delivery_buffer = (uns8 *)USB_EP0_IN_ADDR;
05B2  0E88      	MOVLW 0x88
05B4  6F34      	MOVWF gbl_delivery_buffer, 1
05B6  0E02      	MOVLW 0x02
05B8  6F35      	MOVWF gbl_delivery_buffer+D'1', 1

				clear_bit(bd0in_stat, DTS);				// ready to get toggled
05BA  9D04      	BCF gbl_bd0in,6, 1

				usb_send_data_chunk();
05BC  EC25F000  	CALL usb_send_d_00086

			}
			else
05C0  D028      	BRA	label63

			{
				usb_stall_ep0();
05C2  EC6EF000  	CALL usb_stall__00087

			}

			break;
05C6  D025      	BRA	label63

		case req_Set_Address:
0554  0E05      	MOVLW 0x05
0556  636B      	CPFSEQ usb_handle_0009A_arg_sdp+D'1', 1
0558  D001      	BRA	label48
055A  D036      	BRA	label54
055C            label48
05C8            label54

			usb_address = sdp.wValue & 0xff;
05C8  516C      	MOVF usb_handle_0009A_arg_sdp+D'2', W, 1
05CA  6F43      	MOVWF gbl_usb_address, 1

			usb_status = us_SET_ADDRESS;
05CC  0E01      	MOVLW 0x01
05CE  6F4B      	MOVWF gbl_usb_status, 1


			// Send a status ack - when we confirm that, THEN change address
			usb_send_status_ack();
05D0  0E08      	MOVLW 0x08
05D2  EF94F000  	GOTO	usb_send_e_00085
05D6            label55

			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
05D6  0E06      	MOVLW 0x06
05D8  6F44      	MOVWF gbl_control_mode, 1

			break;
05DA  D01B      	BRA	label63

		case req_Set_Configuration:
055C  0E09      	MOVLW 0x09
055E  636B      	CPFSEQ usb_handle_0009A_arg_sdp+D'1', 1
0560  D001      	BRA	label49
0562  D03C      	BRA	label56
0564            label49
05DC            label56

			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
05DC  0E06      	MOVLW 0x06
05DE  6F44      	MOVWF gbl_control_mode, 1

			usb_send_status_ack();
05E0  0E0C      	MOVLW 0x0C
05E2  EF94F000  	GOTO	usb_send_e_00085
05E6            label57

			usb_state = st_CONFIGURED;
05E6  0E03      	MOVLW 0x03
05E8  6F42      	MOVWF gbl_usb_state, 1

			// device is up - so now get the endpoints happy
			usb_configure_endpoints();
05EA  ECCCF001  	CALL usb_config_00097

			// and do a call back to let the app know we're ready
			#ifdef USB_CALLBACK_ON_DEVICE_CONFIGURED
				usb_device_configured_callback();
05EE  ECC8F001  	CALL usb_device_00096

			#endif
			break;
05F2  D00F      	BRA	label63

		case req_Get_Interface:
0564  0E0A      	MOVLW 0x0A
0566  636B      	CPFSEQ usb_handle_0009A_arg_sdp+D'1', 1
0568  D001      	BRA	label50
056A  D044      	BRA	label58
056C            label50
05F4            label58

				control_mode = cm_CTRL_READ_DATA_STAGE;
05F4  0E03      	MOVLW 0x03
05F6  6F44      	MOVWF gbl_control_mode, 1

				usb_send_one_byte(1);
05F8  0E01      	MOVLW 0x01
05FA  6F74      	MOVWF usb_send_o_00098_arg_data, 1
05FC  0E00      	MOVLW 0x00
05FE  EF74F000  	GOTO	usb_send_o_00098
0602            label59

				break;
0602  D007      	BRA	label63

		case req_Get_Status:
056C  536B      	MOVF usb_handle_0009A_arg_sdp+D'1', F, 1
056E  E04A      	BZ	label60
0604            label60

				#ifdef USB_SELF_POWERED
					usb_send_one_byte(1);
				#else
					usb_send_one_byte(0);	// bus powered
0604  6B74      	CLRF usb_send_o_00098_arg_data, 1
0606  0E04      	MOVLW 0x04
0608  EF74F000  	GOTO	usb_send_o_00098
060C            label61

				#endif
				break;
060C  D002      	BRA	label63

		default:
0570  D04E      	BRA	label62
060E            label62

			usb_stall_ep0();
060E  EC6EF000  	CALL usb_stall__00087

			break;

	}
}
0612  EF03F004  	GOTO	label77



void usb_handle_transaction()

{
	uns8 end_point, pid;
	end_point = ustat >> 3;
074A  3063      	RRCF gbl_ustat, W
074C  0102      	MOVLB 0x02
074E  6F65      	MOVWF usb_handle_0007F_1_end_point, 1
0750  3365      	RRCF usb_handle_0007F_1_end_point, F, 1
0752  3365      	RRCF usb_handle_0007F_1_end_point, F, 1
0754  0E1F      	MOVLW 0x1F
0756  1765      	ANDWF usb_handle_0007F_1_end_point, F, 1


	//read USTAT for endpoint information
	if (test_bit(ustat, DIR))
0758  A463      	BTFSS gbl_ustat,2
075A  D008      	BRA	label75
076C            label75

	{
		pid = (bd0in_stat >> 2) & 0x0f;		// mask out pid
075C  3104      	RRCF gbl_bd0in, W, 1
075E  6F66      	MOVWF usb_handle_0007F_1_pid, 1
0760  3366      	RRCF usb_handle_0007F_1_pid, F, 1
0762  0E3F      	MOVLW 0x3F
0764  1766      	ANDWF usb_handle_0007F_1_pid, F, 1
0766  0E0F      	MOVLW 0x0F
0768  1766      	ANDWF usb_handle_0007F_1_pid, F, 1

	}
	else
076A  D008      	BRA	label76
077C            label76
0928  D009      	BRA	label98
0968  D023      	BRA	label106

	{
		pid = (bd0out_stat >> 2) & 0x0f;	// mask out pid
076C  3100      	RRCF gbl_bd0out, W, 1
076E  6F67      	MOVWF CompTempVar2712, 1
0770  3367      	RRCF CompTempVar2712, F, 1
0772  0E3F      	MOVLW 0x3F
0774  1767      	ANDWF CompTempVar2712, F, 1
0776  0E0F      	MOVLW 0x0F
0778  1567      	ANDWF CompTempVar2712, W, 1
077A  6F66      	MOVWF usb_handle_0007F_1_pid, 1

	}

	if (end_point == 0)
077C  5365      	MOVF usb_handle_0007F_1_end_point, F, 1
077E  A4D8      	BTFSS STATUS,Z
0780  D0C5      	BRA	label92
090C            label92

	{
		if (pid == pid_SETUP)
0782  0E0D      	MOVLW 0x0D
0784  6366      	CPFSEQ usb_handle_0007F_1_pid, 1
0786  D06E      	BRA	label80
0864            label80

		{
			memcpy(/*dst*/ (void*)&usb_sdp, /*src*/ (void *)&buffer_0_out, 8);
0788  0E01      	MOVLW HIGH(gbl_usb_sdp+D'0')
078A  6F6E      	MOVWF memcpy8_00000_arg_dst+D'1', 1
078C  0E9F      	MOVLW LOW(gbl_usb_sdp+D'0')
078E  6F6D      	MOVWF memcpy8_00000_arg_dst, 1
0790  0E02      	MOVLW HIGH(gbl_buffer_0_out+D'0')
0792  6F70      	MOVWF memcpy8_00000_arg_src+D'1', 1
0794  0E80      	MOVLW LOW(gbl_buffer_0_out+D'0')
0796  6F6F      	MOVWF memcpy8_00000_arg_src, 1
0798  0E08      	MOVLW 0x08
079A  6F71      	MOVWF memcpy8_00000_arg_len, 1
079C  EC74F002  	CALL memcpy8_00000

			usb_prime_ep0_out();
07A0  EC96F002  	CALL usb_prime__00099


			if (!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE1) && // std request
07A4  0E40      	MOVLW 0x40
07A6  0101      	MOVLB 0x01
07A8  159F      	ANDWF gbl_usb_sdp, W, 1
07AA  0102      	MOVLB 0x02
07AC  6F67      	MOVWF CompTempVar2715, 1
07AE  6767      	TSTFSZ CompTempVar2715, 1
07B0  D02B      	BRA	label78
0808            label78

				!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE0)) {
07B2  0E20      	MOVLW 0x20
07B4  0101      	MOVLB 0x01
07B6  159F      	ANDWF gbl_usb_sdp, W, 1
07B8  0102      	MOVLB 0x02
07BA  6F68      	MOVWF CompTempVar2716, 1
07BC  6768      	TSTFSZ CompTempVar2716, 1
07BE  D024      	BRA	label78

				usb_handle_standard_request(usb_sdp);
07C0  0101      	MOVLB 0x01
07C2  51A6      	MOVF gbl_usb_sdp+D'7', W, 1
07C4  0102      	MOVLB 0x02
07C6  6F71      	MOVWF usb_handle_0009A_arg_sdp+D'7', 1
07C8  0101      	MOVLB 0x01
07CA  51A5      	MOVF gbl_usb_sdp+D'6', W, 1
07CC  0102      	MOVLB 0x02
07CE  6F70      	MOVWF usb_handle_0009A_arg_sdp+D'6', 1
07D0  0101      	MOVLB 0x01
07D2  51A4      	MOVF gbl_usb_sdp+D'5', W, 1
07D4  0102      	MOVLB 0x02
07D6  6F6F      	MOVWF usb_handle_0009A_arg_sdp+D'5', 1
07D8  0101      	MOVLB 0x01
07DA  51A3      	MOVF gbl_usb_sdp+D'4', W, 1
07DC  0102      	MOVLB 0x02
07DE  6F6E      	MOVWF usb_handle_0009A_arg_sdp+D'4', 1
07E0  0101      	MOVLB 0x01
07E2  51A2      	MOVF gbl_usb_sdp+D'3', W, 1
07E4  0102      	MOVLB 0x02
07E6  6F6D      	MOVWF usb_handle_0009A_arg_sdp+D'3', 1
07E8  0101      	MOVLB 0x01
07EA  51A1      	MOVF gbl_usb_sdp+D'2', W, 1
07EC  0102      	MOVLB 0x02
07EE  6F6C      	MOVWF usb_handle_0009A_arg_sdp+D'2', 1
07F0  0101      	MOVLB 0x01
07F2  51A0      	MOVF gbl_usb_sdp+D'1', W, 1
07F4  0102      	MOVLB 0x02
07F6  6F6B      	MOVWF usb_handle_0009A_arg_sdp+D'1', 1
07F8  0101      	MOVLB 0x01
07FA  519F      	MOVF gbl_usb_sdp, W, 1
07FC  0102      	MOVLB 0x02
07FE  6F6A      	MOVWF usb_handle_0009A_arg_sdp, 1
0800  0E99      	MOVLW 0x99
0802  EFA6F002  	GOTO	usb_handle_0009A
0806            label77

			}
			else if (!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE1) && // class request
0806  D02C      	BRA	label79
0808  0E40      	MOVLW 0x40
080A  0101      	MOVLB 0x01
080C  159F      	ANDWF gbl_usb_sdp, W, 1
080E  0102      	MOVLB 0x02
0810  6F69      	MOVWF CompTempVar2718, 1
0812  6769      	TSTFSZ CompTempVar2718, 1
0814  D025      	BRA	label79

				test_bit(usb_sdp.bmRequestType, REQUEST_TYPE0)) {
0816  0101      	MOVLB 0x01
0818  AB9F      	BTFSS gbl_usb_sdp,5, 1
081A  D022      	BRA	label79

				#ifdef USB_CALLBACK_ON_CTRL_CLASS
					usb_handle_class_request(usb_sdp);
081C  51A6      	MOVF gbl_usb_sdp+D'7', W, 1
081E  0102      	MOVLB 0x02
0820  6F71      	MOVWF usb_handle_0008B_arg_sdp+D'7', 1
0822  0101      	MOVLB 0x01
0824  51A5      	MOVF gbl_usb_sdp+D'6', W, 1
0826  0102      	MOVLB 0x02
0828  6F70      	MOVWF usb_handle_0008B_arg_sdp+D'6', 1
082A  0101      	MOVLB 0x01
082C  51A4      	MOVF gbl_usb_sdp+D'5', W, 1
082E  0102      	MOVLB 0x02
0830  6F6F      	MOVWF usb_handle_0008B_arg_sdp+D'5', 1
0832  0101      	MOVLB 0x01
0834  51A3      	MOVF gbl_usb_sdp+D'4', W, 1
0836  0102      	MOVLB 0x02
0838  6F6E      	MOVWF usb_handle_0008B_arg_sdp+D'4', 1
083A  0101      	MOVLB 0x01
083C  51A2      	MOVF gbl_usb_sdp+D'3', W, 1
083E  0102      	MOVLB 0x02
0840  6F6D      	MOVWF usb_handle_0008B_arg_sdp+D'3', 1
0842  0101      	MOVLB 0x01
0844  51A1      	MOVF gbl_usb_sdp+D'2', W, 1
0846  0102      	MOVLB 0x02
0848  6F6C      	MOVWF usb_handle_0008B_arg_sdp+D'2', 1
084A  0101      	MOVLB 0x01
084C  51A0      	MOVF gbl_usb_sdp+D'1', W, 1
084E  0102      	MOVLB 0x02
0850  6F6B      	MOVWF usb_handle_0008B_arg_sdp+D'1', 1
0852  0101      	MOVLB 0x01
0854  519F      	MOVF gbl_usb_sdp, W, 1
0856  0102      	MOVLB 0x02
0858  6F6A      	MOVWF usb_handle_0008B_arg_sdp, 1
085A  0E99      	MOVLW 0x99
085C  EF0BF003  	GOTO	usb_handle_0008B
0860            label79

				#endif
			}
			clear_bit(ucon, PKTDIS);
0860  9864      	BCF gbl_ucon,4

		}
		else if (pid == pid_IN)
0862  D0EC      	BRA	label108
0864  0E09      	MOVLW 0x09
0866  6366      	CPFSEQ usb_handle_0007F_1_pid, 1
0868  D020      	BRA	label84
08AA            label84

		{
			if (control_mode == cm_CTRL_READ_DATA_STAGE)
086A  0E03      	MOVLW 0x03
086C  6344      	CPFSEQ gbl_control_mode, 1
086E  D003      	BRA	label81
0876            label81

			{
				// it's ours, so send next chunk
				usb_send_data_chunk();
0870  EC25F000  	CALL usb_send_d_00086

			}
			else if (control_mode == cm_CTRL_WRITE_SENDING_STATUS)
0874  D0E3      	BRA	label108
0876  0E06      	MOVLW 0x06
0878  6344      	CPFSEQ gbl_control_mode, 1
087A  D00C      	BRA	label82
0894            label82

			{
				control_mode = cm_IDLE;
087C  6B44      	CLRF gbl_control_mode, 1

				if (usb_status == us_SET_ADDRESS)
087E  054B      	DECF gbl_usb_status, W, 1
0880  A4D8      	BTFSS STATUS,Z
0882  D0DC      	BRA	label108

				{
					usb_state = st_ADDRESS;
0884  0E02      	MOVLW 0x02
0886  6F42      	MOVWF gbl_usb_state, 1

					uaddr = usb_address;
0888  5143      	MOVF gbl_usb_address, W, 1
088A  010F      	MOVLB 0x0F
088C  6F5C      	MOVWF gbl_uaddr, 1

					usb_status = us_IDLE;
088E  0102      	MOVLB 0x02
0890  6B4B      	CLRF gbl_usb_status, 1

				}
			}
			else if (control_mode == cm_CTRL_READ_AWAITING_STATUS)
0892  D0D4      	BRA	label108
0894  0E05      	MOVLW 0x05
0896  6344      	CPFSEQ gbl_control_mode, 1
0898  D002      	BRA	label83
089E            label83

			{
				// Must have been last IN of the read, so still waiting for status
				nop(); // boostc bug
089A  0000      	NOP

			}
			else if (control_mode == cm_CTRL_READ_DATA_STAGE_CLASS)
089C  D0CF      	BRA	label108
089E  0E04      	MOVLW 0x04
08A0  6344      	CPFSEQ gbl_control_mode, 1
08A2  D0CC      	BRA	label108

			{
				// Must be more to come
				#ifdef USB_CALLBACK_ON_CTRL_CLASS
					usb_handle_ctrl_read_class();
08A4  EC4AF003  	CALL usb_handle_00089

				#else
					nop(); // otherwise boostc bug
				#endif
			}
		}
		else if (pid == pid_ACK)
08A8  D0C9      	BRA	label108
08AA  0E02      	MOVLW 0x02
08AC  6366      	CPFSEQ usb_handle_0007F_1_pid, 1
08AE  D011      	BRA	label87
08D2            label87

		{
			if (control_mode == cm_CTRL_READ_DATA_STAGE)
08B0  0E03      	MOVLW 0x03
08B2  6344      	CPFSEQ gbl_control_mode, 1
08B4  D003      	BRA	label85
08BC            label85

			{
				usb_send_data_chunk();
08B6  EC25F000  	CALL usb_send_d_00086

			}
			else if (control_mode == cm_CTRL_READ_DATA_STAGE_CLASS)
08BA  D0C0      	BRA	label108
08BC  0E04      	MOVLW 0x04
08BE  6344      	CPFSEQ gbl_control_mode, 1
08C0  D003      	BRA	label86
08C8            label86

			{
				#ifdef USB_CALLBACK_ON_CTRL_CLASS
					usb_handle_ctrl_read_class();
08C2  EC4AF003  	CALL usb_handle_00089

				#else
					nop(); // boostc bug
				#endif
			}
			else if (control_mode == cm_CTRL_WRITE_SENDING_STATUS)
08C6  D0BA      	BRA	label108
08C8  0E06      	MOVLW 0x06
08CA  6344      	CPFSEQ gbl_control_mode, 1
08CC  D0B7      	BRA	label108

			{
				control_mode = cm_IDLE;
08CE  6B44      	CLRF gbl_control_mode, 1

			}

		}
		else if (pid == pid_OUT)
08D0  D0B5      	BRA	label108
08D2  0566      	DECF usb_handle_0007F_1_pid, W, 1
08D4  A4D8      	BTFSS STATUS,Z
08D6  D0B2      	BRA	label108

		{
			// We've done an out
			if (control_mode == cm_CTRL_READ_AWAITING_STATUS)
08D8  0E05      	MOVLW 0x05
08DA  6344      	CPFSEQ gbl_control_mode, 1
08DC  D002      	BRA	label88
08E2            label88

			{
				control_mode = cm_IDLE;
08DE  6B44      	CLRF gbl_control_mode, 1

			}
			else if (control_mode == cm_CTRL_WRITE_DATA_STAGE_CLASS)
08E0  D012      	BRA	label91
08E2  0E02      	MOVLW 0x02
08E4  6344      	CPFSEQ gbl_control_mode, 1
08E6  D00B      	BRA	label90
08FE            label90

			{
				#ifdef USB_CALLBACK_ON_CTRL_CLASS
					usb_handle_ctrl_write_class((uns8 *)&buffer_0_out, bd0out_count);
08E8  0E02      	MOVLW HIGH(gbl_buffer_0_out+D'0')
08EA  6F68      	MOVWF usb_handle_0008A_arg_data+D'1', 1
08EC  0E80      	MOVLW LOW(gbl_buffer_0_out+D'0')
08EE  6F67      	MOVWF usb_handle_0008A_arg_data, 1
08F0  5101      	MOVF gbl_bd0out+D'1', W, 1
08F2  6F69      	MOVWF usb_handle_0008A_arg_count, 1
08F4  6B6A      	CLRF usb_handle_0008A_arg_count+D'1', 1
08F6  0E99      	MOVLW 0x99
08F8  EF2EF003  	GOTO	usb_handle_0008A
08FC            label89

					// !! should include bc bits here for total count
				#else
					nop();
				#endif
			}
			else if (control_mode == cm_CTRL_READ_DATA_STAGE)
08FC  D004      	BRA	label91
08FE  0E03      	MOVLW 0x03
0900  6344      	CPFSEQ gbl_control_mode, 1
0902  D001      	BRA	label91
0906            label91

			{
				control_mode = cm_IDLE;
0904  6B44      	CLRF gbl_control_mode, 1

			}
			usb_prime_ep0_out();
0906  EC96F002  	CALL usb_prime__00099

		}

	}
	else
090A  D098      	BRA	label108

	{
		buffer_descriptor *bd;
		if (test_bit(ustat, DIR))
090C  A463      	BTFSS gbl_ustat,2
090E  D021      	BRA	label101
0952            label101

		{
			// in
			#ifdef USB_EP_DATA_CALLBACK
#if 1 //defined(MX_USB_TYPE5) || defined (MX_USB_TYPE6)
				{
					uns8 count;
					switch (end_point) {
0940            label99

						case 0: count = bd0in_count;
0910  5365      	MOVF usb_handle_0007F_1_end_point, F, 1
0912  E101      	BNZ	label93
0914  D00A      	BRA	label95
0916            label93
092A            label95
092A  5105      	MOVF gbl_bd0in+D'1', W, 1
092C  6F67      	MOVWF usb_handle_0007F_88_count, 1

							break;
092E  D008      	BRA	label99

						case 1: count = bd1in_count;
0916  0565      	DECF usb_handle_0007F_1_end_point, W, 1
0918  E00B      	BZ	label96
0930            label96
0930  510D      	MOVF gbl_bd1in+D'1', W, 1
0932  6F67      	MOVWF usb_handle_0007F_88_count, 1

							break;
0934  D005      	BRA	label99

						case 2: count = bd2in_count;
091A  0E02      	MOVLW 0x02
091C  6365      	CPFSEQ usb_handle_0007F_1_end_point, 1
091E  D001      	BRA	label94
0920  D00A      	BRA	label97
0922            label94
0936            label97
0936  5115      	MOVF gbl_bd2in+D'1', W, 1
0938  6F67      	MOVWF usb_handle_0007F_88_count, 1

							break;
093A  D002      	BRA	label99

						case 3: count = bd3in_count;
0922  0E03      	MOVLW 0x03
0924  6365      	CPFSEQ usb_handle_0007F_1_end_point, 1
0926  D00C      	BRA	label99
093C            label98
093C  511D      	MOVF gbl_bd3in+D'1', W, 1
093E  6F67      	MOVWF usb_handle_0007F_88_count, 1

					}
					usb_ep_data_in_callback(end_point, count);
0940  5165      	MOVF usb_handle_0007F_1_end_point, W, 1
0942  6F68      	MOVWF usb_ep_dat_00094_arg_end_point, 1
0944  5167      	MOVF usb_handle_0007F_88_count, W, 1
0946  6F69      	MOVWF usb_ep_dat_00094_arg_byte_count, 1
0948  6B6A      	CLRF usb_ep_dat_00094_arg_byte_count+D'1', 1
094A  0E99      	MOVLW 0x99
094C  EF52F003  	GOTO	usb_ep_dat_00094
0950            label100

				}
#else
				bd = ep_in_bd_location[end_point];
				usb_ep_data_in_callback(end_point, bd->count);
#endif
			#else
				nop();
			#endif
		}
		else
0950  D075      	BRA	label108
0A3C            label108

		{
			// out
#if 1 //defined(MX_USB_TYPE5) || defined (MX_USB_TYPE6)
			uns8 *bdstat;
			uns8 *bdcount;

			switch (end_point) {
09C8            label107

				case 0:
0952  5365      	MOVF usb_handle_0007F_1_end_point, F, 1
0954  E00A      	BZ	label103
096A            label103

					bdstat = &bd0out_stat;
096A  0E02      	MOVLW HIGH(gbl_bd0out+D'0')
096C  6F68      	MOVWF usb_handle_0007F_97_bdstat+D'1', 1
096E  0E00      	MOVLW LOW(gbl_bd0out+D'0')
0970  6F67      	MOVWF usb_handle_0007F_97_bdstat, 1

					bdcount = &bd0out_count;
0972  0E02      	MOVLW HIGH(gbl_bd0out+D'1')
0974  6F6A      	MOVWF usb_handle_0007F_97_bdcount+D'1', 1
0976  0E01      	MOVLW LOW(gbl_bd0out+D'1')
0978  6F69      	MOVWF usb_handle_0007F_97_bdcount, 1

					break;
097A  D026      	BRA	label107

				case 1:
0956  0565      	DECF usb_handle_0007F_1_end_point, W, 1
0958  E011      	BZ	label104
097C            label104

					bdstat = &bd1out_stat;
097C  0E02      	MOVLW HIGH(gbl_bd1out+D'0')
097E  6F6B      	MOVWF CompTempVar2724, 1
0980  0E08      	MOVLW LOW(gbl_bd1out+D'0')
0982  6F67      	MOVWF usb_handle_0007F_97_bdstat, 1
0984  516B      	MOVF CompTempVar2724, W, 1
0986  6F68      	MOVWF usb_handle_0007F_97_bdstat+D'1', 1

					bdcount = &bd1out_count;
0988  0E02      	MOVLW HIGH(gbl_bd1out+D'1')
098A  6F6B      	MOVWF CompTempVar2725, 1
098C  0E09      	MOVLW LOW(gbl_bd1out+D'1')
098E  6F69      	MOVWF usb_handle_0007F_97_bdcount, 1
0990  516B      	MOVF CompTempVar2725, W, 1
0992  6F6A      	MOVWF usb_handle_0007F_97_bdcount+D'1', 1

					break;
0994  D019      	BRA	label107

				case 2:
095A  0E02      	MOVLW 0x02
095C  6365      	CPFSEQ usb_handle_0007F_1_end_point, 1
095E  D001      	BRA	label102
0960  D01A      	BRA	label105
0962            label102
0996            label105

					bdstat = &bd2out_stat;
0996  0E02      	MOVLW HIGH(gbl_bd2out+D'0')
0998  6F6B      	MOVWF CompTempVar2726, 1
099A  0E10      	MOVLW LOW(gbl_bd2out+D'0')
099C  6F67      	MOVWF usb_handle_0007F_97_bdstat, 1
099E  516B      	MOVF CompTempVar2726, W, 1
09A0  6F68      	MOVWF usb_handle_0007F_97_bdstat+D'1', 1

					bdcount = &bd2out_count;
09A2  0E02      	MOVLW HIGH(gbl_bd2out+D'1')
09A4  6F6B      	MOVWF CompTempVar2727, 1
09A6  0E11      	MOVLW LOW(gbl_bd2out+D'1')
09A8  6F69      	MOVWF usb_handle_0007F_97_bdcount, 1
09AA  516B      	MOVF CompTempVar2727, W, 1
09AC  6F6A      	MOVWF usb_handle_0007F_97_bdcount+D'1', 1

					break;
09AE  D00C      	BRA	label107

				case 3:
0962  0E03      	MOVLW 0x03
0964  6365      	CPFSEQ usb_handle_0007F_1_end_point, 1
0966  D030      	BRA	label107
09B0            label106

					bdstat = &bd3out_stat;
09B0  0E02      	MOVLW HIGH(gbl_bd3out+D'0')
09B2  6F6B      	MOVWF CompTempVar2728, 1
09B4  0E18      	MOVLW LOW(gbl_bd3out+D'0')
09B6  6F67      	MOVWF usb_handle_0007F_97_bdstat, 1
09B8  516B      	MOVF CompTempVar2728, W, 1
09BA  6F68      	MOVWF usb_handle_0007F_97_bdstat+D'1', 1

					bdcount = &bd3out_count;
09BC  0E02      	MOVLW HIGH(gbl_bd3out+D'1')
09BE  6F6B      	MOVWF CompTempVar2729, 1
09C0  0E19      	MOVLW LOW(gbl_bd3out+D'1')
09C2  6F69      	MOVWF usb_handle_0007F_97_bdcount, 1
09C4  516B      	MOVF CompTempVar2729, W, 1
09C6  6F6A      	MOVWF usb_handle_0007F_97_bdcount+D'1', 1

			}
			#ifdef USB_EP_DATA_CALLBACK
				usb_ep_data_out_callback(end_point, ep_out_buffer_location[end_point],
09C8  5165      	MOVF usb_handle_0007F_1_end_point, W, 1
09CA  6F6B      	MOVWF usb_ep_dat_00093_arg_end_point, 1
09CC  0101      	MOVLB 0x01
09CE  EE01F0AF  	LFSR 0x00, gbl_ep_out_buffer_location
09D2  50E9      	MOVF FSR0L, W
09D4  0102      	MOVLB 0x02
09D6  5165      	MOVF usb_handle_0007F_1_end_point, W, 1
09D8  6F70      	MOVWF CompTempVar2736, 1
09DA  90D8      	BCF STATUS,C
09DC  3570      	RLCF CompTempVar2736, W, 1
09DE  26E9      	ADDWF FSR0L, F
09E0  50EE      	MOVF POSTINC0, W
09E2  6F6C      	MOVWF usb_ep_dat_00093_arg_buffer, 1
09E4  50EF      	MOVF INDF0, W
09E6  6F6D      	MOVWF usb_ep_dat_00093_arg_buffer+D'1', 1
09F0  50EF      	MOVF INDF0, W
09F2  6F6E      	MOVWF usb_ep_dat_00093_arg_byte_count, 1
09F4  6B6F      	CLRF usb_ep_dat_00093_arg_byte_count+D'1', 1
09F6  EC56F003  	CALL usb_ep_dat_00093

									*bdcount);
09E8  516A      	MOVF usb_handle_0007F_97_bdcount+D'1', W, 1
09EA  6EEA      	MOVWF FSR0H
09EC  5169      	MOVF usb_handle_0007F_97_bdcount, W, 1
09EE  6EE9      	MOVWF FSR0L

			#endif

			// re-prime endpoint
			*bdcount = ep_out_buffer_size[end_point];
09FA  0101      	MOVLB 0x01
09FC  EE01F0BF  	LFSR 0x00, gbl_ep_out_buffer_size
0A00  50E9      	MOVF FSR0L, W
0A02  0102      	MOVLB 0x02
0A04  5165      	MOVF usb_handle_0007F_1_end_point, W, 1
0A06  6F6B      	MOVWF CompTempVar2739, 1
0A08  90D8      	BCF STATUS,C
0A0A  376B      	RLCF CompTempVar2739, F, 1
0A0C  516B      	MOVF CompTempVar2739, W, 1
0A0E  26E9      	ADDWF FSR0L, F
0A10  50EE      	MOVF POSTINC0, W
0A12  6F6C      	MOVWF CompTempVar2741, 1
0A14  50EF      	MOVF INDF0, W
0A16  6F6D      	MOVWF CompTempVar2741+D'1', 1
0A18  516A      	MOVF usb_handle_0007F_97_bdcount+D'1', W, 1
0A1A  6EEA      	MOVWF FSR0H
0A1C  5169      	MOVF usb_handle_0007F_97_bdcount, W, 1
0A1E  6EE9      	MOVWF FSR0L
0A20  516C      	MOVF CompTempVar2741, W, 1
0A22  6EEF      	MOVWF INDF0


			// Address shouldn't change, so don't need to update it

			clear_bit(*bdstat, DTS);		// turn on data togle sync TOGGLE
0A24  5168      	MOVF usb_handle_0007F_97_bdstat+D'1', W, 1
0A26  6EEA      	MOVWF FSR0H
0A28  5167      	MOVF usb_handle_0007F_97_bdstat, W, 1
0A2A  6EE9      	MOVWF FSR0L
0A2C  9CEF      	BCF INDF0,6

			clear_bit(*bdstat, KEN);		// clear the keep bit
0A2E  9AEF      	BCF INDF0,5

			clear_bit(*bdstat, INCDIS);	// clear the increment disable
0A30  98EF      	BCF INDF0,4

			clear_bit(*bdstat, DTSEN);
0A32  96EF      	BCF INDF0,3

			clear_bit(*bdstat, BSTALL);	// clear stall bit
0A34  94EF      	BCF INDF0,2

			clear_bit(*bdstat, BC9);
0A36  92EF      	BCF INDF0,1

			clear_bit(*bdstat, BC8);
0A38  90EF      	BCF INDF0,0

			set_bit  (*bdstat, UOWN);		// SIE owns the buffer
0A3A  8EEF      	BSF INDF0,7

#else
			bd = ep_out_bd_location[end_point];
			// issue callback
			#ifdef USB_EP_DATA_CALLBACK
				usb_ep_data_out_callback(end_point, ep_out_buffer_location[end_point],
									bd->count);
			#endif
			// re-prime endpoint
			bd->count = ep_out_buffer_size[end_point];

			// Address shouldn't change, so don't need to update it

			clear_bit(bd->stat, DTS);		// turn on data togle sync TOGGLE
			clear_bit(bd->stat, KEN);		// clear the keep bit
			clear_bit(bd->stat, INCDIS);	// clear the increment disable
			clear_bit(bd->stat, DTSEN);
			clear_bit(bd->stat, BSTALL);	// clear stall bit
			clear_bit(bd->stat, BC9);
			clear_bit(bd->stat, BC8);
			set_bit  (bd->stat, UOWN);		// SIE owns the buffer
#endif
		}
	}
}
0A3C  EF2FF005  	GOTO	label110



void usb_handle_reset()

{
	usb_address = 0;
0702  0102      	MOVLB 0x02
0704  6B43      	CLRF gbl_usb_address, 1

	//uaddr = 0;

	control_mode = cm_IDLE;
0706  6B44      	CLRF gbl_control_mode, 1

	usb_status   = us_IDLE;
0708  6B4B      	CLRF gbl_usb_status, 1


	// clear fifo
	clear_bit(uir, TRNIF);
070A  9662      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
070C  9662      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
070E  9662      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
0710  9662      	BCF gbl_uir,3


	// init buffers

	// EP0 OUT
	bd0out_count = USB_EP0_OUT_SIZE;	// 8 byte buffer
0712  0E08      	MOVLW 0x08
0714  6F01      	MOVWF gbl_bd0out+D'1', 1

	bd0out_addr = USB_EP0_OUT_ADDR;
0716  0E80      	MOVLW 0x80
0718  6F02      	MOVWF gbl_bd0out+D'2', 1
071A  0E02      	MOVLW 0x02
071C  6F03      	MOVWF gbl_bd0out+D'3', 1


	clear_bit(bd0out_stat, DTS);	// turn on data togle sync TOGGLE
071E  9D00      	BCF gbl_bd0out,6, 1

	clear_bit(bd0out_stat, KEN);	// clear the keep bit
0720  9B00      	BCF gbl_bd0out,5, 1

	clear_bit(bd0out_stat, INCDIS);	// clear the increment disable
0722  9900      	BCF gbl_bd0out,4, 1

	clear_bit  (bd0out_stat, DTSEN);	// !!!!!!
0724  9700      	BCF gbl_bd0out,3, 1

	clear_bit(bd0out_stat, BSTALL);	// clear stall bit
0726  9500      	BCF gbl_bd0out,2, 1

	clear_bit(bd0out_stat, BC9);
0728  9300      	BCF gbl_bd0out,1, 1

	clear_bit(bd0out_stat, BC8);
072A  9100      	BCF gbl_bd0out,0, 1


	set_bit  (bd0out_stat, UOWN);	// SIE owns the buffer
072C  8F00      	BSF gbl_bd0out,7, 1

					// since we expect frist transaction to be SETUP
	// EP0 IN
	bd0in_count = USB_EP0_IN_SIZE;	// 8 byte buffer
072E  0E08      	MOVLW 0x08
0730  6F05      	MOVWF gbl_bd0in+D'1', 1

	bd0in_addr = USB_EP0_IN_ADDR;
0732  0E88      	MOVLW 0x88
0734  6F06      	MOVWF gbl_bd0in+D'2', 1
0736  0E02      	MOVLW 0x02
0738  6F07      	MOVWF gbl_bd0in+D'3', 1

	clear_bit(bd0in_stat, DTS);	// turn on data togle sync TOGGLE
073A  9D04      	BCF gbl_bd0in,6, 1

	clear_bit(bd0in_stat, KEN);	// clear the keep bit
073C  9B04      	BCF gbl_bd0in,5, 1

	clear_bit(bd0in_stat, INCDIS);	// clear the increment disable
073E  9904      	BCF gbl_bd0in,4, 1

	clear_bit(bd0in_stat, BSTALL);	// clear stall bit
0740  9504      	BCF gbl_bd0in,2, 1

	clear_bit(bd0in_stat, BC9);
0742  9304      	BCF gbl_bd0in,1, 1

	clear_bit(bd0in_stat, BC8);
0744  9104      	BCF gbl_bd0in,0, 1


	clear_bit(bd0in_stat, UOWN);	// uC owns the buffer
0746  9F04      	BCF gbl_bd0in,7, 1

}
0748  0012      	RETURN



void usb_handle_stall()

{
}
0700  0012      	RETURN



void usb_handle_isr()

{
	if (test_bit(PIRREG, USBIF))			//USB Interrupt?
0A48  A4A1      	BTFSS gbl_pir2,2
0A4A  D01F      	BRA	label115

	{
		clear_bit(PIRREG, USBIF);			//Clear USB Interrupt
0A4C  94A1      	BCF gbl_pir2,2


		if (test_bit(uir, IDLEIF))		//USB Idle Interrupt?
0A4E  A862      	BTFSS gbl_uir,4
0A50  D001      	BRA	label109
0A54            label109

		{
			clear_bit(uir, IDLEIF);		//Clear Idle
0A52  9862      	BCF gbl_uir,4

		}

		if (test_bit(uir, TRNIF))		//USB Transaction detected?
0A54  A662      	BTFSS gbl_uir,3
0A56  D004      	BRA	label111
0A60            label111

		{
			usb_handle_transaction();	//Handle the transaction
0A58  0E99      	MOVLW 0x99
0A5A  EFA5F003  	GOTO	usb_handle_0007F
0A5E            label110

			clear_bit(uir, TRNIF);		//Clear the interrupt
0A5E  9662      	BCF gbl_uir,3

		}

		if (test_bit(uir, URSTIF))		//USB Reset detected?
0A60  A062      	BTFSS gbl_uir,0
0A62  D003      	BRA	label112
0A6A            label112

		{
			usb_handle_reset();			//Deal with the reset
0A64  EC81F003  	CALL usb_handle_00080

			clear_bit(uir, URSTIF);		//Clear the interrupt
0A68  9062      	BCF gbl_uir,0

		}

		if (test_bit(uir, STALLIF))		//USB Stall detected?
0A6A  AA62      	BTFSS gbl_uir,5
0A6C  D003      	BRA	label113
0A74            label113

		{
			usb_handle_stall();			//Handle the stall
0A6E  EC80F003  	CALL usb_handle_00081

			clear_bit(uir, STALLIF);	//Clear the interrupt
0A72  9A62      	BCF gbl_uir,5

		}
		if (test_bit(uir, SOFIF))		//USB Start of frame detected?
0A74  AC62      	BTFSS gbl_uir,6
0A76  D009      	BRA	label115
0A8A            label115

		{
			#ifdef USB_CALLBACK_ON_SOF
				usb_SOF_callback(ufrml);	// sourceboost defines this
0A78  010F      	MOVLB 0x0F
0A7A  515D      	MOVF gbl_ufrml, W, 1
0A7C  0102      	MOVLB 0x02
0A7E  6F65      	MOVWF usb_SOF_ca_00082_arg_frame, 1
0A80  6B66      	CLRF usb_SOF_ca_00082_arg_frame+D'1', 1
0A82  0E99      	MOVLW 0x99
0A84  EF20F005  	GOTO	usb_SOF_ca_00082
0A88            label114

			#endif
 			clear_bit(uir, SOFIF);		//Clear the interrupt
0A88  9C62      	BCF gbl_uir,6

		}
	}
}
0A8A  EF18F00A  	GOTO	label163



void usb_setup()

{
	usb_state = st_POWERED;
0A8E  0102      	MOVLB 0x02
0A90  6B42      	CLRF gbl_usb_state, 1


	// init hardware
        #if (USB_DESCRIPTOR_ADDRESS != 0x2000)
	// JK: Bit is reserved for 16f1455 series, do not touch
        clear_bit(ucfg, 3);     // enable internal tranceiver   -- BR Modded from UTRDIS to 3 for K50 devices
0A92  9661      	BCF gbl_ucfg,3

	#endif
	set_bit(ucfg, FSEN);	// clear for low speed, set for high speed
0A94  8461      	BSF gbl_ucfg,2

	set_bit  (ucfg, UPUEN);	// enable on-chip pull-ups
0A96  8861      	BSF gbl_ucfg,4


	clear_bit(ucfg, PPB1);	// disable double buffering for now
0A98  9261      	BCF gbl_ucfg,1

	clear_bit(ucfg, PPB0);
0A9A  9061      	BCF gbl_ucfg,0


	// init endpoints
	set_bit(uep0,   EPHSHK);	// EP0 handshaking on
0A9C  010F      	MOVLB 0x0F
0A9E  8953      	BSF gbl_uep0,4, 1

	set_bit(uep0,   EPOUTEN);	// EP0 OUT enable
0AA0  8553      	BSF gbl_uep0,2, 1

	set_bit(uep0,   EPINEN); 	// EP0 IN enable
0AA2  8353      	BSF gbl_uep0,1, 1

	clear_bit(uep0, EPCONDIS);	// EP0 control transfers on (and IN and OUT)
0AA4  9753      	BCF gbl_uep0,3, 1


	// init interrupts
	set_bit(uie,  STALLIE);		// interrupt on stall
0AA6  8A60      	BSF gbl_uie,5

	set_bit(uie,  TRNIE);		// on transaction complete
0AA8  8660      	BSF gbl_uie,3

	set_bit(uie,  URSTIE);		// on reset
0AAA  8060      	BSF gbl_uie,0

	set_bit(PIEREG, USBIE);		// general USB interrupts
0AAC  84A0      	BSF gbl_pie2,2

	#ifdef USB_CALLBACK_ON_SOF
		set_bit(uie, SOFIE);
0AAE  8C60      	BSF gbl_uie,6

	#endif

}
0AB0  0012      	RETURN


void usb_enable_module()

{
	// enable usb module
	uir = 0;
0AF2  6A62      	CLRF gbl_uir

	set_bit(ucon, USBEN);		// enable USB serial interface engine (SIE)
0AF4  8664      	BSF gbl_ucon,3

	usb_state = st_DEFAULT;
0AF6  0E01      	MOVLW 0x01
0AF8  0102      	MOVLB 0x02
0AFA  6F42      	MOVWF gbl_usb_state, 1

}
0AFC  0012      	RETURN



usb_state_type usb_get_state()
{
	return usb_state;
}

/*********************************************************************
 *                    Flowcode USB Component Code
 *
 * File: usb_cdc_class.c
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 031008 | BR | Created
 * 190711 | BR | Confirmed current version
 * 230614 | LM | Support for 18F45K50
 ********************************************************************/

// USB includes
#include "pic_usb.h"
#include "pic_usb_buffer_mgt.h"

// local includes
#include "usb_cdc_class.h"

// system includes
#include <memory.h>

// class definitions

#define req_SEND_ENCAPSULATED_COMMAND	0x00
#define req_GET_ENCAPSULATED_RESPONSE	0x01
#define	req_SET_COMM_FEATURE			0x02
#define req_GET_COMM_FEATURE			0x03
#define req_CLEAR_COMM_FEATURE			0x04
#define req_SET_LINE_CODING				0x20
#define req_GET_LINE_CODING				0x21
#define req_SET_CONTROL_LINE_STATE		0x22
#define req_SEND_BREAK					0x23

typedef  union _long_union{
		long as_long;
		uns8 as_byte_array[4];
} long_union;


typedef struct _line_coding {
	long_union	dte_rate;
	uns8	stop_bits;	// 0=1 stop bit, 1=1.5 stop bits, 2=2 stop bits
	uns8	parity;		// 0=None, 1=Odd, 2=Even, 3=Mark, 4=Space
	uns8	data_bits;	// 5,6,7,8 or 16 bits
}	line_coding;

/** Transmit fifo  */
uns8 cdc_tx_buffer[CDC_TX_BUFFER_SIZE];
/** Transmit fifo start point */
uns8 cdc_tx_start=0;
13FC  6B4D      	CLRF gbl_cdc_tx_start, 1

/** Transmit fifo end point */
uns8 cdc_tx_end=0;
13FE  6B4E      	CLRF gbl_cdc_tx_end, 1


/** Receive fifo */
uns8 cdc_rx_buffer[CDC_RX_BUFFER_SIZE];
/** Receive fifo start point */
uns8 cdc_rx_start = 0;
1400  6B4F      	CLRF gbl_cdc_rx_start, 1

/** Receive fifo end point */
uns8 cdc_rx_end = 0;
1402  6B50      	CLRF gbl_cdc_rx_end, 1



uns8 class_data[8];	// we'll dump all our class data in here

void usb_handle_class_request(setup_data_packet sdp) {


	switch (sdp.bRequest) {

		case req_SET_LINE_CODING:
0616  0E20      	MOVLW 0x20
0618  636B      	CPFSEQ usb_handle_0008B_arg_sdp+D'1', 1
061A  D001      	BRA	label64
061C  D008      	BRA	label66
061E            label64
062C  D010      	BRA	label68
062E            label66

			// we now expect the line coding to arrive in the data stage
			control_mode = cm_CTRL_WRITE_DATA_STAGE_CLASS;
062E  0E02      	MOVLW 0x02
0630  6F44      	MOVWF gbl_control_mode, 1

			break;
0632  D012      	BRA	label69

		case req_GET_LINE_CODING:
061E  0E21      	MOVLW 0x21
0620  636B      	CPFSEQ usb_handle_0008B_arg_sdp+D'1', 1
0622  D001      	BRA	label65
0624  D007      	BRA	label67
0626            label65
0634            label67

			control_mode = cm_CTRL_READ_DATA_STAGE_CLASS;
0634  0E04      	MOVLW 0x04
0636  6F44      	MOVWF gbl_control_mode, 1

			//  need to prime ep0 IN with some funky data here
			usb_send_data(/*ep*/ 0, /*data*/ &class_data, /*count*/ 8, /*first*/ 1);
0638  6B72      	CLRF usb_send_d_00084_arg_ep, 1
063A  0E01      	MOVLW HIGH(gbl_class_data+D'0')
063C  6F74      	MOVWF usb_send_d_00084_arg_data+D'1', 1
063E  0EC7      	MOVLW LOW(gbl_class_data+D'0')
0640  6F73      	MOVWF usb_send_d_00084_arg_data, 1
0642  0E08      	MOVLW 0x08
0644  6F75      	MOVWF usb_send_d_00084_arg_send_count, 1
0646  8176      	BSF usb_send_d_00084_arg_first,0, 1
0648  ECB4F000  	CALL usb_send_d_00084

			// actually we know this will be the last packet, so go straight to waiting for the status ack
			break;
064C  D005      	BRA	label69

		case req_SET_CONTROL_LINE_STATE:
0626  0E22      	MOVLW 0x22
0628  636B      	CPFSEQ usb_handle_0008B_arg_sdp+D'1', 1
062A  D016      	BRA	label69
064E            label68

			// no data, so just ack the status
			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
064E  0E06      	MOVLW 0x06
0650  6F44      	MOVWF gbl_control_mode, 1

			usb_send_status_ack();
0652  0E04      	MOVLW 0x04
0654  EF94F000  	GOTO	usb_send_e_00085
0658            label69

			break;
		default:
	}
}
0658  EF30F004  	GOTO	label79


void usb_handle_ctrl_write_class(uns8 *data, uns16 count) {


	switch (usb_sdp.bRequest) {
0690            label71

		case req_SET_LINE_CODING:
065C  0E20      	MOVLW 0x20
065E  0101      	MOVLB 0x01
0660  63A0      	CPFSEQ gbl_usb_sdp+D'1', 1
0662  D016      	BRA	label71

			// dump it into class_data
			memcpy(/* dst */ (void *)&class_data,/* src */ (void *)data, count);
0664  0E01      	MOVLW HIGH(gbl_class_data+D'0')
0666  0102      	MOVLB 0x02
0668  6F6E      	MOVWF memcpy8_00000_arg_dst+D'1', 1
066A  0EC7      	MOVLW LOW(gbl_class_data+D'0')
066C  6F6D      	MOVWF memcpy8_00000_arg_dst, 1
066E  5167      	MOVF usb_handle_0008A_arg_data, W, 1
0670  6F6F      	MOVWF memcpy8_00000_arg_src, 1
0672  5168      	MOVF usb_handle_0008A_arg_data+D'1', W, 1
0674  6F70      	MOVWF memcpy8_00000_arg_src+D'1', 1
0676  5169      	MOVF usb_handle_0008A_arg_count, W, 1
0678  6F71      	MOVWF memcpy8_00000_arg_len, 1
067A  EC74F002  	CALL memcpy8_00000


			// Now we need to send an ACK status back
			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
067E  0E06      	MOVLW 0x06
0680  6F44      	MOVWF gbl_control_mode, 1

			usb_send_status_ack();
0682  0E00      	MOVLW 0x00
0684  EF94F000  	GOTO	usb_send_e_00085
0688            label70

			line_coding *my_lc;
			my_lc = (line_coding*) &class_data;
0688  0E01      	MOVLW HIGH(gbl_class_data+D'0')
068A  6F6C      	MOVWF usb_handle_0008A_1_my_lc+D'1', 1
068C  0EC7      	MOVLW LOW(gbl_class_data+D'0')
068E  6F6B      	MOVWF usb_handle_0008A_1_my_lc, 1

			break;
	}
}
0690  EF7EF004  	GOTO	label89


void usb_handle_ctrl_read_class()

{
		switch (usb_sdp.bRequest)
		{
			case req_GET_LINE_CODING:
0694  0E21      	MOVLW 0x21
0696  0101      	MOVLB 0x01
0698  63A0      	CPFSEQ gbl_usb_sdp+D'1', 1

				// we know we've already sent everything, so now wait for status
				control_mode = cm_CTRL_READ_AWAITING_STATUS;
069C  0E05      	MOVLW 0x05
069E  0102      	MOVLB 0x02
06A0  6F44      	MOVWF gbl_control_mode, 1

				break;
			default:
		}

}
069A  0012      	RETURN
06A2  0012      	RETURN


void usb_ep_data_out_callback(uns8 end_point, uns8 *buffer, uns16 byte_count)

{
	uns8 cdc_rx_next;

	// We have some data!
	if (end_point == CDC_DATA_ENDPOINT)
06AC  0E03      	MOVLW 0x03
06AE  636B      	CPFSEQ usb_ep_dat_00093_arg_end_point, 1

	{	// it's the data end point

		uns8 count;
		for (count = 0; count < byte_count; count++)
06B2  6B71      	CLRF usb_ep_dat_00093_2_count, 1
06B4            label72
06B4  516E      	MOVF usb_ep_dat_00093_arg_byte_count, W, 1
06B6  6171      	CPFSLT usb_ep_dat_00093_2_count, 1
06B8  516F      	MOVF usb_ep_dat_00093_arg_byte_count+D'1', W, 1
06BA  B4D8      	BTFSC STATUS,Z
06FC  2B71      	INCF usb_ep_dat_00093_2_count, F, 1
06FE  D7DA      	BRA	label72

		{
			cdc_rx_next = cdc_rx_end + 1;	// get next buffer position
06BE  2950      	INCF gbl_cdc_rx_end, W, 1
06C0  6F70      	MOVWF usb_ep_dat_00093_1_cdc_rx_next, 1

			if (cdc_rx_next == CDC_RX_BUFFER_SIZE)
06C2  0E40      	MOVLW 0x40
06C4  6370      	CPFSEQ usb_ep_dat_00093_1_cdc_rx_next, 1
06C6  D001      	BRA	label73
06CA            label73

			{	// if we're at the end
				cdc_rx_next = 0;	// then wrap to the beginning
06C8  6B70      	CLRF usb_ep_dat_00093_1_cdc_rx_next, 1

			}
			if (cdc_rx_next != cdc_rx_start)
06CA  514F      	MOVF gbl_cdc_rx_start, W, 1
06CC  6370      	CPFSEQ usb_ep_dat_00093_1_cdc_rx_next, 1
06CE  634F      	CPFSEQ gbl_cdc_rx_start, 1
06D0  D015      	BRA	label74
06FC            label74

			{ // if space in the fifo
				cdc_rx_buffer[cdc_rx_end] = buffer[count]; // put it in
06D2  516D      	MOVF usb_ep_dat_00093_arg_buffer+D'1', W, 1
06D4  6EEA      	MOVWF FSR0H
06D6  516C      	MOVF usb_ep_dat_00093_arg_buffer, W, 1
06D8  6EE9      	MOVWF FSR0L
06DA  5171      	MOVF usb_ep_dat_00093_2_count, W, 1
06DC  6F72      	MOVWF CompTempVar2782, 1
06DE  5172      	MOVF CompTempVar2782, W, 1
06E0  26E9      	ADDWF FSR0L, F
06E2  50EF      	MOVF INDF0, W
06E4  6F73      	MOVWF CompTempVar2783, 1
06E6  0100      	MOVLB 0x00
06E8  EE00F0A0  	LFSR 0x00, gbl_cdc_rx_buffer
06EC  50E9      	MOVF FSR0L, W
06EE  0102      	MOVLB 0x02
06F0  5150      	MOVF gbl_cdc_rx_end, W, 1
06F2  26E9      	ADDWF FSR0L, F
06F4  5173      	MOVF CompTempVar2783, W, 1
06F6  6EEF      	MOVWF INDF0

				cdc_rx_end = cdc_rx_next;  // and move pointer along
06F8  5170      	MOVF usb_ep_dat_00093_1_cdc_rx_next, W, 1
06FA  6F50      	MOVWF gbl_cdc_rx_end, 1

			} // else... just ignore it, we've lost a byte, no room in the inn
		}
	}
}
06B0  0012      	RETURN
06BC  0012      	RETURN


void usb_ep_data_in_callback(uns8 end_point, uns16 byte_count) {

	// data has been sent, so do we need to send more?
	usb_cdc_handle_tx();
06A4  ECF7F001  	CALL usb_cdc_ha_00095

}
06A8  EFA8F004  	GOTO	label100



void usb_ep_get_rx_buffer(char length, char *buffer)

{
	uns8 count;

	if (length > 64)
0AB2  0E40      	MOVLW 0x40
0AB4  655D      	CPFSGT usb_ep_get_000A2_arg_length, 1
0AB6  D002      	BRA	label116
0ABC            label116

		length = 64;		// check for buffer overflow length
0AB8  0E40      	MOVLW 0x40
0ABA  6F5D      	MOVWF usb_ep_get_000A2_arg_length, 1


	for (count = 0; count < length; count++)
0ABC  6B60      	CLRF usb_ep_get_000A2_1_count, 1
0ABE            label117
0ABE  515D      	MOVF usb_ep_get_000A2_arg_length, W, 1
0AC0  6160      	CPFSLT usb_ep_get_000A2_1_count, 1
0AC2  D014      	BRA	label118
0AE8  2B60      	INCF usb_ep_get_000A2_1_count, F, 1
0AEA  D7E9      	BRA	label117
0AEC            label118

	{
		buffer[count] = cdc_rx_buffer[count];
0AC4  0100      	MOVLB 0x00
0AC6  EE00F0A0  	LFSR 0x00, gbl_cdc_rx_buffer
0ACA  50E9      	MOVF FSR0L, W
0ACC  0102      	MOVLB 0x02
0ACE  5160      	MOVF usb_ep_get_000A2_1_count, W, 1
0AD0  6F61      	MOVWF CompTempVar2810, 1
0AD2  5161      	MOVF CompTempVar2810, W, 1
0AD4  26E9      	ADDWF FSR0L, F
0AD6  50EF      	MOVF INDF0, W
0AD8  6F62      	MOVWF CompTempVar2811, 1
0ADA  515F      	MOVF usb_ep_get_000A2_arg_buffer+D'1', W, 1
0ADC  6EEA      	MOVWF FSR0H
0ADE  515E      	MOVF usb_ep_get_000A2_arg_buffer, W, 1
0AE0  2560      	ADDWF usb_ep_get_000A2_1_count, W, 1
0AE2  6EE9      	MOVWF FSR0L
0AE4  5162      	MOVF CompTempVar2811, W, 1
0AE6  6EEF      	MOVWF INDF0

	}
	cdc_rx_end = cdc_rx_start;
0AEC  514F      	MOVF gbl_cdc_rx_start, W, 1
0AEE  6F50      	MOVWF gbl_cdc_rx_end, 1

}
0AF0  0012      	RETURN



void usb_cdc_putc(uns8 c) {

uns8 cdc_tx_next;
bit  my_store_gie;
#ifdef CDC_IDE_DEBUG
return;
#endif

	cdc_tx_next = cdc_tx_end + 1;	// get next buffer position
0DB0  294E      	INCF gbl_cdc_tx_end, W, 1
0DB2  6F62      	MOVWF usb_cdc_pu_0009D_1_cdc_tx_next, 1

	if (cdc_tx_next == CDC_TX_BUFFER_SIZE) {	// if we're at the end
0DB4  0E40      	MOVLW 0x40
0DB6  6362      	CPFSEQ usb_cdc_pu_0009D_1_cdc_tx_next, 1
0DB8  D001      	BRA	label119
0DBC            label119

		cdc_tx_next = 0;	// wrap to the beginning
0DBA  6B62      	CLRF usb_cdc_pu_0009D_1_cdc_tx_next, 1

	}

	if ((!intcon.GIE) && (cdc_tx_next == cdc_tx_start)) {
0DBC  BEF2      	BTFSC gbl_intcon,7
0DBE  D004      	BRA	label120
0DC0  514D      	MOVF gbl_cdc_tx_start, W, 1
0DC2  6362      	CPFSEQ usb_cdc_pu_0009D_1_cdc_tx_next, 1
0DC4  D001      	BRA	label120
0DC8            label120

		return;
	}
	while (cdc_tx_next == cdc_tx_start) {
0DC8  514D      	MOVF gbl_cdc_tx_start, W, 1
0DCA  6362      	CPFSEQ usb_cdc_pu_0009D_1_cdc_tx_next, 1
0DCC  D001      	BRA	label121
0DCE  D7FC      	BRA	label120
0DD0            label121

	}
	my_store_gie = intcon.GIE;	// store interrupt state
0DD0  9163      	BCF usb_cdc_pu_0009D_1_my_store_gie,0, 1
0DD2  BEF2      	BTFSC gbl_intcon,7
0DD4  8163      	BSF usb_cdc_pu_0009D_1_my_store_gie,0, 1
0DD6            label122

	kill_interrupts();	// turn off global interrupts
0DD6  9EF2      	BCF gbl_intcon,7
0DD8  BEF2      	BTFSC gbl_intcon,7
0DDA  D7FD      	BRA	label122


	cdc_tx_buffer[cdc_tx_end] = c; // put it in
0DDC  0100      	MOVLB 0x00
0DDE  EE00F060  	LFSR 0x00, gbl_cdc_tx_buffer
0DE2  50E9      	MOVF FSR0L, W
0DE4  0102      	MOVLB 0x02
0DE6  514E      	MOVF gbl_cdc_tx_end, W, 1
0DE8  26E9      	ADDWF FSR0L, F
0DEA  5161      	MOVF usb_cdc_pu_0009D_arg_c, W, 1
0DEC  6EEF      	MOVWF INDF0

	cdc_tx_end = cdc_tx_next;  // move pointer along
0DEE  5162      	MOVF usb_cdc_pu_0009D_1_cdc_tx_next, W, 1
0DF0  6F4E      	MOVWF gbl_cdc_tx_end, 1


	intcon.GIE = my_store_gie;	// restore interrupt state
0DF2  B163      	BTFSC usb_cdc_pu_0009D_1_my_store_gie,0, 1
0DF4  8EF2      	BSF gbl_intcon,7
0DF6  A163      	BTFSS usb_cdc_pu_0009D_1_my_store_gie,0, 1
0DF8  9EF2      	BCF gbl_intcon,7


}
0DC6  0012      	RETURN
0DFA  0012      	RETURN



void usb_cdc_handle_tx()

{
uns8 cdc_tx_next;
uns8 count;
uns16 buffer_size;
uns8 *buffer;
buffer_descriptor *bd;

#if 1  // defined(MX_USB_TYPE5) || defined (MX_USB_TYPE6)
	#if   (CDC_DATA_ENDPOINT == 1)
		bd = &bd1in;
	#elif (CDC_DATA_ENDPOINT == 2)
		bd = &bd2in;
	#elif (CDC_DATA_ENDPOINT == 3)
		bd = &bd3in;
03EE  0E02      	MOVLW HIGH(gbl_bd3in+D'0')
03F0  0102      	MOVLB 0x02
03F2  6F72      	MOVWF usb_cdc_ha_00095_1_bd+D'1', 1
03F4  0E1C      	MOVLW LOW(gbl_bd3in+D'0')
03F6  6F71      	MOVWF usb_cdc_ha_00095_1_bd, 1

	#else
		bd = &bd0in;
	#endif
#else
	bd = ep_in_bd_location[CDC_DATA_ENDPOINT];
#endif

	if (test_bit(bd->stat, UOWN)) {	// if there's already something in play
03F8  5172      	MOVF usb_cdc_ha_00095_1_bd+D'1', W, 1
03FA  6EEA      	MOVWF FSR0H
03FC  5171      	MOVF usb_cdc_ha_00095_1_bd, W, 1
03FE  6EE9      	MOVWF FSR0L
0400  BEEF      	BTFSC INDF0,7

		return;	// give up
	}

	buffer_size = ep_in_buffer_size[CDC_DATA_ENDPOINT];
0404  0101      	MOVLB 0x01
0406  51BD      	MOVF gbl_ep_in_buffer_size+D'6', W, 1
0408  0102      	MOVLB 0x02
040A  6F6D      	MOVWF usb_cdc_ha_00095_1_buffer_size, 1
040C  0101      	MOVLB 0x01
040E  51BE      	MOVF gbl_ep_in_buffer_size+D'7', W, 1
0410  0102      	MOVLB 0x02
0412  6F6E      	MOVWF usb_cdc_ha_00095_1_buffer_size+D'1', 1

	buffer = ep_in_buffer_location[CDC_DATA_ENDPOINT];
0414  0101      	MOVLB 0x01
0416  51AD      	MOVF gbl_ep_in_buffer_location+D'6', W, 1
0418  0102      	MOVLB 0x02
041A  6F6F      	MOVWF usb_cdc_ha_00095_1_buffer, 1
041C  0101      	MOVLB 0x01
041E  51AE      	MOVF gbl_ep_in_buffer_location+D'7', W, 1
0420  0102      	MOVLB 0x02
0422  6F70      	MOVWF usb_cdc_ha_00095_1_buffer+D'1', 1


	if (cdc_tx_end == cdc_tx_start) { // anything in the fifo?
0424  514D      	MOVF gbl_cdc_tx_start, W, 1
0426  634E      	CPFSEQ gbl_cdc_tx_end, 1
0428  D001      	BRA	label37
042C            label37

	   return; // nope
	}

	start_crit_sec();
042C  9173      	BCF usb_cdc_ha_00095_1_store_gie,0, 1
042E  BEF2      	BTFSC gbl_intcon,7
0430  8173      	BSF usb_cdc_ha_00095_1_store_gie,0, 1
0432            label38
0432  9EF2      	BCF gbl_intcon,7
0434  BEF2      	BTFSC gbl_intcon,7
0436  D7FD      	BRA	label38


	count = 0;
0438  6B6C      	CLRF usb_cdc_ha_00095_1_count, 1

	while ((cdc_tx_end != cdc_tx_start) && (count < buffer_size)) {
043A            label39
043A  514D      	MOVF gbl_cdc_tx_start, W, 1
043C  634E      	CPFSEQ gbl_cdc_tx_end, 1
043E  634D      	CPFSEQ gbl_cdc_tx_start, 1
0440  D020      	BRA	label41
0442  516D      	MOVF usb_cdc_ha_00095_1_buffer_size, W, 1
0444  616C      	CPFSLT usb_cdc_ha_00095_1_count, 1
0446  516E      	MOVF usb_cdc_ha_00095_1_buffer_size+D'1', W, 1
0448  E01C      	BZ	label41
0480  D7DC      	BRA	label39
0482            label41


		cdc_tx_next = cdc_tx_start + 1;	// get next position
044A  294D      	INCF gbl_cdc_tx_start, W, 1
044C  6F6B      	MOVWF usb_cdc_ha_00095_1_cdc_tx_next, 1

		if (cdc_tx_next == CDC_TX_BUFFER_SIZE) {	// if we're at the end of the buffer
044E  0E40      	MOVLW 0x40
0450  636B      	CPFSEQ usb_cdc_ha_00095_1_cdc_tx_next, 1
0452  D001      	BRA	label40
0456            label40

			cdc_tx_next = 0;	// wrap to the beginning
0454  6B6B      	CLRF usb_cdc_ha_00095_1_cdc_tx_next, 1

		}
		buffer[count] = cdc_tx_buffer[cdc_tx_start];	// transmit the character
0456  0100      	MOVLB 0x00
0458  EE00F060  	LFSR 0x00, gbl_cdc_tx_buffer
045C  50E9      	MOVF FSR0L, W
045E  0102      	MOVLB 0x02
0460  514D      	MOVF gbl_cdc_tx_start, W, 1
0462  6F74      	MOVWF CompTempVar2789, 1
0464  5174      	MOVF CompTempVar2789, W, 1
0466  26E9      	ADDWF FSR0L, F
0468  50EF      	MOVF INDF0, W
046A  6F75      	MOVWF CompTempVar2790, 1
046C  5170      	MOVF usb_cdc_ha_00095_1_buffer+D'1', W, 1
046E  6EEA      	MOVWF FSR0H
0470  516F      	MOVF usb_cdc_ha_00095_1_buffer, W, 1
0472  256C      	ADDWF usb_cdc_ha_00095_1_count, W, 1
0474  6EE9      	MOVWF FSR0L
0476  5175      	MOVF CompTempVar2790, W, 1
0478  6EEF      	MOVWF INDF0

		count++;
047A  2B6C      	INCF usb_cdc_ha_00095_1_count, F, 1

		cdc_tx_start = cdc_tx_next;	// move start position of fifo
047C  516B      	MOVF usb_cdc_ha_00095_1_cdc_tx_next, W, 1
047E  6F4D      	MOVWF gbl_cdc_tx_start, 1

	}
	if (count > 0) {
0482  0E00      	MOVLW 0x00
0484  656C      	CPFSGT usb_cdc_ha_00095_1_count, 1
0486  D02B      	BRA	label44
04DE            label44

		bd->count = count;
0488  5172      	MOVF usb_cdc_ha_00095_1_bd+D'1', W, 1
048A  6EEA      	MOVWF FSR0H
048C  2971      	INCF usb_cdc_ha_00095_1_bd, W, 1
048E  6EE9      	MOVWF FSR0L
0490  516C      	MOVF usb_cdc_ha_00095_1_count, W, 1
0492  6EEF      	MOVWF INDF0

		bd->addr = (uns16)buffer;
0494  06E9      	DECF FSR0L, F
0496  0E02      	MOVLW 0x02
0498  26E9      	ADDWF FSR0L, F
049A  2AE9      	INCF FSR0L, F
049C  516F      	MOVF usb_cdc_ha_00095_1_buffer, W, 1
049E  6F74      	MOVWF CompTempVar2791, 1
04A0  5170      	MOVF usb_cdc_ha_00095_1_buffer+D'1', W, 1
04A2  6EEF      	MOVWF INDF0
04A4  06E9      	DECF FSR0L, F
04A6  5174      	MOVF CompTempVar2791, W, 1
04A8  6EEF      	MOVWF INDF0

		if(test_bit(bd->stat, DTS))
04AA  5171      	MOVF usb_cdc_ha_00095_1_bd, W, 1
04AC  6EE9      	MOVWF FSR0L
04AE  ACEF      	BTFSS INDF0,6
04B0  D006      	BRA	label42
04BE            label42

			clear_bit(bd->stat, DTS);
04B2  5172      	MOVF usb_cdc_ha_00095_1_bd+D'1', W, 1
04B4  6EEA      	MOVWF FSR0H
04B6  5171      	MOVF usb_cdc_ha_00095_1_bd, W, 1
04B8  6EE9      	MOVWF FSR0L
04BA  9CEF      	BCF INDF0,6

		else set_bit(bd->stat, DTS);
04BC  D005      	BRA	label43
04BE  5172      	MOVF usb_cdc_ha_00095_1_bd+D'1', W, 1
04C0  6EEA      	MOVWF FSR0H
04C2  5171      	MOVF usb_cdc_ha_00095_1_bd, W, 1
04C4  6EE9      	MOVWF FSR0L
04C6  8CEF      	BSF INDF0,6
04C8            label43

		clear_bit(bd->stat, KEN);	// clear the keep bit
04C8  5172      	MOVF usb_cdc_ha_00095_1_bd+D'1', W, 1
04CA  6EEA      	MOVWF FSR0H
04CC  5171      	MOVF usb_cdc_ha_00095_1_bd, W, 1
04CE  6EE9      	MOVWF FSR0L
04D0  9AEF      	BCF INDF0,5

		clear_bit(bd->stat, INCDIS);	// clear the increment disable
04D2  98EF      	BCF INDF0,4

		set_bit  (bd->stat, DTSEN);
04D4  86EF      	BSF INDF0,3

		clear_bit(bd->stat, BSTALL);	// clear stall bit
04D6  94EF      	BCF INDF0,2

		clear_bit(bd->stat, BC9);
04D8  92EF      	BCF INDF0,1

		clear_bit(bd->stat, BC8);
04DA  90EF      	BCF INDF0,0


		set_bit  (bd->stat, UOWN);	// SIE owns the buffer
04DC  8EEF      	BSF INDF0,7

	}
	end_crit_sec();
04DE  B173      	BTFSC usb_cdc_ha_00095_1_store_gie,0, 1
04E0  8EF2      	BSF gbl_intcon,7
04E2  A173      	BTFSS usb_cdc_ha_00095_1_store_gie,0, 1
04E4  9EF2      	BCF gbl_intcon,7

}
0402  0012      	RETURN
042A  0012      	RETURN
04E6  0012      	RETURN


uns8 usb_cdc_rx_avail() { return (cdc_rx_end - cdc_rx_start); }
0DA6  0102      	MOVLB 0x02
0DA8  514F      	MOVF gbl_cdc_rx_start, W, 1
0DAA  5D50      	SUBWF gbl_cdc_rx_end, W, 1
0DAC  6F5B      	MOVWF CompTempVarRet2797, 1
0DAE  0012      	RETURN

uns8 usb_cdc_tx_empty() { return cdc_tx_start == cdc_tx_end; }
0D3C  0102      	MOVLB 0x02
0D3E  6B60      	CLRF CompTempVarRet2799, 1
0D40  514E      	MOVF gbl_cdc_tx_end, W, 1
0D42  634D      	CPFSEQ gbl_cdc_tx_start, 1
0D44  0012      	RETURN
0D46  2B60      	INCF CompTempVarRet2799, F, 1
0D48  0012      	RETURN


void usb_cdc_print_str(char *str) {

uns8 count;
buffer_descriptor *bd;

	for(count = 0 ; str[count] != 0; count++)
    {
        usb_cdc_putc(str[count]);
    }
}

void usb_SOF_callback(uns16 frame) {

	// we don't care about the frame number, we only care if there's something to send...
	usb_cdc_handle_tx();	// start transmission
0A40  ECF7F001  	CALL usb_cdc_ha_00095

}
0A44  EF44F005  	GOTO	label114


void usb_cdc_setup() {

	line_coding *my_lc;
	my_lc = (line_coding*) &class_data;
0D4A  0E01      	MOVLW HIGH(gbl_class_data+D'0')
0D4C  0102      	MOVLB 0x02
0D4E  6F5B      	MOVWF usb_cdc_se_000A1_1_my_lc+D'1', 1
0D50  0EC7      	MOVLW LOW(gbl_class_data+D'0')
0D52  6F5A      	MOVWF usb_cdc_se_000A1_1_my_lc, 1

	my_lc->dte_rate.as_long = 0x60090000;
0D54  515B      	MOVF usb_cdc_se_000A1_1_my_lc+D'1', W, 1
0D56  6EEA      	MOVWF FSR0H
0D58  515A      	MOVF usb_cdc_se_000A1_1_my_lc, W, 1
0D5A  6EE9      	MOVWF FSR0L
0D5C  0E03      	MOVLW 0x03
0D5E  26E9      	ADDWF FSR0L, F
0D60  0E00      	MOVLW 0x00
0D62  6F5C      	MOVWF CompTempVar2807, 1
0D64  6F5D      	MOVWF CompTempVar2807+D'1', 1
0D66  0E09      	MOVLW 0x09
0D68  6F5E      	MOVWF CompTempVar2807+D'2', 1
0D6A  0E60      	MOVLW 0x60
0D6C  6EEF      	MOVWF INDF0
0D6E  06E9      	DECF FSR0L, F
0D70  515E      	MOVF CompTempVar2807+D'2', W, 1
0D72  6EEF      	MOVWF INDF0
0D74  06E9      	DECF FSR0L, F
0D76  515D      	MOVF CompTempVar2807+D'1', W, 1
0D78  6EEF      	MOVWF INDF0
0D7A  06E9      	DECF FSR0L, F
0D7C  515C      	MOVF CompTempVar2807, W, 1
0D7E  6EEF      	MOVWF INDF0

	my_lc->stop_bits = 0;
0D80  515A      	MOVF usb_cdc_se_000A1_1_my_lc, W, 1
0D82  6EE9      	MOVWF FSR0L
0D84  0E04      	MOVLW 0x04
0D86  26E9      	ADDWF FSR0L, F
0D88  0E00      	MOVLW 0x00
0D8A  6EEF      	MOVWF INDF0

	my_lc->data_bits = 8;
0D8C  515A      	MOVF usb_cdc_se_000A1_1_my_lc, W, 1
0D8E  6EE9      	MOVWF FSR0L
0D90  0E06      	MOVLW 0x06
0D92  26E9      	ADDWF FSR0L, F
0D94  0E08      	MOVLW 0x08
0D96  6EEF      	MOVWF INDF0

	my_lc->parity = 0;
0D98  515A      	MOVF usb_cdc_se_000A1_1_my_lc, W, 1
0D9A  6EE9      	MOVWF FSR0L
0D9C  0E05      	MOVLW 0x05
0D9E  26E9      	ADDWF FSR0L, F
0DA0  0E00      	MOVLW 0x00
0DA2  6EEF      	MOVWF INDF0

}
0DA4  0012      	RETURN


/*********************************************************************
 *                    Flowcode USB Component Code
 *
 * File: usb_config_serial.c
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 031008 | BR | Created
 * 190711 | BR | Confirmed current version
 ********************************************************************/

#include "pic_usb.h"

typedef struct _configuration {
	configuration_descriptor cdc_config;
	interface_descriptor cdc_comm_interface;
	CDC_header_functional_descriptor cdc_header;
	CDC_ACM_functional_descriptor cdc_ACM;
	CDC_union_functional_descriptor cdc_union;
	CDC_call_mgt_functional_descriptor cdc_call_mgt;
	endpoint_descriptor cdc_notification_ep;
	interface_descriptor cdc_data_interface;
	endpoint_descriptor cdc_data_out_ep;
	endpoint_descriptor cdc_data_in_ep;
} configuration;


// Structure Defines
device_descriptor my_device_descriptor;
configuration_descriptor my_config;
interface_descriptor my_comm_interface;
CDC_header_functional_descriptor my_header;
CDC_ACM_functional_descriptor my_ACM;
CDC_union_functional_descriptor my_union;
CDC_call_mgt_functional_descriptor my_call_mgt;
endpoint_descriptor my_notification_ep;
interface_descriptor my_data_interface;
endpoint_descriptor my_data_out_ep;
endpoint_descriptor my_data_in_ep;
configuration complete_serial_configuration;



uns8 string_00 [] =
	{
		4,	// length,
1404  0E04      	MOVLW 0x04
1406  6F24      	MOVWF gbl_string_00, 1

		dt_STRING,	// descriptor type
1408  0E03      	MOVLW 0x03
140A  6F25      	MOVWF gbl_string_00+D'1', 1

		9,	// magic for US english
140C  0E09      	MOVLW 0x09
140E  6F26      	MOVWF gbl_string_00+D'2', 1

		4
1410  0E04      	MOVLW 0x04
1412  6F27      	MOVWF gbl_string_00+D'3', 1

	};


void usb_configure_structures(void)

{
	// device descriptor - - - - - - - - - -
	my_device_descriptor.length = sizeof(device_descriptor); 		// bytes long
0AFE  0E12      	MOVLW 0x12
0B00  6E48      	MOVWF gbl_my_device_descriptor

	my_device_descriptor.descriptor_type = dt_DEVICE; 				// DEVICE 01h
0B02  0E01      	MOVLW 0x01
0B04  6E49      	MOVWF gbl_my_device_descriptor+D'1'

	my_device_descriptor.usb_version = 0x0110;						// usb version 1.10
0B06  0E10      	MOVLW 0x10
0B08  6E4A      	MOVWF gbl_my_device_descriptor+D'2'
0B0A  0E01      	MOVLW 0x01
0B0C  6E4B      	MOVWF gbl_my_device_descriptor+D'3'

	my_device_descriptor.device_class = 2;							// class (communication device class)
0B0E  0E02      	MOVLW 0x02
0B10  6E4C      	MOVWF gbl_my_device_descriptor+D'4'

	my_device_descriptor.device_subclass = 0;						// subclass (unused)
0B12  6A4D      	CLRF gbl_my_device_descriptor+D'5'

	my_device_descriptor.device_protocol = 0;						// protocol	(unused)
0B14  6A4E      	CLRF gbl_my_device_descriptor+D'6'

	my_device_descriptor.max_packet_size_ep0 = USB_EP0_OUT_SIZE;	// max packet size for end point 0
0B16  0E08      	MOVLW 0x08
0B18  6E4F      	MOVWF gbl_my_device_descriptor+D'7'

	my_device_descriptor.vendor_id = MX_VID;						// Matrix's vendor
0B1A  0EBF      	MOVLW 0xBF
0B1C  6E50      	MOVWF gbl_my_device_descriptor+D'8'
0B1E  0E12      	MOVLW 0x12
0B20  6E51      	MOVWF gbl_my_device_descriptor+D'9'

	my_device_descriptor.product_id = MX_PID;						// Matrix's product
0B22  0E10      	MOVLW 0x10
0B24  6E52      	MOVWF gbl_my_device_descriptor+D'10'
0B26  0EF0      	MOVLW 0xF0
0B28  6E53      	MOVWF gbl_my_device_descriptor+D'11'

	my_device_descriptor.device_release = MX_VERSION;				// version 2.0 of the product
0B2A  6A54      	CLRF gbl_my_device_descriptor+D'12'
0B2C  0E01      	MOVLW 0x01
0B2E  6E55      	MOVWF gbl_my_device_descriptor+D'13'

	my_device_descriptor.manufacturer_string_id = 1;				// string 1 for manufacturer
0B30  6E56      	MOVWF gbl_my_device_descriptor+D'14'

	my_device_descriptor.product_string_id = 2;						// string 2 for product
0B32  0E02      	MOVLW 0x02
0B34  6E57      	MOVWF gbl_my_device_descriptor+D'15'

	my_device_descriptor.serial_string_id = 0;						// string 3 for serial number
0B36  6A58      	CLRF gbl_my_device_descriptor+D'16'

	my_device_descriptor.num_configurations = 1;					// number of configurations
0B38  0E01      	MOVLW 0x01
0B3A  6E59      	MOVWF gbl_my_device_descriptor+D'17'


	// configuration descriptor - - - - - - - - - -
	my_config.length = sizeof(configuration_descriptor);			// length,
0B3C  0E09      	MOVLW 0x09
0B3E  0100      	MOVLB 0x00
0B40  6FEA      	MOVWF gbl_my_config, 1

	my_config.descriptor_type = dt_CONFIGURATION;					// descriptor_type,
0B42  0E02      	MOVLW 0x02
0B44  6FEB      	MOVWF gbl_my_config+D'1', 1

	my_config.total_length = sizeof(complete_serial_configuration);	// total_length;
0B46  0E43      	MOVLW 0x43
0B48  6FEC      	MOVWF gbl_my_config+D'2', 1
0B4A  6BED      	CLRF gbl_my_config+D'3', 1

	my_config.num_interfaces = 0x02;								// num_interfaces,
0B4C  0E02      	MOVLW 0x02
0B4E  6FEE      	MOVWF gbl_my_config+D'4', 1

	my_config.configuration_value = 0x01;							// configuration_value,
0B50  0E01      	MOVLW 0x01
0B52  6FEF      	MOVWF gbl_my_config+D'5', 1

	my_config.configuration_string_id = 0x00;						// configuration_string_id,
0B54  6BF0      	CLRF gbl_my_config+D'6', 1

	my_config.attributes = 0b10000000; 								// attributes (bus powered, no remote wake up)
0B56  0E80      	MOVLW 0x80
0B58  6FF1      	MOVWF gbl_my_config+D'7', 1

	my_config.max_power = 100;										// max_power; (200ma)
0B5A  0E64      	MOVLW 0x64
0B5C  6FF2      	MOVWF gbl_my_config+D'8', 1


	// Communication interface descriptor - - - - - - - - - - - -
	my_comm_interface.length = sizeof(interface_descriptor);		// length,
0B5E  0E09      	MOVLW 0x09
0B60  6FF3      	MOVWF gbl_my_comm_interface, 1

	my_comm_interface.descriptor_type = dt_INTERFACE;				// descriptor_type,
0B62  0E04      	MOVLW 0x04
0B64  6FF4      	MOVWF gbl_my_comm_interface+D'1', 1

	my_comm_interface.interface_number = 0x00;						// interface_number, (starts at zero)
0B66  6BF5      	CLRF gbl_my_comm_interface+D'2', 1

	my_comm_interface.alternate_setting = 0x00;						// alternate_setting, (no alternatives)
0B68  6BF6      	CLRF gbl_my_comm_interface+D'3', 1

	my_comm_interface.num_endpoints = 0x01;							// num_endpoints,
0B6A  0E01      	MOVLW 0x01
0B6C  6FF7      	MOVWF gbl_my_comm_interface+D'4', 1

	my_comm_interface.interface_class = 0x02;						// interface_class, (Communication Interface Class)
0B6E  0E02      	MOVLW 0x02
0B70  6FF8      	MOVWF gbl_my_comm_interface+D'5', 1

	my_comm_interface.interface_subclass = 0x02;					// interface_subclass, (Abstract Control Model subclass)
0B72  6FF9      	MOVWF gbl_my_comm_interface+D'6', 1

	my_comm_interface.interface_protocol = 0x01;					// interface_protocol, (AT commands)
0B74  0E01      	MOVLW 0x01
0B76  6FFA      	MOVWF gbl_my_comm_interface+D'7', 1

	my_comm_interface.interface_string_id = 0x00;					// interface_string_id;
0B78  6BFB      	CLRF gbl_my_comm_interface+D'8', 1


	// CDC header functional descriptor - - - - - - - - - - - - - -
	my_header.length = sizeof(CDC_header_functional_descriptor);	// length,
0B7A  0E05      	MOVLW 0x05
0B7C  6E5A      	MOVWF gbl_my_header

	my_header.descriptor_type = dt_CS_INTERFACE;					// descriptor_type (CS_INTERFACE = 0x24)
0B7E  0E24      	MOVLW 0x24
0B80  6E5B      	MOVWF gbl_my_header+D'1'

	my_header.descriptor_subtype = 0x00;							// descriptor_subtype (Header functional descriptor = 0x00)
0B82  6A5C      	CLRF gbl_my_header+D'2'

	my_header.CDC_version = 0x0110;									// CDC_version (BCD release of CDC spec = 0x0110)
0B84  0E10      	MOVLW 0x10
0B86  6E5D      	MOVWF gbl_my_header+D'3'
0B88  0E01      	MOVLW 0x01
0B8A  6E5E      	MOVWF gbl_my_header+D'4'


	// Abstract Control Model functional descriptor - - - - - - - -
	my_ACM.length = sizeof(CDC_ACM_functional_descriptor);			// length,
0B8C  0E04      	MOVLW 0x04
0B8E  0102      	MOVLB 0x02
0B90  6F20      	MOVWF gbl_my_ACM, 1

	my_ACM.descriptor_type = dt_CS_INTERFACE;						// descriptor_type (CS_INTERFACE = 0x24)
0B92  0E24      	MOVLW 0x24
0B94  6F21      	MOVWF gbl_my_ACM+D'1', 1

	my_ACM.descriptor_subtype = 0x02;								// descriptor_subtype (ACM functional descriptor subtype = 0x02)
0B96  0E02      	MOVLW 0x02
0B98  6F22      	MOVWF gbl_my_ACM+D'2', 1

	my_ACM.capabilities = 0x02;										// capabilities (Device supports the request combination of Set_Line_Coding,
0B9A  6F23      	MOVWF gbl_my_ACM+D'3', 1

																	// Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State.
																	// See http://www.usb.org/developers/devclass_docs/usbcdc11.pdf p36

	// Union functional descriptor - - - - - - - - - - - - - - -
	my_union.length = sizeof(CDC_union_functional_descriptor);		// length
0B9C  0E05      	MOVLW 0x05
0B9E  0101      	MOVLB 0x01
0BA0  6FE4      	MOVWF gbl_my_union, 1

	my_union.descriptor_type = dt_CS_INTERFACE;						// descriptor_type (CS_INTERFACE = 0x24)
0BA2  0E24      	MOVLW 0x24
0BA4  6FE5      	MOVWF gbl_my_union+D'1', 1

	my_union.descriptor_subtype = 0x06;								// descriptor_subtype (Union functional descriptor subtype = 0x06)
0BA6  0E06      	MOVLW 0x06
0BA8  6FE6      	MOVWF gbl_my_union+D'2', 1

	my_union.master_interface = 0x00;								// master_interface (Controlling interface number = 0x00)
0BAA  6BE7      	CLRF gbl_my_union+D'3', 1

	my_union.slave_interface = 0x01;								// slave_interface (First slave interface = 0x01)
0BAC  0E01      	MOVLW 0x01
0BAE  6FE8      	MOVWF gbl_my_union+D'4', 1


	// Call management functional descriptor - - - - - - - - - -
	my_call_mgt.length = sizeof(CDC_call_mgt_functional_descriptor);
0BB0  0E05      	MOVLW 0x05
0BB2  6FE9      	MOVWF gbl_my_call_mgt, 1

	my_call_mgt.descriptor_type = dt_CS_INTERFACE;					// descriptor_type (CS_INTERFACE = 0x24)
0BB4  0E24      	MOVLW 0x24
0BB6  6FEA      	MOVWF gbl_my_call_mgt+D'1', 1

	my_call_mgt.descriptor_subtype = 0x01;							// descriptor_subtype (Call management functional descriptor subtype = 0x01)
0BB8  0E01      	MOVLW 0x01
0BBA  6FEB      	MOVWF gbl_my_call_mgt+D'2', 1

	my_call_mgt.capabilities = 0x00;								// capabilities
0BBC  6BEC      	CLRF gbl_my_call_mgt+D'3', 1

																	// bit 1 =0* Device sends/receives call management information only over
																	//           the Communication Class interface
																	//       =1  over data class interface
																	// bit 0 =0* Device does not handle call management itself
																	//       =1  Device handles call management itself
	my_call_mgt.data_interface = 0x01;								// Data_interface  (interface number of data class interface)
0BBE  0E01      	MOVLW 0x01
0BC0  6FED      	MOVWF gbl_my_call_mgt+D'4', 1


	// Notification endpoint descriptor - - - - - - - - - - - - -
	my_notification_ep.length = sizeof(endpoint_descriptor);		// length,
0BC2  0E07      	MOVLW 0x07
0BC4  6FCF      	MOVWF gbl_my_notification_ep, 1

	my_notification_ep.descriptor_type = dt_ENDPOINT;				// descriptor_type,
0BC6  0E05      	MOVLW 0x05
0BC8  6FD0      	MOVWF gbl_my_notification_ep+D'1', 1

	my_notification_ep.endpoint_address = 0b10000010;				// endpoint_address, (Endpoint 2, IN)
0BCA  0E82      	MOVLW 0x82
0BCC  6FD1      	MOVWF gbl_my_notification_ep+D'2', 1

	my_notification_ep.attributes = 0b00000011;						// attributes; (Interrupt)
0BCE  0E03      	MOVLW 0x03
0BD0  6FD2      	MOVWF gbl_my_notification_ep+D'3', 1

	my_notification_ep.max_packet_size = USB_EP2_IN_SIZE;			// max_packet_size;
0BD2  0E08      	MOVLW 0x08
0BD4  6FD3      	MOVWF gbl_my_notification_ep+D'4', 1
0BD6  6BD4      	CLRF gbl_my_notification_ep+D'5', 1

	my_notification_ep.interval = 2;								// interval (10ms)
0BD8  0E02      	MOVLW 0x02
0BDA  6FD5      	MOVWF gbl_my_notification_ep+D'6', 1


	// Data interface descriptor - - - - - - - - - - - -
	my_data_interface.length = sizeof(interface_descriptor);		// length,
0BDC  0E09      	MOVLW 0x09
0BDE  6F96      	MOVWF gbl_my_data_interface, 1

	my_data_interface.descriptor_type = dt_INTERFACE;				// descriptor_type,
0BE0  0E04      	MOVLW 0x04
0BE2  6F97      	MOVWF gbl_my_data_interface+D'1', 1

	my_data_interface.interface_number = 0x01;						// interface_number, (starts at zero)
0BE4  0E01      	MOVLW 0x01
0BE6  6F98      	MOVWF gbl_my_data_interface+D'2', 1

	my_data_interface.alternate_setting = 0x00;						// alternate_setting, (no alternatives)
0BE8  6B99      	CLRF gbl_my_data_interface+D'3', 1

	my_data_interface.num_endpoints = 0x02;							// num_endpoints,
0BEA  0E02      	MOVLW 0x02
0BEC  6F9A      	MOVWF gbl_my_data_interface+D'4', 1

	my_data_interface.interface_class = 0x0A;						// interface_class, (Device Interface Class)
0BEE  0E0A      	MOVLW 0x0A
0BF0  6F9B      	MOVWF gbl_my_data_interface+D'5', 1

	my_data_interface.interface_subclass = 0x00;					// interface_subclass, (Data Interface subclass)
0BF2  6B9C      	CLRF gbl_my_data_interface+D'6', 1

	my_data_interface.interface_protocol = 0x00;					// interface_protocol
0BF4  6B9D      	CLRF gbl_my_data_interface+D'7', 1

	my_data_interface.interface_string_id = 0x00;					// interface_string_id;
0BF6  6B9E      	CLRF gbl_my_data_interface+D'8', 1


	// Data OUT endpoint descriptor - - - - - - - - - - - - -
	my_data_out_ep.length = sizeof(endpoint_descriptor);			// length,
0BF8  0E07      	MOVLW 0x07
0BFA  6FD6      	MOVWF gbl_my_data_out_ep, 1

	my_data_out_ep.descriptor_type = dt_ENDPOINT;					// descriptor_type,
0BFC  0E05      	MOVLW 0x05
0BFE  6FD7      	MOVWF gbl_my_data_out_ep+D'1', 1

	my_data_out_ep.endpoint_address = 0b00000011;					// endpoint_address, (Endpoint 3, OUT)
0C00  0E03      	MOVLW 0x03
0C02  6FD8      	MOVWF gbl_my_data_out_ep+D'2', 1

	my_data_out_ep.attributes = 0b00000010;							// attributes; (Bulk)
0C04  0E02      	MOVLW 0x02
0C06  6FD9      	MOVWF gbl_my_data_out_ep+D'3', 1

	my_data_out_ep.max_packet_size = USB_EP3_OUT_SIZE;				// max_packet_size;
0C08  0E08      	MOVLW 0x08
0C0A  6FDA      	MOVWF gbl_my_data_out_ep+D'4', 1
0C0C  6BDB      	CLRF gbl_my_data_out_ep+D'5', 1

	my_data_out_ep.interval = 0;									// no interval
0C0E  6BDC      	CLRF gbl_my_data_out_ep+D'6', 1


	// Data IN endpoint descriptor - - - - - - - - - - - - -
	my_data_in_ep.length = sizeof(endpoint_descriptor);				// length,
0C10  0E07      	MOVLW 0x07
0C12  6FDD      	MOVWF gbl_my_data_in_ep, 1

	my_data_in_ep.descriptor_type = dt_ENDPOINT;					// descriptor_type,
0C14  0E05      	MOVLW 0x05
0C16  6FDE      	MOVWF gbl_my_data_in_ep+D'1', 1

	my_data_in_ep.endpoint_address = 0b10000011;					// endpoint_address, (Endpoint 3, IN)
0C18  0E83      	MOVLW 0x83
0C1A  6FDF      	MOVWF gbl_my_data_in_ep+D'2', 1

	my_data_in_ep.attributes = 0b00000010;							// attributes; (Bulk)
0C1C  0E02      	MOVLW 0x02
0C1E  6FE0      	MOVWF gbl_my_data_in_ep+D'3', 1

	my_data_in_ep.max_packet_size = USB_EP3_IN_SIZE;				// max_packet_size;
0C20  0E08      	MOVLW 0x08
0C22  6FE1      	MOVWF gbl_my_data_in_ep+D'4', 1
0C24  6BE2      	CLRF gbl_my_data_in_ep+D'5', 1

	my_data_in_ep.interval = 0;										// no interval
0C26  6BE3      	CLRF gbl_my_data_in_ep+D'6', 1


	// Collect into one enumeration structure - - - - - - - - - - - - -
	complete_serial_configuration.cdc_config = my_config;
0C28  0100      	MOVLB 0x00
0C2A  51F2      	MOVF gbl_my_config+D'8', W, 1
0C2C  6E0D      	MOVWF gbl_complete_serial_config_00000+D'8'
0C2E  51F1      	MOVF gbl_my_config+D'7', W, 1
0C30  6E0C      	MOVWF gbl_complete_serial_config_00000+D'7'
0C32  51F0      	MOVF gbl_my_config+D'6', W, 1
0C34  6E0B      	MOVWF gbl_complete_serial_config_00000+D'6'
0C36  51EF      	MOVF gbl_my_config+D'5', W, 1
0C38  6E0A      	MOVWF gbl_complete_serial_config_00000+D'5'
0C3A  51EE      	MOVF gbl_my_config+D'4', W, 1
0C3C  6E09      	MOVWF gbl_complete_serial_config_00000+D'4'
0C3E  51ED      	MOVF gbl_my_config+D'3', W, 1
0C40  6E08      	MOVWF gbl_complete_serial_config_00000+D'3'
0C42  51EC      	MOVF gbl_my_config+D'2', W, 1
0C44  6E07      	MOVWF gbl_complete_serial_config_00000+D'2'
0C46  51EB      	MOVF gbl_my_config+D'1', W, 1
0C48  6E06      	MOVWF gbl_complete_serial_config_00000+D'1'
0C4A  51EA      	MOVF gbl_my_config, W, 1
0C4C  6E05      	MOVWF gbl_complete_serial_config_00000

	complete_serial_configuration.cdc_comm_interface = my_comm_interface;
0C4E  51FB      	MOVF gbl_my_comm_interface+D'8', W, 1
0C50  6E16      	MOVWF gbl_complete_serial_config_00000+D'17'
0C52  51FA      	MOVF gbl_my_comm_interface+D'7', W, 1
0C54  6E15      	MOVWF gbl_complete_serial_config_00000+D'16'
0C56  51F9      	MOVF gbl_my_comm_interface+D'6', W, 1
0C58  6E14      	MOVWF gbl_complete_serial_config_00000+D'15'
0C5A  51F8      	MOVF gbl_my_comm_interface+D'5', W, 1
0C5C  6E13      	MOVWF gbl_complete_serial_config_00000+D'14'
0C5E  51F7      	MOVF gbl_my_comm_interface+D'4', W, 1
0C60  6E12      	MOVWF gbl_complete_serial_config_00000+D'13'
0C62  51F6      	MOVF gbl_my_comm_interface+D'3', W, 1
0C64  6E11      	MOVWF gbl_complete_serial_config_00000+D'12'
0C66  51F5      	MOVF gbl_my_comm_interface+D'2', W, 1
0C68  6E10      	MOVWF gbl_complete_serial_config_00000+D'11'
0C6A  51F4      	MOVF gbl_my_comm_interface+D'1', W, 1
0C6C  6E0F      	MOVWF gbl_complete_serial_config_00000+D'10'
0C6E  51F3      	MOVF gbl_my_comm_interface, W, 1
0C70  6E0E      	MOVWF gbl_complete_serial_config_00000+D'9'

	complete_serial_configuration.cdc_header = my_header;
0C72  505E      	MOVF gbl_my_header+D'4', W
0C74  6E1B      	MOVWF gbl_complete_serial_config_00000+D'22'
0C76  505D      	MOVF gbl_my_header+D'3', W
0C78  6E1A      	MOVWF gbl_complete_serial_config_00000+D'21'
0C7A  505C      	MOVF gbl_my_header+D'2', W
0C7C  6E19      	MOVWF gbl_complete_serial_config_00000+D'20'
0C7E  505B      	MOVF gbl_my_header+D'1', W
0C80  6E18      	MOVWF gbl_complete_serial_config_00000+D'19'
0C82  505A      	MOVF gbl_my_header, W
0C84  6E17      	MOVWF gbl_complete_serial_config_00000+D'18'

	complete_serial_configuration.cdc_ACM = my_ACM;
0C86  0102      	MOVLB 0x02
0C88  5123      	MOVF gbl_my_ACM+D'3', W, 1
0C8A  6E1F      	MOVWF gbl_complete_serial_config_00000+D'26'
0C8C  5122      	MOVF gbl_my_ACM+D'2', W, 1
0C8E  6E1E      	MOVWF gbl_complete_serial_config_00000+D'25'
0C90  5121      	MOVF gbl_my_ACM+D'1', W, 1
0C92  6E1D      	MOVWF gbl_complete_serial_config_00000+D'24'
0C94  5120      	MOVF gbl_my_ACM, W, 1
0C96  6E1C      	MOVWF gbl_complete_serial_config_00000+D'23'

	complete_serial_configuration.cdc_union = my_union;
0C98  0101      	MOVLB 0x01
0C9A  51E8      	MOVF gbl_my_union+D'4', W, 1
0C9C  6E24      	MOVWF gbl_complete_serial_config_00000+D'31'
0C9E  51E7      	MOVF gbl_my_union+D'3', W, 1
0CA0  6E23      	MOVWF gbl_complete_serial_config_00000+D'30'
0CA2  51E6      	MOVF gbl_my_union+D'2', W, 1
0CA4  6E22      	MOVWF gbl_complete_serial_config_00000+D'29'
0CA6  51E5      	MOVF gbl_my_union+D'1', W, 1
0CA8  6E21      	MOVWF gbl_complete_serial_config_00000+D'28'
0CAA  51E4      	MOVF gbl_my_union, W, 1
0CAC  6E20      	MOVWF gbl_complete_serial_config_00000+D'27'

	complete_serial_configuration.cdc_call_mgt = my_call_mgt;
0CAE  51ED      	MOVF gbl_my_call_mgt+D'4', W, 1
0CB0  6E29      	MOVWF gbl_complete_serial_config_00000+D'36'
0CB2  51EC      	MOVF gbl_my_call_mgt+D'3', W, 1
0CB4  6E28      	MOVWF gbl_complete_serial_config_00000+D'35'
0CB6  51EB      	MOVF gbl_my_call_mgt+D'2', W, 1
0CB8  6E27      	MOVWF gbl_complete_serial_config_00000+D'34'
0CBA  51EA      	MOVF gbl_my_call_mgt+D'1', W, 1
0CBC  6E26      	MOVWF gbl_complete_serial_config_00000+D'33'
0CBE  51E9      	MOVF gbl_my_call_mgt, W, 1
0CC0  6E25      	MOVWF gbl_complete_serial_config_00000+D'32'

	complete_serial_configuration.cdc_notification_ep = my_notification_ep;
0CC2  51D5      	MOVF gbl_my_notification_ep+D'6', W, 1
0CC4  6E30      	MOVWF gbl_complete_serial_config_00000+D'43'
0CC6  51D4      	MOVF gbl_my_notification_ep+D'5', W, 1
0CC8  6E2F      	MOVWF gbl_complete_serial_config_00000+D'42'
0CCA  51D3      	MOVF gbl_my_notification_ep+D'4', W, 1
0CCC  6E2E      	MOVWF gbl_complete_serial_config_00000+D'41'
0CCE  51D2      	MOVF gbl_my_notification_ep+D'3', W, 1
0CD0  6E2D      	MOVWF gbl_complete_serial_config_00000+D'40'
0CD2  51D1      	MOVF gbl_my_notification_ep+D'2', W, 1
0CD4  6E2C      	MOVWF gbl_complete_serial_config_00000+D'39'
0CD6  51D0      	MOVF gbl_my_notification_ep+D'1', W, 1
0CD8  6E2B      	MOVWF gbl_complete_serial_config_00000+D'38'
0CDA  51CF      	MOVF gbl_my_notification_ep, W, 1
0CDC  6E2A      	MOVWF gbl_complete_serial_config_00000+D'37'

	complete_serial_configuration.cdc_data_interface = my_data_interface;
0CDE  519E      	MOVF gbl_my_data_interface+D'8', W, 1
0CE0  6E39      	MOVWF gbl_complete_serial_config_00000+D'52'
0CE2  519D      	MOVF gbl_my_data_interface+D'7', W, 1
0CE4  6E38      	MOVWF gbl_complete_serial_config_00000+D'51'
0CE6  519C      	MOVF gbl_my_data_interface+D'6', W, 1
0CE8  6E37      	MOVWF gbl_complete_serial_config_00000+D'50'
0CEA  519B      	MOVF gbl_my_data_interface+D'5', W, 1
0CEC  6E36      	MOVWF gbl_complete_serial_config_00000+D'49'
0CEE  519A      	MOVF gbl_my_data_interface+D'4', W, 1
0CF0  6E35      	MOVWF gbl_complete_serial_config_00000+D'48'
0CF2  5199      	MOVF gbl_my_data_interface+D'3', W, 1
0CF4  6E34      	MOVWF gbl_complete_serial_config_00000+D'47'
0CF6  5198      	MOVF gbl_my_data_interface+D'2', W, 1
0CF8  6E33      	MOVWF gbl_complete_serial_config_00000+D'46'
0CFA  5197      	MOVF gbl_my_data_interface+D'1', W, 1
0CFC  6E32      	MOVWF gbl_complete_serial_config_00000+D'45'
0CFE  5196      	MOVF gbl_my_data_interface, W, 1
0D00  6E31      	MOVWF gbl_complete_serial_config_00000+D'44'

	complete_serial_configuration.cdc_data_out_ep = my_data_out_ep;
0D02  51DC      	MOVF gbl_my_data_out_ep+D'6', W, 1
0D04  6E40      	MOVWF gbl_complete_serial_config_00000+D'59'
0D06  51DB      	MOVF gbl_my_data_out_ep+D'5', W, 1
0D08  6E3F      	MOVWF gbl_complete_serial_config_00000+D'58'
0D0A  51DA      	MOVF gbl_my_data_out_ep+D'4', W, 1
0D0C  6E3E      	MOVWF gbl_complete_serial_config_00000+D'57'
0D0E  51D9      	MOVF gbl_my_data_out_ep+D'3', W, 1
0D10  6E3D      	MOVWF gbl_complete_serial_config_00000+D'56'
0D12  51D8      	MOVF gbl_my_data_out_ep+D'2', W, 1
0D14  6E3C      	MOVWF gbl_complete_serial_config_00000+D'55'
0D16  51D7      	MOVF gbl_my_data_out_ep+D'1', W, 1
0D18  6E3B      	MOVWF gbl_complete_serial_config_00000+D'54'
0D1A  51D6      	MOVF gbl_my_data_out_ep, W, 1
0D1C  6E3A      	MOVWF gbl_complete_serial_config_00000+D'53'

	complete_serial_configuration.cdc_data_in_ep = my_data_in_ep;
0D1E  51E3      	MOVF gbl_my_data_in_ep+D'6', W, 1
0D20  6E47      	MOVWF gbl_complete_serial_config_00000+D'66'
0D22  51E2      	MOVF gbl_my_data_in_ep+D'5', W, 1
0D24  6E46      	MOVWF gbl_complete_serial_config_00000+D'65'
0D26  51E1      	MOVF gbl_my_data_in_ep+D'4', W, 1
0D28  6E45      	MOVWF gbl_complete_serial_config_00000+D'64'
0D2A  51E0      	MOVF gbl_my_data_in_ep+D'3', W, 1
0D2C  6E44      	MOVWF gbl_complete_serial_config_00000+D'63'
0D2E  51DF      	MOVF gbl_my_data_in_ep+D'2', W, 1
0D30  6E43      	MOVWF gbl_complete_serial_config_00000+D'62'
0D32  51DE      	MOVF gbl_my_data_in_ep+D'1', W, 1
0D34  6E42      	MOVWF gbl_complete_serial_config_00000+D'61'
0D36  51DD      	MOVF gbl_my_data_in_ep, W, 1
0D38  6E41      	MOVWF gbl_complete_serial_config_00000+D'60'

}
0D3A  0012      	RETURN




void usb_get_descriptor_callback(uns8 descriptor_type, uns8 descriptor_num,

                                 uns8 **rtn_descriptor_ptr, uns16 *rtn_descriptor_size) {

	uns8 *descriptor_ptr;
	uns16 descriptor_size;

	descriptor_ptr = (uns8 *) 0;	// this means we didn't find it
02CC  6B7A      	CLRF usb_get_de_0008C_1_descrip_00091, 1
02CE  6B7B      	CLRF usb_get_de_0008C_1_descrip_00091+D'1', 1

	switch (descriptor_type) {
		case dt_DEVICE:
02D0  0574      	DECF usb_get_de_0008C_arg_descr_0008D, W, 1
02D2  E00C      	BZ	label30
02EC            label30

			descriptor_ptr = (uns8 *)&my_device_descriptor;
02EC  0E00      	MOVLW HIGH(gbl_my_device_descriptor+D'0')
02EE  6F7E      	MOVWF CompTempVar2773, 1
02F0  0E48      	MOVLW LOW(gbl_my_device_descriptor+D'0')
02F2  6F7A      	MOVWF usb_get_de_0008C_1_descrip_00091, 1
02F4  517E      	MOVF CompTempVar2773, W, 1
02F6  6F7B      	MOVWF usb_get_de_0008C_1_descrip_00091+D'1', 1

			descriptor_size = sizeof(my_device_descriptor);
02F8  0E12      	MOVLW 0x12
02FA  6F7C      	MOVWF usb_get_de_0008C_1_descrip_00092, 1
02FC  6B7D      	CLRF usb_get_de_0008C_1_descrip_00092+D'1', 1

			break;
02FE  D02F      	BRA	label36

		case dt_CONFIGURATION:
02D4  0E02      	MOVLW 0x02
02D6  6374      	CPFSEQ usb_get_de_0008C_arg_descr_0008D, 1
02D8  D001      	BRA	label28
02DA  D012      	BRA	label31
02DC            label28
02EA  D039      	BRA	label36
0300            label31
0322  D014      	BRA	label35

			descriptor_ptr = (uns8 *) &complete_serial_configuration;
0300  0E00      	MOVLW HIGH(gbl_complete_serial_config_00000+D'0')
0302  6F7E      	MOVWF CompTempVar2774, 1
0304  0E05      	MOVLW LOW(gbl_complete_serial_config_00000+D'0')
0306  6F7A      	MOVWF usb_get_de_0008C_1_descrip_00091, 1
0308  517E      	MOVF CompTempVar2774, W, 1
030A  6F7B      	MOVWF usb_get_de_0008C_1_descrip_00091+D'1', 1

			descriptor_size = sizeof(complete_serial_configuration);
030C  0E43      	MOVLW 0x43
030E  6F7C      	MOVWF usb_get_de_0008C_1_descrip_00092, 1
0310  6B7D      	CLRF usb_get_de_0008C_1_descrip_00092+D'1', 1

			break;
0312  D025      	BRA	label36

		case dt_STRING:
02DC  0E03      	MOVLW 0x03
02DE  6374      	CPFSEQ usb_get_de_0008C_arg_descr_0008D, 1
02E0  D001      	BRA	label29
02E2  D018      	BRA	label32
02E4            label29
0314            label32

			switch (descriptor_num) {
035E            label36

				case 00:
0314  5375      	MOVF usb_get_de_0008C_arg_descr_0008E, F, 1
0316  E006      	BZ	label33
0324            label33

					descriptor_size = sizeof(string_00);
0324  0E04      	MOVLW 0x04
0326  6F7C      	MOVWF usb_get_de_0008C_1_descrip_00092, 1
0328  6B7D      	CLRF usb_get_de_0008C_1_descrip_00092+D'1', 1

					descriptor_ptr = string_00;
032A  0E02      	MOVLW HIGH(gbl_string_00+D'0')
032C  6F7E      	MOVWF CompTempVar2775, 1
032E  0E24      	MOVLW LOW(gbl_string_00+D'0')
0330  6F7A      	MOVWF usb_get_de_0008C_1_descrip_00091, 1
0332  517E      	MOVF CompTempVar2775, W, 1
0334  6F7B      	MOVWF usb_get_de_0008C_1_descrip_00091+D'1', 1

					break;
0336  D013      	BRA	label36

				case 01:
0318  0575      	DECF usb_get_de_0008C_arg_descr_0008E, W, 1
031A  E00E      	BZ	label34
0338            label34

					descriptor_size = sizeof(MX_USBMFR);
0338  0E2E      	MOVLW 0x2E
033A  6F7C      	MOVWF usb_get_de_0008C_1_descrip_00092, 1
033C  6B7D      	CLRF usb_get_de_0008C_1_descrip_00092+D'1', 1

					descriptor_ptr = MX_USBMFR;
033E  0E01      	MOVLW HIGH(gbl_MX_USBMFR+D'0')
0340  6F7E      	MOVWF CompTempVar2776, 1
0342  0E40      	MOVLW LOW(gbl_MX_USBMFR+D'0')
0344  6F7A      	MOVWF usb_get_de_0008C_1_descrip_00091, 1
0346  517E      	MOVF CompTempVar2776, W, 1
0348  6F7B      	MOVWF usb_get_de_0008C_1_descrip_00091+D'1', 1

					break;
034A  D009      	BRA	label36

				case 02:
031C  0E02      	MOVLW 0x02
031E  6375      	CPFSEQ usb_get_de_0008C_arg_descr_0008E, 1
0320  D01E      	BRA	label36
034C            label35

					descriptor_size = sizeof(MX_USBNAME);
034C  0E28      	MOVLW 0x28
034E  6F7C      	MOVWF usb_get_de_0008C_1_descrip_00092, 1
0350  6B7D      	CLRF usb_get_de_0008C_1_descrip_00092+D'1', 1

					descriptor_ptr = MX_USBNAME;
0352  0E01      	MOVLW HIGH(gbl_MX_USBNAME+D'0')
0354  6F7E      	MOVWF CompTempVar2777, 1
0356  0E6E      	MOVLW LOW(gbl_MX_USBNAME+D'0')
0358  6F7A      	MOVWF usb_get_de_0008C_1_descrip_00091, 1
035A  517E      	MOVF CompTempVar2777, W, 1
035C  6F7B      	MOVWF usb_get_de_0008C_1_descrip_00091+D'1', 1

					break;

			}
			break;
		case dt_DEVICE_QUALIFIER:
02E4  0E06      	MOVLW 0x06
02E6  6374      	CPFSEQ usb_get_de_0008C_arg_descr_0008D, 1
02E8  D03A      	BRA	label36

			// we don't hfandle this, send a stall
			break;
		default:

	}
	*rtn_descriptor_ptr = descriptor_ptr;
035E  5177      	MOVF usb_get_de_0008C_arg_rtn_d_0008F+D'1', W, 1
0360  6EEA      	MOVWF FSR0H
0362  5176      	MOVF usb_get_de_0008C_arg_rtn_d_0008F, W, 1
0364  6EE9      	MOVWF FSR0L
0366  2AE9      	INCF FSR0L, F
0368  517A      	MOVF usb_get_de_0008C_1_descrip_00091, W, 1
036A  6F7E      	MOVWF CompTempVar2778, 1
036C  517B      	MOVF usb_get_de_0008C_1_descrip_00091+D'1', W, 1
036E  6EEF      	MOVWF INDF0
0370  06E9      	DECF FSR0L, F
0372  517E      	MOVF CompTempVar2778, W, 1
0374  6EEF      	MOVWF INDF0

	*rtn_descriptor_size = descriptor_size;
0376  5179      	MOVF usb_get_de_0008C_arg_rtn_d_00090+D'1', W, 1
0378  6EEA      	MOVWF FSR0H
037A  5178      	MOVF usb_get_de_0008C_arg_rtn_d_00090, W, 1
037C  6EE9      	MOVWF FSR0L
037E  2AE9      	INCF FSR0L, F
0380  517C      	MOVF usb_get_de_0008C_1_descrip_00092, W, 1
0382  6F7E      	MOVWF CompTempVar2779, 1
0384  517D      	MOVF usb_get_de_0008C_1_descrip_00092+D'1', W, 1
0386  6EEF      	MOVWF INDF0
0388  06E9      	DECF FSR0L, F
038A  517E      	MOVF CompTempVar2779, W, 1
038C  6EEF      	MOVWF INDF0

}
038E  0012      	RETURN


/*********************************************************************
 *                  Flowcode CAL ADC File
 *
 * File: PIC_CAL_ADC.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 060911 | BR | Created
 * 200911 | BR | Updated to include all ADC type files
 * 110512 | BR | Fixed a bug with ADC type 13 and Vref+
 * 161012 | BR | Fixed a bug with ADC type 32 and 10 bit instead of 12 bit
 * 171212 | BR | Moved the code to begin the sample to allow for more optimised ADC readings
 * 020713 | LM | Standard API calls
 * 240414 | LM | Additions to support Touch via ADC
 * 040215 | LM | 16F726 fix modified so as to work with 16F1937
 * 040116 | LM | medelec35 fix Vref enable for ADC Type 7 (16F883, 16F884, 16F886, 16F887)
 */


//ADC Function Prototypes
void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode);
void FC_CAL_ADC_Disable (void);
#ifdef MX_ADC_TOUCH
	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel);
#endif

//ADC Global Variables
MX_UINT8 old_tris, tris_mask;
MX_UINT8 * tris_reg;					//TRIS register pointer


// ADC Type 1 Supported Devices ************************************************************
// 16F818, 16F819, 16F873A, 16F874A, 16F876A, 16F877A,
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_1
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#define MX_ADC_TOUCH_CASE(ADC, PORT, BIT)	\
			case (ADC):							\
			tris##PORT##.##BIT = 0;				\
			port##PORT##.##BIT = 1;				\
			adcon0 = (ADC << 3) | 0xC1;			\
			adcon0.0 = 0;						\
			port##PORT##.##BIT = 0;				\
			tris##PORT##.##BIT = 1;				\
			adcon1 = 0x80;						\
			adcon0.0 = 1;						\
			adcon0.2 = 1;						\
			while (adcon0.2);					\
			result = (adresh << 8) | adresl;	\
			break;

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		MX_UINT16 result = 0;
		MX_UINT8  temp = adcon1;
		adcon1 = 0x87;				// all ports digital

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
					MX_ADC_TOUCH_CASE(0, a, 0);
			#endif
			#ifdef MX_ADC_CHANNEL_1
					MX_ADC_TOUCH_CASE(1, a, 1);
			#endif
			#ifdef MX_ADC_CHANNEL_2
					MX_ADC_TOUCH_CASE(2, a, 2);
			#endif
			#ifdef MX_ADC_CHANNEL_3
					MX_ADC_TOUCH_CASE(3, a, 3);
			#endif
			#ifdef MX_ADC_CHANNEL_4
					MX_ADC_TOUCH_CASE(4, a, 5);
			#endif
			#ifdef MX_ADC_CHANNEL_5
					MX_ADC_TOUCH_CASE(5, e, 0);
			#endif
			#ifdef MX_ADC_CHANNEL_6
					MX_ADC_TOUCH_CASE(6, e, 1);
			#endif
			#ifdef MX_ADC_CHANNEL_7
					MX_ADC_TOUCH_CASE(7, e, 2);
			#endif
		}
		adcon1 = temp;
		return result;
	}
	#endif // MX_ADC_TOUCH

#endif


// ADC Type 2 Supported Devices ************************************************************
// 16F88
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_2
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG1);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel = 0x40;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH

#endif


// ADC Type 3 Supported Devices ************************************************************
// 16F616, 16F676, 16F677, 16F684, 16F685, 16F687, 16F688, 16F689, 16F690
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_3
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = ((Conv_Speed & 0x07) << 4);				//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 4 Supported Devices ************************************************************
// 16F737, 16F747, 16F767, 16F777
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_4
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					adcon1 = 0x01;
					break;
			#endif
		}

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6));					//turn ADC on
		adcon0 = adcon0 | ((Channel & 0x07) << 3);
		adcon0 = adcon0 | ((Channel & 0x08) >> 2);
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 5 Supported Devices ************************************************************
// 12F615, 12HV615, 12F675, 12F683
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_5
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					ansel = 0x08;
					break;
			#endif
		}

		ansel = ansel | ((Conv_Speed & 0x07) << 4);				//assign conversion speed

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 6 Supported Devices ************************************************************
// 16C72, 16C72A, 16CR72, 16F72, 16C73, 16C73A, 16C73B, 16F73, 16C74, 16C74A, 16C74B, 16F74,
// 16C76, 16F76, 16C77, 16F77, 16C716, 16F716
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_6
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 + 1;

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif



// ADC Type 7 Supported Devices ************************************************************
// 16F883, 16F884, 16F886, 16F887
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_7
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (13):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x20;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 2);	//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 8 Supported Devices ************************************************************
// 16F785
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_8
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel0 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel1 = 0x08;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel0 = 0x00;
		adcon0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 9 Supported Devices ************************************************************
// 16F913, 16F914, 16F916, 16F917, 16F946
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_9
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 10 Supported Devices ***********************************************************
// 12C671, 12C672, 12CE673, 12CE674
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_10
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					if (Vref == 0)
						adcon1 = 0x06;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 11 Supported Devices ***********************************************************
// 16C717, 16C770, 16C771
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_11
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADFM);

		if (Vref != 0)											//assign VREF functionality
		{
			st_bit(adcon1, VCFG0);
			st_bit(adcon1, VCFG1);
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 12 Supported Devices ***********************************************************
// 18F6310, 18F6390, 18F6410, 18F6490, 18F6520, 18F6527, 18F6585, 18F66J60, 18F66J65,
// 18F6620, 18F6622, 18F6627, 18F6680, 18F67J60, 18F6720, 18F6722, 18F8310, 18F8390,
// 18F8410, 18F8490, 18F8520, 18F8527, 18F8585, 18F86J60, 18F86J65, 18F8620, 18F8622,
// 18F8627, 18F8680, 18F87J60, 18F8720, 18F8722, 18F96J60, 18F96J65, 18F97J60
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_12
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 13 Supported Devices ***********************************************************
// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
// 18F4680, 18F4682, 18F4685
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_13
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);								//BR changed from adcon0 05/12

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
		  #ifdef MX_ADC_BITS_12
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		  #else
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		  #endif
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 14 Supported Devices ***********************************************************
// 18F2331, 18F2431, 18F4331, 18F4431
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_14
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;											//set up ADC conversion
		adcon2 = Conv_Speed & 0x07;
		adcon3 = 0x00;
		adchs = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon0 = 0x00;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon0 = 0x04;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon0 = 0x08;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon0 = 0x0C;
					ansel0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					adcon0 = 0x00;
					adchs = 0x01;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon0 = 0x04;
					adchs = 0x10;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon0 = 0x08;
					adchs = 0x04;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon0 = 0x0C;
					adchs = 0x40;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon0 = 0x00;
					adchs = 0x02;
					ansel1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = adcon0 | 0x01;									//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 15 Supported Devices ***********************************************************
// 18F1220, 18F1320
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_15
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x7E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x7D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x7B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x77;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x6F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x5F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x3F;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x7f;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 16 Supported Devices ***********************************************************
// 18F242, 18F2439, 18F248, 18F252, 18F2539, 18F258, 18F442, 18F4439, 18F448, 18F452,
// 18F4539, 18F458
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_16
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x0A;
					else
						adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 17 Supported Devices ***********************************************************
// 18F1230, 18F1330
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_17
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;
		adcon1 = 0x00 | (0x01 << Channel);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x10;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x40;
					tris_reg = &trisa;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 18 Supported Devices ***********************************************************
// 16F722, 16F723, 16F724, 16F726, 16F727, 16F1933, 16F1934, 16F1936, 16F1937, 16F1939
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_18

	#ifndef ADREF1
		#define ADREF1 ADPREF1
	#endif

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 | (Vref & 0x03);					//Mod to allow FVR as VREF

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			#ifdef ADRESH
				iRetVal = (adresh << 2);							//10-bit ADC
				iRetVal = iRetVal | (adresl >> 6);
			#else
				iRetVal = (adres << 2);							//10-bit ADC
			#endif
		}
		else
			#ifdef ADRESH
				iRetVal = adresh;									//8-bit ADC
            #else
				iRetVal = adres;
		    #endif

		adcon0 = adcon0 | 0x02;									//begin next conversion
		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#define MX_ADC_TOUCH_CASE(ADC, PORT, BIT)	\
			case (ADC):						\
			tris##PORT##.##BIT = 0;			\
			lat##PORT##.##BIT = 1;			\
			ansel##PORT##.##BIT = 1;		\
			adcon0 = (ADC << 2) | 1;		\
			adcon0.0 = 0;					\
			lat##PORT##.##BIT = 0;			\
			tris##PORT##.##BIT = 1;			\
			adcon0 = (ADC << 2) | 1;		\
			adcon0 = (ADC << 2) | 3;		\
			while (adcon0.1);				\
			ansel##PORT##.##BIT = 0;		\
			return (adresh << 8) | adresl;

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		adcon1 = 0xf0;						// Right justified result and set FRC clock mode

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
					MX_ADC_TOUCH_CASE(0, a, 0);
			#endif
			#ifdef MX_ADC_CHANNEL_1
					MX_ADC_TOUCH_CASE(1, a, 1);
			#endif
			#ifdef MX_ADC_CHANNEL_2
					MX_ADC_TOUCH_CASE(2, a, 2);
			#endif
			#ifdef MX_ADC_CHANNEL_3
					MX_ADC_TOUCH_CASE(3, a, 3);
			#endif
			#ifdef MX_ADC_CHANNEL_4
					MX_ADC_TOUCH_CASE(4, a, 5);
			#endif
			#ifdef MX_ADC_CHANNEL_5
					MX_ADC_TOUCH_CASE(5, e, 0);
			#endif
			#ifdef MX_ADC_CHANNEL_6
					MX_ADC_TOUCH_CASE(6, e, 1);
			#endif
			#ifdef MX_ADC_CHANNEL_7
					MX_ADC_TOUCH_CASE(7, e, 2);
			#endif
			#ifdef MX_ADC_CHANNEL_8
					MX_ADC_TOUCH_CASE(8, b, 2);
			#endif
			#ifdef MX_ADC_CHANNEL_9
					MX_ADC_TOUCH_CASE(9, b, 3);
			#endif
			#ifdef MX_ADC_CHANNEL_10
					MX_ADC_TOUCH_CASE(10, b, 1);
			#endif
			#ifdef MX_ADC_CHANNEL_11
					MX_ADC_TOUCH_CASE(11, b, 4);
			#endif
			#ifdef MX_ADC_CHANNEL_12
					MX_ADC_TOUCH_CASE(12, b, 0);
			#endif
			#ifdef MX_ADC_CHANNEL_13
					MX_ADC_TOUCH_CASE(13, b, 5);
			#endif
		}
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 19 Supported Devices ***********************************************************
// 18F13K50, 18F14K50, 18LF13K50, 18LF14K50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_19
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)

	{
		adcon1 = 0;
0EAC  6AC1      	CLRF gbl_adcon1


		switch (Channel)
0EE4            label138

		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
0EAE  0E07      	MOVLW 0x07
0EB0  6359      	CPFSEQ FC_CAL_ADC_0005A_arg_Channel, 1
0EB2  D001      	BRA	label135
0EB4  D004      	BRA	label136
0EB6            label135
0EBC  D009      	BRA	label137
0EBE            label136

					tris_mask = 0x08;
0EBE  0E08      	MOVLW 0x08
0EC0  6F53      	MOVWF gbl_tris_mask, 1

					tris_reg = &trisc;
0EC2  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
0EC4  6F37      	MOVWF gbl_tris_reg+D'1', 1
0EC6  0E94      	MOVLW LOW(gbl_trisc+D'0')
0EC8  6F36      	MOVWF gbl_tris_reg, 1

					adcon1 = 0x80;
0ECA  0E80      	MOVLW 0x80
0ECC  6EC1      	MOVWF gbl_adcon1

					break;
0ECE  D00A      	BRA	label138

			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
0EB6  0E08      	MOVLW 0x08
0EB8  6359      	CPFSEQ FC_CAL_ADC_0005A_arg_Channel, 1
0EBA  D014      	BRA	label138
0ED0            label137

					tris_mask = 0x40;
0ED0  0E40      	MOVLW 0x40
0ED2  6F53      	MOVWF gbl_tris_mask, 1

					tris_reg = &trisc;
0ED4  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
0ED6  6F5D      	MOVWF CompTempVar2650, 1
0ED8  0E94      	MOVLW LOW(gbl_trisc+D'0')
0EDA  6F36      	MOVWF gbl_tris_reg, 1
0EDC  515D      	MOVF CompTempVar2650, W, 1
0EDE  6F37      	MOVWF gbl_tris_reg+D'1', 1

					anselh = 0x01;
0EE0  0E01      	MOVLW 0x01
0EE2  6E7F      	MOVWF gbl_anselh

					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate
0EE4  0E07      	MOVLW 0x07
0EE6  155A      	ANDWF FC_CAL_ADC_0005A_arg_Conv_Speed, W, 1
0EE8  6EC0      	MOVWF gbl_adcon2


		if (Vref != 0)											//assign VREF functionality
0EEA  535B      	MOVF FC_CAL_ADC_0005A_arg_Vref, F, 1
0EEC  E00A      	BZ	label139
0F02            label139

			adcon1 = adcon1 | ((Vref & 0x03) << 2);				//Mod to allow FVR as VREF
0EEE  0E03      	MOVLW 0x03
0EF0  155B      	ANDWF FC_CAL_ADC_0005A_arg_Vref, W, 1
0EF2  6F5D      	MOVWF CompTempVar2651, 1
0EF4  375D      	RLCF CompTempVar2651, F, 1
0EF6  375D      	RLCF CompTempVar2651, F, 1
0EF8  0EFC      	MOVLW 0xFC
0EFA  175D      	ANDWF CompTempVar2651, F, 1
0EFC  515D      	MOVF CompTempVar2651, W, 1
0EFE  10C1      	IORWF gbl_adcon1, W
0F00  6EC1      	MOVWF gbl_adcon1


		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
0F02  5137      	MOVF gbl_tris_reg+D'1', W, 1
0F04  6EEA      	MOVWF FSR0H
0F06  5136      	MOVF gbl_tris_reg, W, 1
0F08  6EE9      	MOVWF FSR0L
0F0A  50EF      	MOVF INDF0, W
0F0C  6F52      	MOVWF gbl_old_tris, 1

		*tris_reg = old_tris | tris_mask;
0F0E  5153      	MOVF gbl_tris_mask, W, 1
0F10  1152      	IORWF gbl_old_tris, W, 1
0F12  6F5D      	MOVWF CompTempVar2653, 1
0F14  6EEF      	MOVWF INDF0

		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
0F16  5159      	MOVF FC_CAL_ADC_0005A_arg_Channel, W, 1
0F18  6F5E      	MOVWF CompTempVar2655, 1
0F1A  375E      	RLCF CompTempVar2655, F, 1
0F1C  375E      	RLCF CompTempVar2655, F, 1
0F1E  0EFC      	MOVLW 0xFC
0F20  175E      	ANDWF CompTempVar2655, F, 1
0F22  515E      	MOVF CompTempVar2655, W, 1
0F24  0901      	IORLW 0x01
0F26  6F5D      	MOVWF CompTempVar2654, 1
0F28  515D      	MOVF CompTempVar2654, W, 1
0F2A  6EC2      	MOVWF gbl_adcon0

		delay_us(T_Charge);										//wait the acquisition time
0F2C  515C      	MOVF FC_CAL_ADC_0005A_arg_T_Charge, W, 1
0F2E  6F5D      	MOVWF delay_us_00000_arg_del, 1
0F30  EC06F000  	CALL delay_us_00000


		adcon0 = adcon0 | 0x02;									//begin next conversion
0F34  0E02      	MOVLW 0x02
0F36  10C2      	IORWF gbl_adcon0, W
0F38  6EC2      	MOVWF gbl_adcon0

	}
0F3A  0012      	RETURN


	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)

	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
0E68            label132
0E68  B2C2      	BTFSC gbl_adcon0,1
0E6A  D7FE      	BRA	label132

		if (Sample_Mode)
0E6C  5359      	MOVF FC_CAL_ADC_0005B_arg_Sample_Mode, F, 1
0E6E  E013      	BZ	label133
0E96            label133

		{
			iRetVal = (adresh << 2);							//10-bit ADC
0E70  50C4      	MOVF gbl_adresh, W
0E72  6F5A      	MOVWF FC_CAL_ADC_0005B_1_iRetVal, 1
0E74  6B5B      	CLRF FC_CAL_ADC_0005B_1_iRetVal+D'1', 1
0E76  375A      	RLCF FC_CAL_ADC_0005B_1_iRetVal, F, 1
0E78  375B      	RLCF FC_CAL_ADC_0005B_1_iRetVal+D'1', F, 1
0E7A  375A      	RLCF FC_CAL_ADC_0005B_1_iRetVal, F, 1
0E7C  375B      	RLCF FC_CAL_ADC_0005B_1_iRetVal+D'1', F, 1
0E7E  0EFC      	MOVLW 0xFC
0E80  175A      	ANDWF FC_CAL_ADC_0005B_1_iRetVal, F, 1

			iRetVal = iRetVal | (adresl >> 6);
0E82  30C3      	RRCF gbl_adresl, W
0E84  6F5C      	MOVWF CompTempVar2659, 1
0E86  335C      	RRCF CompTempVar2659, F, 1
0E88  3B5C      	SWAPF CompTempVar2659, F, 1
0E8A  0E03      	MOVLW 0x03
0E8C  175C      	ANDWF CompTempVar2659, F, 1
0E8E  515C      	MOVF CompTempVar2659, W, 1
0E90  135A      	IORWF FC_CAL_ADC_0005B_1_iRetVal, F, 1
0E92  535B      	MOVF FC_CAL_ADC_0005B_1_iRetVal+D'1', F, 1

		}
		else
0E94  D003      	BRA	label134
0E9C            label134

			iRetVal = adresh;									//8-bit ADC
0E96  50C4      	MOVF gbl_adresh, W
0E98  6F5A      	MOVWF FC_CAL_ADC_0005B_1_iRetVal, 1
0E9A  6B5B      	CLRF FC_CAL_ADC_0005B_1_iRetVal+D'1', 1


		adcon0 = adcon0 | 0x02;									//begin next conversion
0E9C  0E02      	MOVLW 0x02
0E9E  10C2      	IORWF gbl_adcon0, W
0EA0  6EC2      	MOVWF gbl_adcon0


		return (iRetVal);
0EA2  515A      	MOVF FC_CAL_ADC_0005B_1_iRetVal, W, 1
0EA4  6F5C      	MOVWF CompTempVarRet2656, 1
0EA6  515B      	MOVF FC_CAL_ADC_0005B_1_iRetVal+D'1', W, 1
0EA8  6F5D      	MOVWF CompTempVarRet2656+D'1', 1

	}
0EAA  0012      	RETURN


	void FC_CAL_ADC_Disable ()

	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
0F3C  0102      	MOVLB 0x02
0F3E  5137      	MOVF gbl_tris_reg+D'1', W, 1
0F40  6EEA      	MOVWF FSR0H
0F42  5136      	MOVF gbl_tris_reg, W, 1
0F44  6EE9      	MOVWF FSR0L
0F46  5152      	MOVF gbl_old_tris, W, 1
0F48  6EEF      	MOVWF INDF0

		ansel = 0;
0F4A  6A7E      	CLRF gbl_ansel

		adcon0 = 0x00;
0F4C  6AC2      	CLRF gbl_adcon0

		#ifdef ANSELH
			anselh = 0;
0F4E  6A7F      	CLRF gbl_anselh

		#endif
	}
0F50  0012      	RETURN


	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 20 Supported Devices ***********************************************************
// 18F23K20, 18F24K20, 18F25K20, 18F26K20, 18F43K20, 18F44K20, 18F45K20, 18F16K20
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_20
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 21 Supported Devices ***********************************************************
// 18F2xJ11, 18F4xJ11
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_21
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0xFE;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0xFD;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0xFB;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0xF7;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0xEF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ancon0 = 0xDF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ancon0 = 0xBF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ancon0 = 0x7F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ancon1 = 0x1E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ancon1 = 0x1D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ancon1 = 0x1B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ancon1 = 0x17;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ancon1 = 0x0F;
					break;
			#endif
		}

		adcon1 = Conv_Speed & 0x07;								//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0xFF;
		ancon1 = 0x1F;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 22 Supported Devices ***********************************************************
// 10F220, 10F222
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_22
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon0 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					asm("movf 1,w");
					asm("tris 6");
					adcon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					asm("movf 2,w");
					asm("tris 6");
					adcon0 = 0x84;
					break;
			#endif
		}

		adcon0 = adcon0 | 0x01;									//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;


		while (adcon0 & 0x02);
		if (Sample_Mode)
			iRetVal = (adres << 2);								//10-bit ADC
		else
			iRetVal = adres;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		adcon0 = 0x00;											//Reset ADC Registers
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 23 Supported Devices ***********************************************************
// 16F1826, 16F1827
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_23

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x80;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 | (Vref & 0x03);					//Mod to allow FVR as VREF

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 24 Supported Devices ***********************************************************
// 18F65J50, 18F66J50, 18F66J55, 18F67J50, 18F85J50, 18F86J50, 18F86J55, 18F87J50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_24
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0x00;
		ancon1 = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 25 Supported Devices ***********************************************************
// 18F66J93, 18F67J93, 18F86J93, 18F87J93, 18F66J90, 18F67J90, 18F86J90, 18F87J90
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_25
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 26 Supported Devices ***********************************************************
// 12F1822, 16F1823, 16F1824, 16F1825, 16F1828, 16F1829
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_26

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 | (Vref & 0x03);					//Mod to allow FVR as VREF

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 27 Supported Devices ***********************************************************
// 16F1946, 16F1947
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_27

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (11):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (11):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (11):
					tris_mask = 0x01;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 | (Vref & 0x03);					//Mod to allow FVR as VREF

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 28 Supported Devices ***********************************************************
// 18F65K22, 18F66K22, 18F67K22, 18F85K22, 18F86K22, 18F87K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_28
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ancon0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ancon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ancon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ancon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ancon2 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ancon2 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ancon2 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ancon2 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x08;
					tris_reg = &trish;
					ancon2 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x04;
					tris_reg = &trish;
					ancon2 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x02;
					tris_reg = &trish;
					ancon2 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x01;
					tris_reg = &trish;
					ancon2 = 0x80;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 | ((Vref & 0x03) << 4);				//Mod to allow FVR as VREF

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ancon0 = 0x00;
		#ifdef ANCON1
			ancon1 = 0x00;
		#endif
		#ifdef ANCON2
			ancon2 = 0x00;
		#endif
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 29 Supported Devices ***********************************************************
// 18F23K22, 18F24K22, 18F25K22, 18F26K22, 18F43K22, 18F44K22, 18F45K22, 18F46K22,
// 18LF23K22, 18LF24K22, 18LF25K22, 18LF26K22, 18LF43K22, 18LF44K22, 18LF45K22, 18LF46K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_29

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x20;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x01;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x02;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x04;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x08;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_24
				case (24):
					tris_mask = 0x10;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_25
				case (25):
					tris_mask = 0x20;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_26
				case (26):
					tris_mask = 0x40;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_27
				case (27):
					tris_mask = 0x80;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 | ((Vref & 0x03) << 2);				//Mod to allow FVR as VREF

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = ansel_reg | tris_mask;

		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 30 Supported Devices ************************************************************
// 16F870, 16F871, 16F872, 16F873, 16F874, 16F876, 16F877
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_30
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 31 Supported Devices ************************************************************
// 12F510, 16F506
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_31
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon0 = (0xC1 | (Conv_Speed << 4) | (Channel << 2));	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);

		iRetVal = adres;										//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 32 Supported Devices ***********************************************************
// 18F2xK80, 18F4xK80, 18F6xK80
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_32
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ancon0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ancon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ancon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ancon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ancon1 = 0x04;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
		{
			adcon1 = adcon1 | ((Vref & 0x03) << 4);				//Mod to allow FVR as VREF
		}
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0x00;
		ancon1 = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


/*********************************************************************
 *                  Flowcode CAL PWM File
 *
 * File: PIC_CAL_PWM.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 270911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 * 090413 | LM | Ports now defined by V6 PWM CAL component
 * 030713 | LM | Standard API calls
 * 250713 | LM | Upper case register name typo fix
 * 030615 | BR | PWM Allocated Timer
 * 250815 | LM | PWM1CON for 16F1508 ...
 */


#define MX_PWM_CHANNEL_X	CAL_APPEND(MX_PWM_CHANNEL_, MX_PWM_NUM)
#define MX_PWM_PORT_X		CAL_APPEND(MX_PWM_PORT_, MX_PWM_NUM)
#define MX_PWM_TRIS_X		CAL_APPEND(MX_PWM_TRIS_, MX_PWM_NUM)
#define MX_PWM_PIN_X		CAL_APPEND(MX_PWM_PIN_, MX_PWM_NUM)
#define MX_PWM_RPOR_X		CAL_APPEND(MX_PWM_RPOR_, MX_PWM_NUM)
#define MX_PWM_RPOC_X		CAL_APPEND(MX_PWM_RPOC_, MX_PWM_NUM)
#define MX_PWM_TMR_X			CAL_APPEND(MX_PWM_TMR_, 	MX_PWM_NUM)

//Work around for PWM with variable timers and 4 channels or less
#ifdef CCPTMRS
	#ifndef CCPTMRS0
		#define CCPTMRS0
		#define ccptmrs0 ccptmrs
	#endif
#endif


//I2C Master Functions
CALFUNCTION(void, FC_CAL_PWM_Enable_, (void));
CALFUNCTION(void, FC_CAL_PWM_Disable_, (void));
CALFUNCTION(void, FC_CAL_PWM_SetDuty8Bit_, (MX_UINT8 duty));
CALFUNCTION(void, FC_CAL_PWM_ChangePeriod_, (MX_UINT16 period, MX_UINT16 prescaler));
CALFUNCTION(void, FC_CAL_PWM_SetDuty10Bit_, (MX_UINT16 duty));


CALFUNCTION(void, FC_CAL_PWM_Enable_, (void))

{

 #ifdef MX_PWM

	//Remappable PWM Functionality
	#ifdef MX_PWM_REMAPPABLE
		MX_PWM_RPOR_X = MX_PWM_RPOC_X;									//Assign PWM Channel OCx -> RPx - See FCD Defines For Info
	#endif

	FC_CAL_Bit_Low_DDR (MX_PWM_PORT_X, MX_PWM_TRIS_X, MX_PWM_PIN_X);	//PWM pin is an output
0E12  9A94      	BCF gbl_trisc,5
0E14  9A82      	BCF gbl_portc,5


	#if (MX_PWM_CHANNEL_X == 1)

		//Alt Reg Functionality											//Mods for alt pin on 16F1939 family and others
		#ifdef MX_PWM_AREG_1
			MX_PWM_AREG_1 = MX_PWM_AREG_1 | MX_PWM_AMASK_1;
		#endif

		#ifdef PWM1CON
			pwm1con = 0xC0;
0E16  0EC0      	MOVLW 0xC0
0E18  6EB7      	MOVWF gbl_pwm1con

		#else
			ccp1con = 0x0C;													//Enable Capture Compare Channel 1
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 2)

		//Alt Reg Functionality											//Mods for alt pin on 16F1939 family and others
		#ifdef MX_PWM_AREG_2
			MX_PWM_AREG_2 = MX_PWM_AREG_2 | MX_PWM_AMASK_2;
		#endif

		#ifdef PWM2CON
			pwm2con = 0xC0;
		#else
			ccp2con = 0x0C;													//Enable Capture Compare Channel 2
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 3)

		//Alt Reg Functionality											//Mods for alt pin on 16F1939 family and others
		#ifdef MX_PWM_AREG_3
			MX_PWM_AREG_3 = MX_PWM_AREG_3 | MX_PWM_AMASK_3;
		#endif

		#ifdef PWM3CON
			pwm3con = 0xC0;
		#else
			ccp3con = 0x0C;													//Enable Capture Compare Channel 3 *****************************************************************
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 4)

		//Alt Reg Functionality											//Mods for alt pin on 16F1939 family and others
		#ifdef MX_PWM_AREG_4
			MX_PWM_AREG_4 = MX_PWM_AREG_4 | MX_PWM_AMASK_4;
		#endif

		#ifdef PWM4CON
			pwm4con = 0xC0;
		#else
			ccp4con = 0x0C;													//Enable Capture Compare Channel 4 *****************************************************************
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 5)

		//Alt Reg Functionality											//Mods for alt pin on 16F1939 family and others
		#ifdef MX_PWM_AREG_5
			MX_PWM_AREG_5 = MX_PWM_AREG_5 | MX_PWM_AMASK_5;
		#endif

		ccp5con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 6)

		//Alt Reg Functionality											//Mods for alt pin on 16F1939 family and others
		#ifdef MX_PWM_AREG_6
			MX_PWM_AREG_6 = MX_PWM_AREG_6 | MX_PWM_AMASK_6;
		#endif

		ccp6con = 0x0C;													//Enable Capture Compare Channel 6 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 7)

		//Alt Reg Functionality											//Mods for alt pin on 16F1939 family and others
		#ifdef MX_PWM_AREG_7
			MX_PWM_AREG_7 = MX_PWM_AREG_7 | MX_PWM_AMASK_7;
		#endif

		ccp7con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 8)

		//Alt Reg Functionality											//Mods for alt pin on 16F1939 family and others
		#ifdef MX_PWM_AREG_8
			MX_PWM_AREG_8 = MX_PWM_AREG_8 | MX_PWM_AMASK_8;
		#endif

		ccp8con = 0x0C;													//Enable Capture Compare Channel 8 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 9)

		//Alt Reg Functionality											//Mods for alt pin on 16F1939 family and others
		#ifdef MX_PWM_AREG_9
			MX_PWM_AREG_9 = MX_PWM_AREG_9 | MX_PWM_AMASK_9;
		#endif

		ccp9con = 0x0C;													//Enable Capture Compare Channel 9 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 10)

		//Alt Reg Functionality											//Mods for alt pin on 16F1939 family and others
		#ifdef MX_PWM_AREG_10
			MX_PWM_AREG_10 = MX_PWM_AREG_10 | MX_PWM_AMASK_10;
		#endif

		ccp10con = 0x0C;												//Enable Capture Compare Channel 10 *****************************************************************
	#endif

 #else
 	#warning "Hardware PWM not supported by Target microcontroller."
 	#undef MX_PWM_CHANNEL_X
 #endif

}
0E1A  0012      	RETURN



CALFUNCTION(void, FC_CAL_PWM_Disable_, (void))
{
	FC_CAL_Bit_In_DDR (MX_PWM_PORT_X, MX_PWM_TRIS_X, MX_PWM_PIN_X);		//PWM pin is an input

	#if (MX_PWM_CHANNEL_X == 1)
		#ifdef PWM1CON
			pwm1con = 0;
		#else
			ccp1con = 0x00;													//Disable Capture Compare Channel 1
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		#ifdef PWM2CON
			pwm2con = 0;
		#else
			ccp2con = 0x00;													//Disable Capture Compare Channel 2
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		#ifdef PWM3CON
			pwm3con = 0;
		#else
			ccp3con = 0x00;													//Disable Capture Compare Channel 3
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		#ifdef PWM4CON
			pwm4con = 0;
		#else
			ccp4con = 0x00;													//Disable Capture Compare Channel 4
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccp5con = 0x00;													//Disable Capture Compare Channel 5
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccp6con = 0x00;													//Disable Capture Compare Channel 6
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccp7con = 0x00;													//Disable Capture Compare Channel 7
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccp8con = 0x00;													//Disable Capture Compare Channel 8
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccp9con = 0x00;													//Disable Capture Compare Channel 9
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccp10con = 0x00;												//Disable Capture Compare Channel 10
	#endif
}


CALFUNCTION(void, FC_CAL_PWM_SetDuty8Bit_, (MX_UINT8 duty))
{
	#if (MX_PWM_CHANNEL_X == 1)
		#ifdef PWM1DCH
			pwm1dch = duty;
		#else
			ccpr1l = duty;													//Update Capture Compare Count 1
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		#ifdef PWM2DCH
			pwm2dch = duty;
		#else
			ccpr2l = duty;													//Update Capture Compare Count 2
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		#ifdef PWM3DCH
			pwm3dch = duty;
		#else
			ccpr3l = duty;													//Update Capture Compare Count 3
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		#ifdef PWM4DCH
			pwm4dch = duty;
		#else
			ccpr4l = duty;													//Update Capture Compare Count 4
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = duty;													//Update Capture Compare Count 5
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = duty;													//Update Capture Compare Count 6
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = duty;													//Update Capture Compare Count 7
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = duty;													//Update Capture Compare Count 8
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = duty;													//Update Capture Compare Count 9
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = duty;													//Update Capture Compare Count 10
	#endif
}


CALFUNCTION(void, FC_CAL_PWM_ChangePeriod_, (MX_UINT16 period, MX_UINT16 prescaler))

{
  #ifdef MX_PWM								//Hardware Mode

  	#if (MX_PWM_TMR_X == 2)

		#if (MX_PWM_CHANNEL_X == 1)
			#ifdef CCPTMRS0
				ccptmrs0 = ccptmrs0 & 0xFC;
			#endif
		#endif
		#if (MX_PWM_CHANNEL_X == 2)
			#ifdef CCPTMRS0
				ccptmrs0 = ccptmrs0 & 0xF3;
			#endif
		#endif
		#if (MX_PWM_CHANNEL_X == 3)
			#ifdef CCPTMRS0
				ccptmrs0 = ccptmrs0 & 0xCF;
			#endif
		#endif
		#if (MX_PWM_CHANNEL_X == 4)
			#ifdef CCPTMRS0
				ccptmrs0 = ccptmrs0 & 0x3F;
			#endif
		#endif
		#if (MX_PWM_CHANNEL_X == 5)
			#ifdef CCPTMRS1
				ccptmrs1 = ccptmrs1 & 0xFC;
			#endif
		#endif

		pr2 = period;
0E1C  5157      	MOVF FC_CAL_PWM_0004E_arg_period, W, 1
0E1E  6ECB      	MOVWF gbl_pr2

		switch (prescaler)
		{
			case 1:
0E20  0E01      	MOVLW 0x01
0E22  6359      	CPFSEQ FC_CAL_PWM_0004E_arg_prescaler, 1
0E24  D002      	BRA	label124
0E26  515A      	MOVF FC_CAL_PWM_0004E_arg_prescaler+D'1', W, 1
0E28  E010      	BZ	label127
0E4A            label127

				t2con = 0x04;
0E4A  0E04      	MOVLW 0x04
0E4C  6ECA      	MOVWF gbl_t2con

				break;
			case 4:
0E2A  0E04      	MOVLW 0x04
0E2C  6359      	CPFSEQ FC_CAL_PWM_0004E_arg_prescaler, 1
0E2E  D002      	BRA	label125
0E30  515A      	MOVF FC_CAL_PWM_0004E_arg_prescaler+D'1', W, 1
0E32  E00E      	BZ	label128
0E50            label128

				t2con = 0x05;
0E50  0E05      	MOVLW 0x05
0E52  6ECA      	MOVWF gbl_t2con

				break;
			case 16:
0E34  0E10      	MOVLW 0x10
0E36  6359      	CPFSEQ FC_CAL_PWM_0004E_arg_prescaler, 1
0E38  D002      	BRA	label126
0E3A  515A      	MOVF FC_CAL_PWM_0004E_arg_prescaler+D'1', W, 1
0E3C  E00C      	BZ	label129
0E56            label129

				t2con = 0x06;
0E56  0E06      	MOVLW 0x06
0E58  6ECA      	MOVWF gbl_t2con

				break;
			case 64:
0E3E  0E40      	MOVLW 0x40
0E40  6359      	CPFSEQ FC_CAL_PWM_0004E_arg_prescaler, 1
0E42  D00F      	BRA	label131
0E44  515A      	MOVF FC_CAL_PWM_0004E_arg_prescaler+D'1', W, 1
0E46  E00A      	BZ	label130
0E5C            label130

				t2con = 0x07;					//Note some earlier devices do not have the /64 option
0E5C  0E07      	MOVLW 0x07
0E5E  6ECA      	MOVWF gbl_t2con

				break;
			default:
0E48  D00C      	BRA	label131
0E62            label131

				t2con = 0x05;
0E62  0E05      	MOVLW 0x05
0E64  6ECA      	MOVWF gbl_t2con

				break;
		}
	#endif

  	#if (MX_PWM_TMR_X == 4)

		#if (MX_PWM_CHANNEL_X == 1)
			#ifdef CCPTMRS0
				ccptmrs0 = ccptmrs0 & 0xFC;
				ccptmrs0 = ccptmrs0 | 0x01;
			#endif
		#endif
		#if (MX_PWM_CHANNEL_X == 2)
			#ifdef CCPTMRS0
				ccptmrs0 = ccptmrs0 & 0xF3;
				ccptmrs0 = ccptmrs0 | 0x04;
			#endif
		#endif
		#if (MX_PWM_CHANNEL_X == 3)
			#ifdef CCPTMRS0
				ccptmrs0 = ccptmrs0 & 0xCF;
				ccptmrs0 = ccptmrs0 | 0x10;
			#endif
		#endif
		#if (MX_PWM_CHANNEL_X == 4)
			#ifdef CCPTMRS0
				ccptmrs0 = ccptmrs0 & 0x3F;
				ccptmrs0 = ccptmrs0 | 0x40;
			#endif
		#endif
		#if (MX_PWM_CHANNEL_X == 5)
			#ifdef CCPTMRS1
				ccptmrs1 = ccptmrs1 & 0xFC;
				ccptmrs1 = ccptmrs1 | 0x01;
			#endif
		#endif

		pr4 = period;
		switch (prescaler)
		{
			case 1:
				t4con = 0x04;
				break;
			case 4:
				t4con = 0x05;
				break;
			case 16:
				t4con = 0x06;
				break;
			case 64:
				t4con = 0x07;					//Note some earlier devices do not have the /64 option
				break;
			default:
				t4con = 0x05;
				break;
		}
	#endif

  	#if (MX_PWM_TMR_X == 6)

		#if (MX_PWM_CHANNEL_X == 1)
			#ifdef CCPTMRS0
				ccptmrs0 = ccptmrs0 & 0xFC;
				ccptmrs0 = ccptmrs0 | 0x02;
			#endif
		#endif
		#if (MX_PWM_CHANNEL_X == 2)
			#ifdef CCPTMRS0
				ccptmrs0 = ccptmrs0 & 0xF3;
				ccptmrs0 = ccptmrs0 | 0x08;
			#endif
		#endif
		#if (MX_PWM_CHANNEL_X == 3)
			#ifdef CCPTMRS0
				ccptmrs0 = ccptmrs0 & 0xCF;
				ccptmrs0 = ccptmrs0 | 0x20;
			#endif
		#endif
		#if (MX_PWM_CHANNEL_X == 4)
			#ifdef CCPTMRS0
				ccptmrs0 = ccptmrs0 & 0x3F;
				ccptmrs0 = ccptmrs0 | 0x80;
			#endif
		#endif
		#if (MX_PWM_CHANNEL_X == 5)
			#ifdef CCPTMRS1
				ccptmrs1 = ccptmrs1 & 0xFC;
				ccptmrs1 = ccptmrs1 | 0x02;
			#endif
		#endif

		pr6 = period;
		switch (prescaler)
		{
			case 1:
				t6con = 0x04;
				break;
			case 4:
				t6con = 0x05;
				break;
			case 16:
				t6con = 0x06;
				break;
			case 64:
				t6con = 0x07;					//Note some earlier devices do not have the /64 option
				break;
			default:
				t6con = 0x05;
				break;
		}
	#endif
  #endif
}
0E4E  0012      	RETURN
0E54  0012      	RETURN
0E5A  0012      	RETURN
0E60  0012      	RETURN
0E66  0012      	RETURN



CALFUNCTION(void, FC_CAL_PWM_SetDuty10Bit_, (MX_UINT16 duty))
{
	char nCCPxCONtemp;

	#if (MX_PWM_CHANNEL_X == 1)
		#ifdef PWM1DCH
			pwm1dch = duty >> 2;
			pwm1dcl = duty << 6;
		#else
			ccpr1l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 1
			duty = (duty & 0x03) << 4;
			nCCPxCONtemp = (ccp1con & 0xCF) | duty;
			ccp1con = nCCPxCONtemp;
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		#ifdef PWM2DCH
			pwm2dch = duty >> 2;
			pwm2dcl = duty << 6;
		#else
			ccpr2l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 2
			duty = (duty & 0x03) << 4;
			nCCPxCONtemp = (ccp2con & 0xCF) | duty;
			ccp2con = nCCPxCONtemp;
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		#ifdef PWM3DCH
			pwm3dch = duty >> 2;
			pwm3dcl = duty << 6;
		#else
			ccpr3l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 3
			duty = (duty & 0x03) << 4;
			nCCPxCONtemp = (ccp3con & 0xCF) | duty;
			ccp3con = nCCPxCONtemp;
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		#ifdef PWM4DCH
			pwm4dch = duty >> 2;
			pwm4dcl = duty << 6;
		#else
			ccpr4l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 4
			duty = (duty & 0x03) << 4;
			nCCPxCONtemp = (ccp4con & 0xCF) | duty;
			ccp4con = nCCPxCONtemp;
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 5
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp5con & 0xCF) | duty;
		ccp5con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 6
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp6con & 0xCF) | duty;
		ccp6con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 7
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp7con & 0xCF) | duty;
		ccp7con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 8
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp8con & 0xCF) | duty;
		ccp8con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 9
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp9con & 0xCF) | duty;
		ccp9con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 10
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp10con & 0xCF) | duty;
		ccp10con = nCCPxCONtemp;
	#endif
}


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EFEBF008  	GOTO	_startup

0008  EF0DF00A  	GOTO	interrupt
000C            delay_us_00000
000C            ; { delay_us ; function begin
000C            label1
000C  2F5D      	DECFSZ delay_us_00000_arg_del, F, 1
000E  D7FE      	BRA	label1
0010  0012      	RETURN
0012            ; } delay_us function end

0012            delay_ms_00000
0012            ; { delay_ms ; function begin
0012  535D      	MOVF delay_ms_00000_arg_del, F, 1
0014  0000      	NOP
0016  E101      	BNZ	label2
0018  0012      	RETURN
001A            label2
001A  0EF9      	MOVLW 0xF9
001C            label3
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0FFF      	ADDLW 0xFF
002E  A4D8      	BTFSS STATUS,Z
0030  D7F5      	BRA	label3
0032  0000      	NOP
0034  0000      	NOP
0036  0000      	NOP
0038  0000      	NOP
003A  0000      	NOP
003C  0000      	NOP
003E  0000      	NOP
0040  0000      	NOP
0042  0000      	NOP
0044  2F5D      	DECFSZ delay_ms_00000_arg_del, F, 1
0046  D7E9      	BRA	label2
0048  0012      	RETURN
004A            ; } delay_ms function end





































































04E8            memcpy8_00000
04E8            ; { memcpy8 ; function begin
04E8  516D      	MOVF memcpy8_00000_arg_dst, W, 1
04EA  6F72      	MOVWF memcpy8_00000_1_dst2, 1
04EC  516E      	MOVF memcpy8_00000_arg_dst+D'1', W, 1
04EE  6F73      	MOVWF memcpy8_00000_1_dst2+D'1', 1
04F0  516F      	MOVF memcpy8_00000_arg_src, W, 1
04F2  6F74      	MOVWF memcpy8_00000_1_src2, 1
04F4  5170      	MOVF memcpy8_00000_arg_src+D'1', W, 1
04F6  6F75      	MOVWF memcpy8_00000_1_src2+D'1', 1
04F8            label45
04F8  0E00      	MOVLW 0x00
04FA  6571      	CPFSGT memcpy8_00000_arg_len, 1
04FC  D012      	BRA	label46
04FE  5175      	MOVF memcpy8_00000_1_src2+D'1', W, 1
0500  6EEA      	MOVWF FSR0H
0502  5174      	MOVF memcpy8_00000_1_src2, W, 1
0504  6EE9      	MOVWF FSR0L
0506  4B74      	INFSNZ memcpy8_00000_1_src2, F, 1
0508  2B75      	INCF memcpy8_00000_1_src2+D'1', F, 1
050A  50EF      	MOVF INDF0, W
050C  6F76      	MOVWF CompTempVar411, 1
050E  5173      	MOVF memcpy8_00000_1_dst2+D'1', W, 1
0510  6EEA      	MOVWF FSR0H
0512  5172      	MOVF memcpy8_00000_1_dst2, W, 1
0514  6EE9      	MOVWF FSR0L
0516  4B72      	INFSNZ memcpy8_00000_1_dst2, F, 1
0518  2B73      	INCF memcpy8_00000_1_dst2+D'1', F, 1
051A  5176      	MOVF CompTempVar411, W, 1
051C  6EEF      	MOVWF INDF0
051E  0771      	DECF memcpy8_00000_arg_len, F, 1
0520  D7EB      	BRA	label45
0522            label46
0522  516D      	MOVF memcpy8_00000_arg_dst, W, 1
0524  6F76      	MOVWF CompTempVarRet410, 1
0526  516E      	MOVF memcpy8_00000_arg_dst+D'1', W, 1
0528  6F77      	MOVWF CompTempVarRet410+D'1', 1
052A  0012      	RETURN
052C            ; } memcpy8 function end



























































































11D6            _startup
11D6  0ED5      	MOVLW 0xD5
11D8  0100      	MOVLB 0x00
11DA  6FFC      	MOVWF gbl_14_LSR, 1
11DC  0EC4      	MOVLW 0xC4
11DE  6FFD      	MOVWF gbl_14_LSR+D'1', 1
11E0  0EBB      	MOVLW 0xBB
11E2  6FFE      	MOVWF gbl_14_LSR+D'2', 1
11E4  0EDC      	MOVLW 0xDC
11E6  6FFF      	MOVWF gbl_14_LSR+D'3', 1
11E8  0101      	MOVLB 0x01
11EA  6BEE      	CLRF gbl_15_gbl_aSig, 1
11EC  6BEF      	CLRF gbl_15_gbl_aSig+D'1', 1
11EE  6BF0      	CLRF gbl_15_gbl_aSig+D'2', 1
11F0  6BF1      	CLRF gbl_15_gbl_aSig+D'3', 1
11F2  6BF2      	CLRF gbl_15_gbl_bSig, 1
11F4  6BF3      	CLRF gbl_15_gbl_bSig+D'1', 1
11F6  6BF4      	CLRF gbl_15_gbl_bSig+D'2', 1
11F8  6BF5      	CLRF gbl_15_gbl_bSig+D'3', 1
11FA  6BF6      	CLRF gbl_15_gbl_zSig, 1
11FC  6BF7      	CLRF gbl_15_gbl_zSig+D'1', 1
11FE  6BF8      	CLRF gbl_15_gbl_zSig+D'2', 1
1200  6BF9      	CLRF gbl_15_gbl_zSig+D'3', 1
1202  0102      	MOVLB 0x02
1204  6B3A      	CLRF gbl_15_gbl_aExp, 1
1206  6B3B      	CLRF gbl_15_gbl_bExp, 1
1208  0101      	MOVLB 0x01
120A  6BFE      	CLRF gbl_15_gbl_zExp, 1
120C  6BFF      	CLRF gbl_15_gbl_zExp+D'1', 1
120E  0102      	MOVLB 0x02
1210  6B3C      	CLRF gbl_15_gbl_aSign, 1
1212  6B3D      	CLRF gbl_15_gbl_bSign, 1
1214  6B3E      	CLRF gbl_15_gbl_zSign, 1
1216  6B3F      	CLRF gbl_15_gbl_zSigZero, 1
1218  0101      	MOVLB 0x01
121A  6BFA      	CLRF gbl_15_gbl_ret, 1
121C  6BFB      	CLRF gbl_15_gbl_ret+D'1', 1
121E  6BFC      	CLRF gbl_15_gbl_ret+D'2', 1
1220  6BFD      	CLRF gbl_15_gbl_ret+D'3', 1
1222  0102      	MOVLB 0x02
1224  6B38      	CLRF gbl_float_rounding_mode, 1
1226  6B39      	CLRF gbl_float_exception_flags, 1
1228  6A5F      	CLRF gbl_float_detect_tininess



1416  EF95F008  	GOTO	main

300000  3238      	DW 0x3238
300002  1E1F      	DW 0x1E1F
300004  8808      	DW 0x8808
300006  C003      	DW 0xC003
300008  E003      	DW 0xE003
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
